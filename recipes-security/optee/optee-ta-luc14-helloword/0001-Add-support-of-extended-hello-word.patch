From 24a020db895a9bbfab292742d0f667f6375a4d01 Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@linaro.org>
Date: Fri, 23 Jan 2015 15:15:31 +0100
Subject: [PATCH] Add support of extended hello word

Signed-off-by: Christophe Priouzeau <christophe.priouzeau@linaro.org>
---
 host_ext/Makefile                                  |  24 ++
 host_ext/helloworld_params.c                       | 272 ++++++++++++++
 host_ext/tee_ut_hello.c                            | 204 +++++++++++
 ta/hellota_ext_ta/Makefile                         |  20 ++
 .../faked_armv7_uta_signed_header.bin              | Bin 0 -> 336 bytes
 ta/hellota_ext_ta/hellota_ta.c                     | 233 ++++++++++++
 ta/hellota_ext_ta/hellota_ta.h                     |  42 +++
 ta/hellota_ext_ta/sub.mk                           |   2 +
 ta/hellota_ext_ta/user_ta_header_defines.h         |  43 +++
 ta/helloworld_ext_ta/Makefile                      |  20 ++
 .../faked_armv7_uta_signed_header.bin              | Bin 0 -> 336 bytes
 ta/helloworld_ext_ta/hello_world_params.c          | 145 ++++++++
 ta/helloworld_ext_ta/hello_world_ta.c              | 394 +++++++++++++++++++++
 ta/helloworld_ext_ta/hello_world_ta.h              |  35 ++
 ta/helloworld_ext_ta/sub.mk                        |   3 +
 ta/helloworld_ext_ta/user_ta_header_defines.h      |  38 ++
 16 files changed, 1475 insertions(+)
 create mode 100644 host_ext/Makefile
 create mode 100644 host_ext/helloworld_params.c
 create mode 100644 host_ext/tee_ut_hello.c
 create mode 100644 ta/hellota_ext_ta/Makefile
 create mode 100644 ta/hellota_ext_ta/faked_armv7_uta_signed_header.bin
 create mode 100644 ta/hellota_ext_ta/hellota_ta.c
 create mode 100644 ta/hellota_ext_ta/hellota_ta.h
 create mode 100644 ta/hellota_ext_ta/sub.mk
 create mode 100644 ta/hellota_ext_ta/user_ta_header_defines.h
 create mode 100644 ta/helloworld_ext_ta/Makefile
 create mode 100644 ta/helloworld_ext_ta/faked_armv7_uta_signed_header.bin
 create mode 100644 ta/helloworld_ext_ta/hello_world_params.c
 create mode 100644 ta/helloworld_ext_ta/hello_world_ta.c
 create mode 100644 ta/helloworld_ext_ta/hello_world_ta.h
 create mode 100644 ta/helloworld_ext_ta/sub.mk
 create mode 100644 ta/helloworld_ext_ta/user_ta_header_defines.h

diff --git a/host_ext/Makefile b/host_ext/Makefile
new file mode 100644
index 0000000..aa76d18
--- /dev/null
+++ b/host_ext/Makefile
@@ -0,0 +1,24 @@
+
+#CC      = $(CROSS_COMPILE)gcc
+#LD      = $(CROSS_COMPILE)ld
+#AR      = $(CROSS_COMPILE)ar
+#NM      = $(CROSS_COMPILE)nm
+#OBJCOPY = $(CROSS_COMPILE)objcopy
+#OBJDUMP = $(CROSS_COMPILE)objdump
+#READELF = $(CROSS_COMPILE)readelf
+
+OBJS = tee_ut_hello.o
+OBJS += helloworld_params.o
+
+CFLAGS += -Wall -I../ta/hellota_ext_ta -I../ta/helloworld_ext_ta -I$(TEEC_EXPORT)/include
+LDADD += -lteec -L$(TEEC_EXPORT)/lib
+
+.PHONY: all
+all: hello_world_ext
+
+hello_world_ext: $(OBJS)
+	$(CC) $(LDADD) -o $@ $(OBJS)
+
+.PHONY: clean
+clean:
+	rm -f $(OBJS) hello_world
diff --git a/host_ext/helloworld_params.c b/host_ext/helloworld_params.c
new file mode 100644
index 0000000..4b08920
--- /dev/null
+++ b/host_ext/helloworld_params.c
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2014, STMicroelectronics All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "tee_client_api.h"
+
+extern int verbose;
+
+int test_add_value(TEEC_Context *ctx, TEEC_Session *sess, unsigned int cmd)
+{
+	char prelog1[] = "Test params by value in/out";
+	char prelog2[] = "Test params by value in/value out";
+	TEEC_Result restee;			/* Result of the operation - Error or not */
+	TEEC_Operation op;			/* Parameters of the command we run */
+	unsigned int erroru32;			/* error code for more information about the error */
+	int v1, v2, v3, v4, loop, ret;
+
+	ret = 0;
+
+	/*
+	 * Test case 1:
+	 * param[i].value.a = param[i].value.a + param[i].value.b
+	 */
+	v1 = 1000000000; /* more than 16bit covered */
+	v2 = 1;
+	v3 = v1 + v2;
+
+	for (loop = 0; loop < 4; loop++) {
+
+		memset(&op, 0, sizeof(op));
+		op.paramTypes =
+			(loop == 0) ? TEEC_PARAM_TYPES(TEEC_VALUE_INOUT, TEEC_NONE, TEEC_NONE, TEEC_NONE) :
+			(loop == 1) ? TEEC_PARAM_TYPES(TEEC_NONE, TEEC_VALUE_INOUT, TEEC_NONE, TEEC_NONE) :
+			(loop == 2) ? TEEC_PARAM_TYPES(TEEC_NONE, TEEC_NONE, TEEC_VALUE_INOUT, TEEC_NONE) :
+			TEEC_PARAM_TYPES(TEEC_NONE, TEEC_NONE, TEEC_NONE, TEEC_VALUE_INOUT);
+		op.params[loop].value.a = v1;
+		op.params[loop].value.b = v2;
+		restee = TEEC_InvokeCommand(sess, cmd, &op, &erroru32);
+		if (restee != TEEC_SUCCESS) {
+			printf("Error: %s #%d FAILED: TEEC_InvokeCommand failed, retval=%d=0x%X, origin=%d\n",
+				prelog1, loop, restee, restee, erroru32);
+			return -1;
+		}
+		if ((int)op.params[loop].value.a != v3) {
+			printf("Error: %s #%d FAILED: unexpeted result: %d + %d = %d, expected %d\n",
+				prelog1, loop, v1, v2, op.params[loop].value.a, v3);
+			ret = -1;
+			break;
+		} else if (verbose) {
+			printf("%s #%d => OK (%d+%d=%d)\n", prelog1, loop, v1, v2, op.params[loop].value.a);
+		}
+	}
+
+	/*
+	 * Test case 2:
+	 * param[i].value.a = param[j].value.a + param[k].value.a + param[l].value.a
+	 * param[i].value.b = param[j].value.b + param[k].value.b + param[l].value.b
+	 *
+	 * for simplicity, use value.b = -value.a and test a signed addition.
+	 */
+	v1 = 1000000000; /* more than 16bit covered */
+	v2 = 1000;
+	v3 = 1;
+	v4 = v1 + v2 + v3;
+
+	for (loop = 0; loop < 4; loop++) {
+
+		memset(&op, 0, sizeof(op));
+
+		switch(loop) {
+		case 0:
+			op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_OUTPUT, TEEC_VALUE_INPUT,
+						TEEC_VALUE_INPUT, TEEC_VALUE_INPUT);
+			op.params[1].value.a = v1;
+			op.params[2].value.a = v2;
+			op.params[3].value.a = v3;
+			op.params[1].value.b = -v1;
+			op.params[2].value.b = -v2;
+			op.params[3].value.b = -v3;
+			break;
+		case 1:
+			op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INPUT, TEEC_VALUE_OUTPUT,
+						TEEC_VALUE_INPUT, TEEC_VALUE_INPUT);
+			op.params[0].value.a = v1;
+			op.params[2].value.a = v2;
+			op.params[3].value.a = v3;
+			op.params[0].value.b = -v1;
+			op.params[2].value.b = -v2;
+			op.params[3].value.b = -v3;
+			break;
+		case 2:
+			op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INPUT, TEEC_VALUE_INPUT,
+						TEEC_VALUE_OUTPUT, TEEC_VALUE_INPUT);
+			op.params[0].value.a = v1;
+			op.params[1].value.a = v2;
+			op.params[3].value.a = v3;
+			op.params[0].value.b = -v1;
+			op.params[1].value.b = -v2;
+			op.params[3].value.b = -v3;
+			break;
+		case 3:
+			op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INPUT, TEEC_VALUE_INPUT,
+						TEEC_VALUE_INPUT, TEEC_VALUE_OUTPUT);
+			op.params[0].value.a = v1;
+			op.params[1].value.a = v2;
+			op.params[2].value.a = v3;
+			op.params[0].value.b = -v1;
+			op.params[1].value.b = -v2;
+			op.params[2].value.b = -v3;
+			break;
+		}
+
+		restee = TEEC_InvokeCommand(sess, cmd, &op, &erroru32);
+		if (restee != TEEC_SUCCESS) {
+			printf("Error: %s #%d FAILED: TEEC_InvokeCommand failed, retval=%d=0x%X, origin=%d\n",
+				prelog2, loop, restee, restee, erroru32);
+			return -1;
+		}
+		if ((int)op.params[loop].value.a != v4) {
+			printf("Error: %s #%d FAILED: unexpeted result in 'value.a': %d + %d + %d = %d, expected %d\n",
+				prelog2, loop, v1, v2, v3, op.params[loop].value.a, v4);
+			ret = -1;
+			break;
+		}
+		if ((int)op.params[loop].value.b != -v4) {
+			printf("Error: %s #%d FAILED: unexpeted result in 'value.b': %d + %d + %d = %d, expected %d\n",
+				prelog2, loop, -v1, -v2, -v3, op.params[loop].value.a, -v4);
+			ret = -1;
+			break;
+		} else if (verbose) {
+			printf("%s #%d => OK (%d+%d+%d=%d)\n", prelog2, loop, v1, v2, v3, op.params[loop].value.a);
+		}
+	}
+
+out:
+	return ret;
+}
+
+int test_add_memref(TEEC_Context *ctx, TEEC_Session *sess, unsigned int cmd)
+{
+	char prelog1[] = "Test params by temporary shared mem";
+	char prelog2[] = "Test params by registered shared mem";
+	TEEC_Result restee;			/* Result of the operation - Error or not */
+	TEEC_Operation op;			/* Parameters of the command we run */
+	unsigned int erroru32;			/* error code for more information about the error */
+	TEEC_SharedMemory shm;			/* shared memory */
+	unsigned char inb1[256], inb2[256], out, ob1[256];
+	int i, size, loop, ret;
+
+	size = 250;
+	if ((size + 3) > sizeof(inb1)) {
+		printf("value \"size\" is too big.. abort test....");
+		return -1;
+	}
+
+	ret = 0;
+
+	/* test susing temporary shared memory reference parameters */
+	for (loop = 0; loop < 4; loop++) {
+
+		/* fill input buffer and compute out value */
+		out = 0;
+		for (i = 0; i < size; i++) {
+			inb1[i] = (unsigned char)((i + loop + 3) & 0xFF);
+			out += (unsigned char)((i + loop + 3) & 0xFF);
+		}
+
+		/* invoke buffer addition using temporary memory references */
+		memset(&op, 0, sizeof(op));
+		op.paramTypes =
+			(loop == 0) ? TEEC_PARAM_TYPES(TEEC_MEMREF_TEMP_INOUT, TEEC_NONE, TEEC_NONE, TEEC_NONE) :
+			(loop == 1) ? TEEC_PARAM_TYPES(TEEC_NONE, TEEC_MEMREF_TEMP_INOUT, TEEC_NONE, TEEC_NONE) :
+			(loop == 2) ? TEEC_PARAM_TYPES(TEEC_NONE, TEEC_NONE, TEEC_MEMREF_TEMP_INOUT, TEEC_NONE) :
+			TEEC_PARAM_TYPES(TEEC_NONE, TEEC_NONE, TEEC_NONE, TEEC_MEMREF_TEMP_INOUT);
+		op.params[loop].tmpref.buffer = inb1;
+		op.params[loop].tmpref.size = size;
+
+		restee = TEEC_InvokeCommand(sess, cmd, &op, &erroru32);
+		if (restee != TEEC_SUCCESS) {
+			printf("Error: %s #%d FAILED:\n=> invoke_cmd failed: retval=%d=0x%X, origin=%d\n",
+				prelog1, loop, restee, restee, erroru32);
+			return -1;
+		}
+		if (inb1[0] != out) {
+			printf("Error: %s #%d FAILED:\n=> unexpected results: sum(in[0..%d]) = 0x%02X, expected 0x%02X\n",
+				prelog1, loop, size - 1, inb1[0], out);
+			ret = -1;
+		} else if (verbose) {
+			printf("%s #%d => OK (sum(in[0..%d])=0x%02X)\n", prelog1, loop, size - 1, out);
+		}
+	}
+
+	/* test using registered shared memory reference parameters */
+	for (loop = 0; loop < 4; loop++) {
+
+		size_t offset = loop;
+
+		/* fill input buffer and compute out value */
+		out = 0;
+		for (i = 0; i < size; i++) {
+			inb1[i + offset] = (unsigned char)((i + loop) & 0xFF);
+			out += (unsigned char)((i + loop) & 0xFF);
+		}
+
+		/* allocate registered shared memory */
+		memset(&shm, 0, sizeof(shm));
+		shm.size = sizeof(inb1);
+		shm.flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+		restee = TEEC_AllocateSharedMemory(ctx, &shm);
+		if (restee != TEEC_SUCCESS) {
+			printf("%s %d: TEEC_AllocateSharedMemory failed, retval=%d=0x%X\n",
+				prelog2, loop, restee, restee);
+			return -1;
+		}
+
+		/* invoke buffer addition using registered memory references */
+		memcpy(shm.buffer, inb1, shm.size);
+
+		memset(&op, 0, sizeof(op));
+		op.paramTypes =
+			(loop == 0) ? TEEC_PARAM_TYPES(TEEC_MEMREF_PARTIAL_INOUT, TEEC_NONE, TEEC_NONE, TEEC_NONE) :
+			(loop == 1) ? TEEC_PARAM_TYPES(TEEC_NONE, TEEC_MEMREF_PARTIAL_INOUT, TEEC_NONE, TEEC_NONE) :
+			(loop == 2) ? TEEC_PARAM_TYPES(TEEC_NONE, TEEC_NONE, TEEC_MEMREF_PARTIAL_INOUT, TEEC_NONE) :
+			TEEC_PARAM_TYPES(TEEC_NONE, TEEC_NONE, TEEC_NONE, TEEC_MEMREF_PARTIAL_INOUT);
+		op.params[loop].memref.parent = &shm;
+		op.params[loop].memref.size = size;
+		op.params[loop].memref.offset = offset;
+
+		restee = TEEC_InvokeCommand(sess, cmd, &op, &erroru32);
+		if (restee != TEEC_SUCCESS) {
+			printf("Error: %s #%d FAILED:\n=> invoke_cmd failed: retval=%d=0x%X, origin=%d\n",
+				prelog2, loop, restee, restee, erroru32);
+			return -1;
+		}
+		if (*((unsigned char *)shm.buffer + offset) != out) {
+			printf("Error: %s #%d FAILED:\n=> unexpeted result sum(in[%d..%d]) = 0x%02X, expected 0x%02X\n",
+				prelog2, loop, offset, offset + size - 1, *((unsigned char *)shm.buffer + offset), out);
+			ret = -1;
+		} else if (verbose) {
+			printf("%s #%d => OK (sum(in[%d..%d])=0x%02X)\n", prelog2, loop, offset, offset + size - 1, out);
+		}
+
+		TEEC_ReleaseSharedMemory(&shm);
+	}
+
+	return ret;
+}
diff --git a/host_ext/tee_ut_hello.c b/host_ext/tee_ut_hello.c
new file mode 100644
index 0000000..469b664
--- /dev/null
+++ b/host_ext/tee_ut_hello.c
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2014, STMicroelectronics All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <hello_world_ta.h>
+#include <hellota_ta.h>
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "tee_client_api.h"
+
+int verbose = 1;
+
+int test_add_value(TEEC_Context *ctx, TEEC_Session *sess, unsigned int cmd);
+int test_add_memref(TEEC_Context *ctx, TEEC_Session *sess, unsigned int cmd);
+
+static char gDevName[32] = "teetz";
+
+int main(int argc, char *argv[])
+{
+	TEEC_Result restee;		/* Result of the operation - Error or not */
+	TEEC_Context teeContext;	/*Context of the TEE */
+	TEEC_Session teeSession;	/* Session of this TA call */
+	TEEC_Operation op;		/* Parameters of the command we run */
+	TEEC_UUID helloworld_uuid = TA_HELLO_WORLD_UUID;
+	TEEC_UUID hellota_uuid = TA_HELLO_TA_UUID;
+	unsigned int erroru32;		/* error code for more information about the error */
+	int ret;
+	size_t test_cnt;
+	int test_memref_ret;
+
+	if (argc > 1) {
+		strncpy(gDevName, argv[1], sizeof(gDevName));
+		gDevName[sizeof(gDevName) - 1] = '\0';
+	}
+	printf("Use [%s]\n", gDevName);
+	test_cnt = 0;
+
+	/* Initialize the context */
+	printf("Init context\n");
+	restee = TEEC_InitializeContext(gDevName, &teeContext);
+	if (restee != TEEC_SUCCESS) {
+		printf("Error: TEEC_InitializeContext failed, retval=%d=0x%X\n", restee, restee);
+		return -1;
+	}
+
+	/*
+	 * Test user TA 'hello world' from NonSecure: open session, send test commands, close session
+	 */
+	printf("Test #%d - Open Session from NonSecure to \"user TA\"\n", test_cnt);
+	restee = TEEC_OpenSession(&teeContext, &teeSession, &helloworld_uuid, TEEC_LOGIN_PUBLIC, NULL, NULL, &erroru32);
+	if (restee != TEEC_SUCCESS) {
+		printf("Error: TEEC_OpenSession failed, retval=%d=0x%X, origin=%d\n", restee, restee, erroru32);
+		return -1;
+	}
+	printf("Test #%d - \"NonSecure\" to \"user TA\": 'trace' command\n", test_cnt);
+	memset(&op, 0, sizeof(op));
+	restee = TEEC_InvokeCommand(&teeSession, TA_HELLO_WORLD_CMD_PRINT_HELLO_WORLD, &op, &erroru32);
+	if (restee != TEEC_SUCCESS) {
+		printf("Error: TEEC_InvokeCommand failed, retval=%d=0x%X, origin=%d\n", restee, restee, erroru32);
+		return -1;
+	}
+	printf("Test #%d - \"NonSecure\" to \"user TA\": 'value param' tests\n", test_cnt);
+	ret = test_add_value(&teeContext, &teeSession, TA_HELLO_WORLD_CMD_PARAMS);
+	if (ret) {
+		printf("Error: Test userTA through userTA failed on 'value' parameters\n");
+		return ret;
+	}
+	printf("Test #%d - \"NonSecure\" to \"user TA\": 'memref param' tests\n", test_cnt);
+	ret = test_add_memref(&teeContext, &teeSession, TA_HELLO_WORLD_CMD_PARAMS);
+	if (ret) {
+		printf("Error: Test \"NonSecure\" to \"user TA\" failed on 'memref' parameters\n");
+		return ret;
+	}
+
+	/* nicely close the pending sessions */
+	printf("Close pending sessions\n");
+	TEEC_CloseSession(&teeSession);
+
+	/*
+	 * Test user TA (helloworld) through a user TA (hellota): open session, send test commands.
+	 */
+	test_cnt++;
+	printf("Test #%d - Open Session from NonSecure to \"user TA\"\n", test_cnt);
+	restee = TEEC_OpenSession(&teeContext, &teeSession, &hellota_uuid, TEEC_LOGIN_PUBLIC, NULL, NULL, &erroru32);
+	if (restee != TEEC_SUCCESS) {
+		printf("Error: TEEC_OpenSession failed, retval=%d=0x%X, origin=%d\n", restee, restee, erroru32);
+		return -1;
+	}
+
+	printf("Test #%d - Open Session from \"user TA\" to \"user TA\"\n", test_cnt);
+	memset(&op, 0, sizeof(op));
+	restee = TEEC_InvokeCommand(&teeSession, TA_HELLO_TA_CMD_OPEN_UTA, &op, &erroru32);
+	if (restee != TEEC_SUCCESS) {
+		printf("Error: TEEC_InvokeCommand failed, retval=%d=0x%X, origin=%d\n", restee, restee, erroru32);
+		return -1;
+	}
+
+	printf("Test #%d - Close Session from \"user TA\" to \"user TA\"\n", test_cnt);
+	memset(&op, 0, sizeof(op));
+	restee = TEEC_InvokeCommand(&teeSession, TA_HELLO_TA_CMD_CLOSE_UTA, &op, &erroru32);
+	if (restee != TEEC_SUCCESS) {
+		printf("Error: TEEC_InvokeCommand failed, retval=%d=0x%X, origin=%d\n", restee, restee, erroru32);
+		return -1;
+	}
+
+	test_cnt++;
+	printf("Test #%d - Open Session from \"user TA\" to \"user TA\"\n", test_cnt);
+	memset(&op, 0, sizeof(op));
+	restee = TEEC_InvokeCommand(&teeSession, TA_HELLO_TA_CMD_OPEN_UTA, &op, &erroru32);
+	if (restee != TEEC_SUCCESS) {
+		printf("Error: TEEC_InvokeCommand failed, retval=%d=0x%X, origin=%d\n", restee, restee, erroru32);
+		return -1;
+	}
+
+	printf("Test #%d - \"user TA\" to \"user TA\": 'trace' command test\n", test_cnt);
+	memset(&op, 0, sizeof(op));
+	restee = TEEC_InvokeCommand(&teeSession, TA_HELLO_TA_CMD_TRACE_UTA, &op, &erroru32);
+	if (restee != TEEC_SUCCESS) {
+		printf("Error: TEEC_InvokeCommand failed, retval=%d=0x%X, origin=%d\n", restee, restee, erroru32);
+		return -1;
+	}
+	printf("Test #%d - \"user TA\" to \"user TA\": 'value param' test \n", test_cnt);
+	ret = test_add_value(&teeContext, &teeSession, TA_HELLO_TA_CMD_TEST_UTA_NSEC_PARAMS);
+	if (ret) {
+		printf("Error: Test \"user TA\" to \"user TA\" failed on 'value' parameters\n\n");
+		return ret;
+	}
+
+	/*
+	 * Test user TA through a user TA: run memref params tests from
+	 * various memory section (NSec shm, TA stack, TA heap, TA code).
+	 */
+	test_memref_ret = 0;
+	test_cnt++;
+	printf("Test #%d - \"user TA\" to \"user TA\": NSec 'memref param' tests\n", test_cnt);
+	ret = test_add_memref(&teeContext, &teeSession, TA_HELLO_TA_CMD_TEST_UTA_NSEC_PARAMS);
+	if (ret) {
+		printf("\nError: Test userTA through userTA failed on 'NSec memref' parameters\n\n");
+		test_memref_ret = ret;
+	}
+
+	test_cnt++;
+	printf("Test #%d - \"user TA\" to \"user TA\": TA stack 'memref param' tests\n", test_cnt);
+	ret = test_add_memref(&teeContext, &teeSession, TA_HELLO_TA_CMD_TEST_UTA_STACK_PARAMS);
+	if (ret) {
+		printf("\nError: Test userTA through userTA failed on 'Stack memref' parameters\n\n");
+		test_memref_ret = ret;
+	}
+
+	test_cnt++;
+	printf("Test #%d - \"user TA\" to \"user TA\": TA heap 'memref param' tests\n", test_cnt);
+	ret = test_add_memref(&teeContext, &teeSession, TA_HELLO_TA_CMD_TEST_UTA_HEAP_PARAMS);
+	if (ret) {
+		printf("\nError: Test userTA through userTA failed on 'Heap memref' parameters\n\n");
+		test_memref_ret = ret;
+	}
+
+	test_cnt++;
+	printf("Test #%d - \"user TA\" to \"user TA\": TA code 'memref param' tests\n", test_cnt);
+	ret = test_add_memref(&teeContext, &teeSession, TA_HELLO_TA_CMD_TEST_UTA_CODE_PARAMS);
+	if (ret) {
+		printf("\nError: Test \"user TA\" to \"user TA\" failed on 'Code memref' parameters\n\n");
+		test_memref_ret = ret;
+	}
+
+	if (test_memref_ret)
+		return test_memref_ret;
+
+	/* nicely close the pending sessions */
+	printf("Close pending sessions\n");
+	memset(&op, 0, sizeof(op));
+	restee = TEEC_InvokeCommand(&teeSession, TA_HELLO_TA_CMD_CLOSE_UTA, &op, &erroru32);
+	if (restee != TEEC_SUCCESS) {
+		printf("Error: TEEC_InvokeCommand failed, retval=%d=0x%X, origin=%d\n", restee, restee, erroru32);
+		return -1;
+	}
+	TEEC_CloseSession(&teeSession);
+
+	return ret;
+}
+
diff --git a/ta/hellota_ext_ta/Makefile b/ta/hellota_ext_ta/Makefile
new file mode 100644
index 0000000..652e736
--- /dev/null
+++ b/ta/hellota_ext_ta/Makefile
@@ -0,0 +1,20 @@
+# variables expected from caller:
+#  TEMPDIR    location where TA source files are built.
+#  TA_DEVKIT  location of the delivered TA devkit.
+# other varaible are default set from TA devkit 'config.mk'
+
+BINARY = 1b990126-6c04-11e4-8ad5101f74f39d1d
+CFG_TEE_PREFIXTOADD = hellota_ta
+
+include $(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk
+
+all: $(BINARY).ta
+
+$(BINARY).ta: $(BINARY).bin
+	rm -f $@
+	cat ../faked_armv7_uta_signed_header.bin $< > $@
+
+clean: clean_ta_file
+.PHONY: clean_ta_file
+clean_ta_file:
+	rm -f $(BINARY).ta
diff --git a/ta/hellota_ext_ta/faked_armv7_uta_signed_header.bin b/ta/hellota_ext_ta/faked_armv7_uta_signed_header.bin
new file mode 100644
index 0000000000000000000000000000000000000000..7d5d2ad2e0f99dea3886ff550f143df5fc79ec96
GIT binary patch
literal 336
zcmWG?@dyrJWME`sU|?VbVh}9=#31kiB!C9qFJB_M_2H7=s}IckS|9hK>iUA(%B}xz
z_@yy+8^(lwa`o$D@OpOc*;4H}yM&zDf2lCmhiQ8~Sju?&SNntNeXnlSwYhuTnJu}e
z`D*6$CF0BcYCdG!hSjaAxbsOZwWONO-^uKgg!0D5Z5K8lPXEZSd~n+aw&1g8xuZ<l
zUJ1B7o{%b0aj|b+d&Gtvn#s23LhsnLNAS)t`jdP#BhSgZC?sLa<oLa3&usg@tbU!G
zPpn3?_)q;)d0HE5=Dfe?a!4llsu@SokE=8C3Ko`~|F{0auUmV(Kb`z-<QHT0_RNl?
zkc0+q<GX1=%!jQG^zmH1m#whN{M&A^885Q-E?m)eX#?wtB)=_BWb!IioU%HYUpVUW
Yt$3R{?Mhtm;w=l;h1_1$8h$bn0NvV{!~g&Q

literal 0
HcmV?d00001

diff --git a/ta/hellota_ext_ta/hellota_ta.c b/ta/hellota_ext_ta/hellota_ta.c
new file mode 100644
index 0000000..682b508
--- /dev/null
+++ b/ta/hellota_ext_ta/hellota_ta.c
@@ -0,0 +1,233 @@
+/*
+ * Copyright (c) 2014, STMicroelectronics All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#define STR_TRACE_USER_TA "HELLOTA_TA"
+
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+#include "hellota_ta.h"
+#include "../helloworld_ext_ta/hello_world_ta.h"
+
+static TEE_TASessionHandle ta_session;
+
+static TEE_UUID uta_uuid = TA_HELLO_WORLD_UUID;
+
+static TEE_Result test_ta_open(TEE_UUID *uuid)
+{
+	TEE_Result ret;
+	uint32_t orig;
+
+	if (ta_session != 0) {
+		EMSG("session is already opened towards TA");
+		return TEE_ERROR_GENERIC;
+	}
+	ret = TEE_OpenTASession(uuid, 0, 0, NULL, &ta_session, &orig);
+	if (ret != TEE_SUCCESS) {
+		EMSG("Open session with TA failed 0x%X/%d", (unsigned int)ret, (int)orig);
+		return TEE_ERROR_GENERIC;
+	}
+
+	if (ta_session == 0) {
+		EMSG("Unexpected null session handler: panic !");
+		TEE_Panic(0);
+	}
+
+	return TEE_SUCCESS;
+}
+
+static TEE_Result test_ta_close(void)
+{
+	if (ta_session == 0) {
+		EMSG("No session already opened towards TA");
+		return TEE_ERROR_GENERIC;
+	}
+	TEE_CloseTASession(ta_session);
+	ta_session = 0;
+
+	return TEE_SUCCESS;
+}
+
+static TEE_Result test_ta_invoke(uint32_t cmd,
+				uint32_t ptypes, TEE_Param p[4])
+{
+	TEE_Result ret;
+	uint32_t orig;
+
+	if (ta_session == 0) {
+		EMSG("error: no session opened towards TA");
+		return TEE_ERROR_GENERIC;
+	}
+	ret = TEE_InvokeTACommand(ta_session, 0, cmd, ptypes, p, &orig);
+	if (ret != TEE_SUCCESS) {
+		EMSG("Invoke TA failed 0x%X/%d", (unsigned int)ret, (int)orig);
+		return TEE_ERROR_GENERIC;
+	}
+	return ret;
+}
+
+static TEE_Result test_ta_trace(void)
+{
+	TEE_Param loc_params[4];
+	uint32_t cmd;
+
+	cmd = TA_HELLO_WORLD_CMD_PRINT_HELLO_WORLD;
+
+	TEE_MemFill(loc_params, 0, sizeof(loc_params));
+	return test_ta_invoke(cmd, 0, loc_params);
+}
+
+/*
+ * NSec provide parameters: TA shall invoke "param test" command to TA
+ * with memref argument from different parts of the TA memory space
+ *
+ * from NSecure shared memory: preserve incoming memref location
+ * from TA private RAM (stack, heap, rw data): copy incoming data to target
+ * tested location
+ */
+#define TEST_MEMREF_MAX_SIZE	256
+static unsigned char initdata_buffer[TEST_MEMREF_MAX_SIZE] = { 1 };
+
+
+/*
+ * NSec provide parameters: TA shall invoke "param test" command to  TA
+ * with memref argument from TA "stack" memory instead of NSec pristine memref.
+ */
+static TEE_Result test_ta_memref_params(TEE_UUID *uuid, uint32_t cmd_in,
+				uint32_t ptypes, TEE_Param p[4])
+{
+	unsigned char *loc_buffer, stack_buffer[TEST_MEMREF_MAX_SIZE];
+	TEE_Param loc_params[4];
+	TEE_Result ret;
+	size_t id;
+	uint32_t cmd;
+
+        (void)&uuid; /* Unused parameter */
+
+	cmd = TA_HELLO_WORLD_CMD_PARAMS;
+
+	if (ptypes == TEE_PARAM_TYPE_SET(TEE_PARAM_TYPE_MEMREF_INOUT, 0))
+		id = 0;
+	else if (ptypes == TEE_PARAM_TYPE_SET(TEE_PARAM_TYPE_MEMREF_INOUT, 1))
+		id = 1;
+	else if (ptypes == TEE_PARAM_TYPE_SET(TEE_PARAM_TYPE_MEMREF_INOUT, 2))
+		id = 2;
+	else if (ptypes == TEE_PARAM_TYPE_SET(TEE_PARAM_TYPE_MEMREF_INOUT, 3))
+		id = 3;
+	else
+		return test_ta_invoke(cmd, ptypes, p);
+
+	if ((p[id].memref.size == 0) ||
+		(p[id].memref.size > TEST_MEMREF_MAX_SIZE)) {
+		EMSG("invalid size: param#%d size=%d", id, p[id].memref.size);
+		return TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	TEE_MemFill(loc_params, 0, sizeof(loc_params));
+
+	loc_buffer = NULL;
+	if (cmd_in == TA_HELLO_TA_CMD_TEST_UTA_STACK_PARAMS)
+		loc_buffer = stack_buffer;
+	else if (cmd_in == TA_HELLO_TA_CMD_TEST_UTA_CODE_PARAMS)
+		loc_buffer = initdata_buffer;
+	else if (cmd_in == TA_HELLO_TA_CMD_TEST_UTA_HEAP_PARAMS) {
+		loc_buffer = TEE_Malloc(p[id].memref.size, 0);
+		if (loc_buffer == NULL)
+			return TEE_ERROR_OUT_OF_MEMORY;
+	}
+
+	if (loc_buffer != NULL) {
+		TEE_MemMove(loc_buffer, p[id].memref.buffer, p[id].memref.size);
+		loc_params[id].memref.buffer = loc_buffer;
+		loc_params[id].memref.size = p[id].memref.size;
+	}
+
+	if (cmd_in == TA_HELLO_TA_CMD_TEST_UTA_NSEC_PARAMS)
+		ret = test_ta_invoke(cmd, ptypes, p);
+	else
+		ret = test_ta_invoke(cmd, ptypes, loc_params);
+
+	if (loc_buffer != NULL) {
+		if (p[id].memref.size <= loc_params[id].memref.size)
+			TEE_MemMove(p[id].memref.buffer, loc_buffer,
+					loc_params[id].memref.size);
+		p[id].memref.size = loc_params[id].memref.size;
+
+	}
+
+	if (cmd_in == TA_HELLO_TA_CMD_TEST_UTA_HEAP_PARAMS)
+		TEE_Free(loc_buffer);
+
+	return ret;
+}
+
+/*
+ * Trusted Application Entry Points
+ */
+
+TEE_Result TA_CreateEntryPoint(void)
+{
+	return TEE_SUCCESS;
+}
+
+void TA_DestroyEntryPoint(void)
+{
+	return;
+}
+
+TEE_Result TA_OpenSessionEntryPoint(uint32_t t, TEE_Param p[4], void **c)
+{
+        (void)t;
+        (void)p;
+        (void)c;
+    return TEE_SUCCESS;
+}
+
+void TA_CloseSessionEntryPoint(void *sess)
+{
+	(void)&sess; /* Unused parameter */
+	return;
+}
+
+TEE_Result TA_InvokeCommandEntryPoint(void *sess, uint32_t cmd,
+				uint32_t ptypes, TEE_Param p[4])
+{
+        (void)&sess; /* Unused parameter */
+	switch (cmd) {
+	case TA_HELLO_TA_CMD_OPEN_UTA:
+		return test_ta_open(&uta_uuid);
+	case TA_HELLO_TA_CMD_CLOSE_UTA:
+		return test_ta_close();
+	case TA_HELLO_TA_CMD_TRACE_UTA:
+		return test_ta_trace();
+	case TA_HELLO_TA_CMD_TEST_UTA_NSEC_PARAMS:
+	case TA_HELLO_TA_CMD_TEST_UTA_STACK_PARAMS:
+	case TA_HELLO_TA_CMD_TEST_UTA_HEAP_PARAMS:
+	case TA_HELLO_TA_CMD_TEST_UTA_CODE_PARAMS:
+		return test_ta_memref_params(&uta_uuid, cmd, ptypes, p);
+	default:
+		break;
+	}
+	return TEE_ERROR_BAD_PARAMETERS;
+}
diff --git a/ta/hellota_ext_ta/hellota_ta.h b/ta/hellota_ext_ta/hellota_ta.h
new file mode 100644
index 0000000..2d4e430
--- /dev/null
+++ b/ta/hellota_ext_ta/hellota_ta.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2014, STMicroelectronics All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef HELLO_TA_HELLOWORLD_H
+#define HELLO_TA_HELLOWORLD_H
+
+#define TA_HELLO_TA_UUID { 0x1b990126, 0x6c04, 0x11e4, \
+			{ 0x8a, 0xd5, 0x10, 0x1f, 0x74, 0xf3, 0x9d, 0x1d } }
+
+enum hello_ta_cmd {
+	TA_HELLO_TA_CMD_OPEN_UTA,
+	TA_HELLO_TA_CMD_CLOSE_UTA,
+	TA_HELLO_TA_CMD_TRACE_UTA,
+	TA_HELLO_TA_CMD_TEST_UTA_NSEC_PARAMS,
+	TA_HELLO_TA_CMD_TEST_UTA_STACK_PARAMS,
+	TA_HELLO_TA_CMD_TEST_UTA_HEAP_PARAMS,
+	TA_HELLO_TA_CMD_TEST_UTA_CODE_PARAMS,
+};
+
+#endif
diff --git a/ta/hellota_ext_ta/sub.mk b/ta/hellota_ext_ta/sub.mk
new file mode 100644
index 0000000..b7e13cd
--- /dev/null
+++ b/ta/hellota_ext_ta/sub.mk
@@ -0,0 +1,2 @@
+global-incdirs-y += .
+srcs-y += hellota_ta.c
diff --git a/ta/hellota_ext_ta/user_ta_header_defines.h b/ta/hellota_ext_ta/user_ta_header_defines.h
new file mode 100644
index 0000000..81977d3
--- /dev/null
+++ b/ta/hellota_ext_ta/user_ta_header_defines.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2014, STMicroelectronics All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef USER_TA_HEADER_DEFINES_H
+#define USER_TA_HEADER_DEFINES_H
+
+#include <hellota_ta.h>
+#include <user_ta_header.h>
+
+#define TA_UUID		TA_HELLO_TA_UUID
+
+#define TA_FLAGS	(TA_FLAG_MULTI_SESSION | TA_FLAG_EXEC_DDR)
+#define TA_STACK_SIZE	(2 * 1024)
+#define TA_DATA_SIZE	(32 * 1024)
+
+#define TA_CURRENT_TA_EXT_PROPERTIES \
+	{ "gp.ta.description", USER_TA_PROP_TYPE_STRING, \
+		"Hello 'Static TA HelloWorld' Application" }, \
+	{ "gp.ta.version", USER_TA_PROP_TYPE_U32, &(const uint32_t){ 0x0100 } }
+
+#endif /*USER_TA_HEADER_DEFINES_H*/
diff --git a/ta/helloworld_ext_ta/Makefile b/ta/helloworld_ext_ta/Makefile
new file mode 100644
index 0000000..19aa945
--- /dev/null
+++ b/ta/helloworld_ext_ta/Makefile
@@ -0,0 +1,20 @@
+# variables expected from caller:
+#  TEMPDIR    location where TA source files are built.
+#  TA_DEVKIT  location of the delivered TA devkit.
+# other varaible are default set from TA devkit 'config.mk'
+
+BINARY = 1ca38dfc-6c04-11e4-9dbb101f74f39d1d
+CFG_TEE_PREFIXTOADD = hello_world
+
+include $(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk
+
+all: $(BINARY).ta
+
+$(BINARY).ta: $(BINARY).bin
+	rm -f $@
+	cat ../faked_armv7_uta_signed_header.bin $< > $@
+
+clean: clean_ta_file
+.PHONY: clean_ta_file
+clean_ta_file:
+	rm -f $(BINARY).ta
diff --git a/ta/helloworld_ext_ta/faked_armv7_uta_signed_header.bin b/ta/helloworld_ext_ta/faked_armv7_uta_signed_header.bin
new file mode 100644
index 0000000000000000000000000000000000000000..7d5d2ad2e0f99dea3886ff550f143df5fc79ec96
GIT binary patch
literal 336
zcmWG?@dyrJWME`sU|?VbVh}9=#31kiB!C9qFJB_M_2H7=s}IckS|9hK>iUA(%B}xz
z_@yy+8^(lwa`o$D@OpOc*;4H}yM&zDf2lCmhiQ8~Sju?&SNntNeXnlSwYhuTnJu}e
z`D*6$CF0BcYCdG!hSjaAxbsOZwWONO-^uKgg!0D5Z5K8lPXEZSd~n+aw&1g8xuZ<l
zUJ1B7o{%b0aj|b+d&Gtvn#s23LhsnLNAS)t`jdP#BhSgZC?sLa<oLa3&usg@tbU!G
zPpn3?_)q;)d0HE5=Dfe?a!4llsu@SokE=8C3Ko`~|F{0auUmV(Kb`z-<QHT0_RNl?
zkc0+q<GX1=%!jQG^zmH1m#whN{M&A^885Q-E?m)eX#?wtB)=_BWb!IioU%HYUpVUW
Yt$3R{?Mhtm;w=l;h1_1$8h$bn0NvV{!~g&Q

literal 0
HcmV?d00001

diff --git a/ta/helloworld_ext_ta/hello_world_params.c b/ta/helloworld_ext_ta/hello_world_params.c
new file mode 100644
index 0000000..47b7891
--- /dev/null
+++ b/ta/helloworld_ext_ta/hello_world_params.c
@@ -0,0 +1,145 @@
+/*
+ * Copyright STMicroelectronics 2013
+ */
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+
+TEE_Result helloworld_entry_params(uint32_t ptypes, TEE_Param p[4]);
+
+/*
+ * Supported tests on parameters
+ * (I, J, K, L refer to param index)
+ *
+ * Case 1: command parameters type are: 1 in/out value, 3 empty.
+ *         => process outI.a = inI.a + inI.b
+ * Case 2: command parameters type are: 3 input value, 1 output value
+ *         => process = outI.a = inJ.a + inK.a + inL.a
+ * Case 3: command parameters type are: 1 in/out memref, 3 empty.
+ *         => process = outI[0] = sum(inI[0..len-1])
+ */
+TEE_Result helloworld_entry_params(uint32_t param_types, TEE_Param params[4])
+{
+    size_t i;
+    uint8_t d8, *in;
+
+    /* case 1a: 1 input/output value argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_VALUE_INOUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_NONE)) {
+        params[0].value.a = params[0].value.a + params[0].value.b;
+        return TEE_SUCCESS;
+    }
+    /* case 1b: 1 input/output value argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_VALUE_INOUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_NONE)) {
+        params[1].value.a = params[1].value.a + params[1].value.b;
+        return TEE_SUCCESS;
+    }
+    /* case 1c: 1 input/output value argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_VALUE_INOUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_NONE)) {
+        params[2].value.a = params[2].value.a + params[2].value.b;
+        return TEE_SUCCESS;
+    }
+    /* case 1d: 1 input/output value argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_VALUE_INOUT)) {
+        params[3].value.a = params[3].value.a + params[3].value.b;
+        return TEE_SUCCESS;
+    }
+
+    /* case 2a: 3 input value arguments, 1 output value argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_VALUE_OUTPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_VALUE_INPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_VALUE_INPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_VALUE_INPUT)) {
+        params[0].value.a = params[1].value.a + params[2].value.a + params[3].value.a;
+        params[0].value.b = params[1].value.b + params[2].value.b + params[3].value.b;
+        return TEE_SUCCESS;
+    }
+    /* case 2a: 3 input value arguments, 1 output value argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_VALUE_INPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_VALUE_OUTPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_VALUE_INPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_VALUE_INPUT)) {
+        params[1].value.a = params[0].value.a + params[2].value.a + params[3].value.a;
+        params[1].value.b = params[0].value.b + params[2].value.b + params[3].value.b;
+        return TEE_SUCCESS;
+    }
+    /* case 2a: 3 input value arguments, 1 output value argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_VALUE_INPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_VALUE_INPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_VALUE_OUTPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_VALUE_INPUT)) {
+        params[2].value.a = params[0].value.a + params[1].value.a + params[3].value.a;
+        params[2].value.b = params[0].value.b + params[1].value.b + params[3].value.b;
+        return TEE_SUCCESS;
+    }
+    /* case 2a: 3 input value arguments, 1 output value argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_VALUE_INPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_VALUE_INPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_VALUE_INPUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_VALUE_OUTPUT)) {
+        params[3].value.a = params[0].value.a + params[1].value.a + params[2].value.a;
+        params[3].value.b = params[0].value.b + params[1].value.b + params[2].value.b;
+        return TEE_SUCCESS;
+    }
+
+    /* case 3a: 1 in/out memref argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_MEMREF_INOUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_NONE)) {
+        in = (uint8_t *)params[0].memref.buffer;
+        d8 = 0;
+        for (i = 0; i < params[0].memref.size; i++)
+            d8 += in[i];
+        *(uint8_t *)params[0].memref.buffer = d8;
+        return TEE_SUCCESS; //TEE_SUCCESS;
+    }
+    /* case 3b: 1 in/out memref argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_MEMREF_INOUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_NONE)) {
+        in = (uint8_t *)params[1].memref.buffer;
+        d8 = 0;
+        for (i = 0; i < params[1].memref.size; i++)
+            d8 += in[i];
+        *(uint8_t *)params[1].memref.buffer = d8;
+        return TEE_SUCCESS;
+    }
+    /* case 3c: 1 in/out memref argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_MEMREF_INOUT) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_NONE)) {
+        in = (uint8_t *)params[2].memref.buffer;
+        d8 = 0;
+        for (i = 0; i < params[2].memref.size; i++)
+            d8 += in[i];
+        *(uint8_t *)params[2].memref.buffer = d8;
+        return TEE_SUCCESS;
+    }
+    /* case 3d: 1 in/out memref argument */
+    if ((TEE_PARAM_TYPE_GET(param_types, 0) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 1) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 2) == TEE_PARAM_TYPE_NONE) &&
+        (TEE_PARAM_TYPE_GET(param_types, 3) == TEE_PARAM_TYPE_MEMREF_INOUT)) {
+        in = (uint8_t *)params[3].memref.buffer;
+        d8 = 0;
+        for (i = 0; i < params[3].memref.size; i++)
+            d8 += in[i];
+        *(uint8_t *)params[3].memref.buffer = d8;
+        return TEE_SUCCESS;
+    }
+
+    return TEE_ERROR_BAD_PARAMETERS;
+}
diff --git a/ta/helloworld_ext_ta/hello_world_ta.c b/ta/helloworld_ext_ta/hello_world_ta.c
new file mode 100644
index 0000000..b4f3ea8
--- /dev/null
+++ b/ta/helloworld_ext_ta/hello_world_ta.c
@@ -0,0 +1,394 @@
+/**
+ * Copyright (C) STM 2013. All rights reserved.
+ * This code is ST-Ericsson proprietary and confidential.
+ * Any use of the code for whatever purpose is subject to
+ * specific written permission of STM.
+ *
+ */
+
+#define STR_TRACE_USER_TA "HELLO_WORLD-TA"
+
+#include <tee_internal_api.h>
+#include <tee_internal_api_extensions.h>
+
+#include "hello_world_ta.h"
+
+/*
+ * Forward Declarations
+ */
+
+static TEE_Result print_hello_world(uint32_t param_types, TEE_Param params[4]);
+static TEE_Result add(uint32_t param_types, TEE_Param params[4]);
+static TEE_Result set_global(uint32_t param_types, TEE_Param params[4]);
+static TEE_Result get_global(uint32_t param_types, TEE_Param params[4]);
+static TEE_Result getsystemtime(uint32_t param_types, TEE_Param params[4]);
+static TEE_Result getreetime(uint32_t param_types, TEE_Param params[4]);
+static TEE_Result getpersistanttime(uint32_t param_types, TEE_Param params[4]);
+static TEE_Result setpersistanttime(uint32_t param_types, TEE_Param params[4]);
+static TEE_Result teewait(uint32_t param_types, TEE_Param params[4]);
+static TEE_Result incvalue(uint32_t param_types, TEE_Param params[4]);
+extern TEE_Result helloworld_entry_params(uint32_t ptypes, TEE_Param p[4]);
+
+static int _globalvalue=0;
+
+/*
+ * Trusted Application Entry Points
+ */
+
+/* Called each time a new instance is created */
+TEE_Result TA_EXPORT TA_CreateEntryPoint(void)
+{
+    DMSG("TA_CreateEntryPoint of Hello World TA\n");
+    return TEE_SUCCESS;
+}
+
+/* Called each time an instance is destroyed */
+void TA_EXPORT TA_DestroyEntryPoint(void)
+{
+    DMSG("TA_DestroyEntryPoint of Hello World TA\n");
+}
+
+/* Called each time a session is opened */
+TEE_Result TA_EXPORT TA_OpenSessionEntryPoint(uint32_t nParamTypes,
+                TEE_Param  pParams[4], void **ppSessionContext)
+{
+    (void)nParamTypes;
+    (void)pParams;
+    (void)ppSessionContext;
+    DMSG("TA_OpenSessionEntryPoint of Hello World TA\n");
+    return TEE_SUCCESS;
+}
+
+/* Called each time a session is closed */
+void TA_EXPORT TA_CloseSessionEntryPoint(void *pSessionContext)
+{
+   (void)pSessionContext;
+    DMSG("TA_CloseSessionEntryPoint of Hello World TA\n");
+}
+
+/* Called when a command is invoked */
+TEE_Result TA_EXPORT TA_InvokeCommandEntryPoint(
+    void *pSessionContext, uint32_t nCommandID, uint32_t nParamTypes,
+    TEE_Param pParams[4])
+{
+    (void)pSessionContext;
+    switch (nCommandID) {
+    case TA_HELLO_WORLD_CMD_PRINT_HELLO_WORLD:
+        return print_hello_world(nParamTypes, pParams);
+    case TA_HELLO_WORLD_CMD_ADD:
+        return add(nParamTypes, pParams);
+    case TA_HELLO_WORLD_CMD_SETGLOBAL:
+        return set_global(nParamTypes, pParams);
+    case TA_HELLO_WORLD_CMD_GETGLOBAL:
+        return get_global(nParamTypes, pParams);
+    case TA_HELLO_WORLD_CMD_GETREETIME:
+        return getreetime(nParamTypes, pParams);
+    case TA_HELLO_WORLD_CMD_GETPERSISTANTTIME:
+        return getpersistanttime(nParamTypes, pParams);
+    case TA_HELLO_WORLD_CMD_SETPERSISTANTTIME:
+        return setpersistanttime(nParamTypes, pParams);
+    case TA_HELLO_WORLD_CMD_WAIT:
+        return teewait(nParamTypes, pParams);
+    case TA_HELLO_WORLD_CMD_GETSYSTEMTIME:
+       return getsystemtime(nParamTypes, pParams);
+    case TA_HELLO_WORLD_CMD_INCVALUE:
+        return incvalue(nParamTypes, pParams);
+    case TA_HELLO_WORLD_CMD_PARAMS:
+        return helloworld_entry_params(nParamTypes, pParams);
+
+    default:
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+}
+
+/*
+ * Functions corresponding to command id
+ */
+
+
+/* TA_HELLO_WORLD_CMD_PRINT_HELLO_WORLD */
+static TEE_Result print_hello_world(uint32_t param_types, TEE_Param params[4])
+{
+    TEE_Result res;
+    TEE_PropSetHandle propHandle;
+    char name_buffer[80];
+    char value_buffer[80];
+    size_t name_size;
+    size_t value_size;
+    uint32_t version;
+
+    (void)param_types;
+    (void)params;
+    INMSG("print");
+
+EMSG("HELLOOOOOOOOOOOOOOOOOO WOLRD !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
+
+    // retrieve and display a specific TA property
+    value_size = sizeof(value_buffer);
+    res = TEE_GetPropertyAsString(TEE_PROPSET_CURRENT_TA, (char *)"gp.ta.description", value_buffer, &value_size);
+    if (res == TEE_SUCCESS) {
+        printf("TA Property: description='%s'\n", value_buffer);
+    } else {
+        EMSG("TEE_GetPropertyAsString: returned 0x%x\n", (int)res);
+        goto out;
+    }
+    res = TEE_GetPropertyAsU32(TEE_PROPSET_CURRENT_TA, (char *)"gp.ta.version", &version);
+    if (res == TEE_SUCCESS) {
+        printf("TA Property: version=%u.%u\n", (int)version>>8, (int)version&0xFF);
+    } else {
+        EMSG("TEE_GetPropertyAsU32: returned 0x%x\n", (int)res);
+        goto out;
+    }
+
+    // retrieve and display all TA properties
+    res = TEE_AllocatePropertyEnumerator(&propHandle);
+    if (res != TEE_SUCCESS) {
+        EMSG("TEE_AllocatePropertyEnumerator: returned 0x%x\n", (int)res);
+        goto out;
+    }
+
+    TEE_StartPropertyEnumerator(propHandle, TEE_PROPSET_CURRENT_TA);
+    while (true) {
+        name_size = sizeof(name_buffer);
+        res = TEE_GetPropertyName(propHandle, name_buffer, &name_size);
+        if (res != TEE_SUCCESS) {
+            EMSG("TEE_GetPropertyName: returned 0x%x\n", (int)res);
+            goto out;
+        }
+        value_size = sizeof(value_buffer);
+        res = TEE_GetPropertyAsString(propHandle, NULL, value_buffer, &value_size);
+        if (res != TEE_SUCCESS) {
+            EMSG("TEE_GetPropertyAsString: returned 0x%x\n", (int)res);
+            goto out;
+        }
+        if (res == TEE_SUCCESS) {
+            printf("Found property: %s='%s'\n", name_buffer, value_buffer);
+        }
+        res = TEE_GetNextProperty(propHandle);
+        if (res == TEE_ERROR_ITEM_NOT_FOUND) {
+            res = TEE_SUCCESS;
+            break;
+        }
+    }
+    TEE_FreePropertyEnumerator(propHandle);
+
+out:
+    OUTMSG();
+    return res;
+}
+
+static TEE_Result add(uint32_t param_types, TEE_Param params[4])
+{
+    TEE_Result res = TEE_SUCCESS;
+    t_add *pAdd;
+    int i;
+
+    INMSG("add");
+
+    // Param 0 is a memref, input/output
+    if (TEE_PARAM_TYPE_MEMREF_INOUT != TEE_PARAM_TYPE_GET(param_types, 0)) {
+        EMSG("Wrong parameter 0 type: %d instead of %d\n", (int)TEE_PARAM_TYPE_GET(param_types, 0), TEE_PARAM_TYPE_MEMREF_INOUT);
+        res = TEE_ERROR_BAD_PARAMETERS;
+        goto out;
+    }
+
+    // Other parameters must be of type TEE_PARAM_TYPE_NONE
+    for (i=1; i<4; i++) {
+        if (TEE_PARAM_TYPE_NONE != TEE_PARAM_TYPE_GET(param_types, i)) {
+            EMSG("Wrong parameter %d type: %d instead of %d\n", i, (int)TEE_PARAM_TYPE_GET(param_types, i), TEE_PARAM_TYPE_NONE);
+            res = TEE_ERROR_BAD_PARAMETERS;
+            goto out;
+        }
+    }
+
+    // check the size of parameter 0
+    if(params[0].memref.size != sizeof(t_add)) {
+        EMSG("Wrong parameter size: %d instead of %d\n", params[0].memref.size, sizeof(t_add));
+        res = TEE_ERROR_BAD_PARAMETERS;
+        goto out;
+    }
+
+    pAdd = (t_add *)params[0].memref.buffer;
+    pAdd->out = pAdd->in1 + pAdd->in2;
+    DMSG("%d + %d = %d\n", pAdd->in1, pAdd->in2, pAdd->out);
+
+out:
+    OUTMSG();
+    return res;
+}
+
+
+static TEE_Result set_global(uint32_t param_types, TEE_Param params[4])
+{
+    int i;
+
+    // Param 0 is a memref, input/output
+    if (TEE_PARAM_TYPE_VALUE_INPUT != TEE_PARAM_TYPE_GET(param_types, 0)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    // Other parameters must be of type TEE_PARAM_TYPE_NONE
+    for (i=1; i<4; i++) {
+        if (TEE_PARAM_TYPE_NONE != TEE_PARAM_TYPE_GET(param_types, i)) {
+            return TEE_ERROR_BAD_PARAMETERS;
+        }
+    }
+
+    _globalvalue = params[0].value.a;
+    return TEE_SUCCESS;
+}
+
+static TEE_Result get_global(uint32_t param_types, TEE_Param params[4])
+{
+    int i;
+
+    // Param 0 is a memref, input/output
+    if (TEE_PARAM_TYPE_VALUE_OUTPUT != TEE_PARAM_TYPE_GET(param_types, 0)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    // Other parameters must be of type TEE_PARAM_TYPE_NONE
+    for (i=1; i<4; i++) {
+        if (TEE_PARAM_TYPE_NONE != TEE_PARAM_TYPE_GET(param_types, i)) {
+            return TEE_ERROR_BAD_PARAMETERS;
+        }
+    }
+
+    params[0].value.a = _globalvalue;
+    return TEE_SUCCESS;
+}
+
+static TEE_Result getsystemtime(uint32_t param_types, TEE_Param params[4])
+{
+    TEE_Time time;
+    int i;
+
+    // Param 0 is an output value
+    if (TEE_PARAM_TYPE_VALUE_OUTPUT != TEE_PARAM_TYPE_GET(param_types, 0)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    // Other parameters must be of type TEE_PARAM_TYPE_NONE
+    for (i=1; i<4; i++) {
+        if (TEE_PARAM_TYPE_NONE != TEE_PARAM_TYPE_GET(param_types, i)) {
+            return TEE_ERROR_BAD_PARAMETERS;
+        }
+    }
+
+    TEE_GetSystemTime(&time);
+    params[0].value.a = time.seconds;
+    params[0].value.b = time.millis;
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result getreetime(uint32_t param_types, TEE_Param params[4])
+{
+    TEE_Time time;
+    int i;
+
+    // Param 0 is an output value
+    if (TEE_PARAM_TYPE_VALUE_OUTPUT != TEE_PARAM_TYPE_GET(param_types, 0)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    // Other parameters must be of type TEE_PARAM_TYPE_NONE
+    for (i=1; i<4; i++) {
+        if (TEE_PARAM_TYPE_NONE != TEE_PARAM_TYPE_GET(param_types, i)) {
+            return TEE_ERROR_BAD_PARAMETERS;
+        }
+    }
+
+    TEE_GetREETime(&time);
+    params[0].value.a = time.seconds;
+    params[0].value.b = time.millis;
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result getpersistanttime(uint32_t param_types, TEE_Param params[4])
+{
+    TEE_Time time;
+    int i;
+
+    // Param 0 is an output value
+    if (TEE_PARAM_TYPE_VALUE_OUTPUT != TEE_PARAM_TYPE_GET(param_types, 0)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    // Other parameters must be of type TEE_PARAM_TYPE_NONE
+    for (i=1; i<4; i++) {
+        if (TEE_PARAM_TYPE_NONE != TEE_PARAM_TYPE_GET(param_types, i)) {
+            return TEE_ERROR_BAD_PARAMETERS;
+        }
+    }
+
+    TEE_GetTAPersistentTime(&time);
+    params[0].value.a = time.seconds;
+    params[0].value.b = time.millis;
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result setpersistanttime(uint32_t param_types, TEE_Param params[4])
+{
+    TEE_Time time;
+    int i;
+
+    // Param 0 is an input value
+    if (TEE_PARAM_TYPE_VALUE_INPUT != TEE_PARAM_TYPE_GET(param_types, 0)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    // Other parameters must be of type TEE_PARAM_TYPE_NONE
+    for (i=1; i<4; i++) {
+        if (TEE_PARAM_TYPE_NONE != TEE_PARAM_TYPE_GET(param_types, i)) {
+            return TEE_ERROR_BAD_PARAMETERS;
+        }
+    }
+
+    time.seconds = params[0].value.a;
+    time.millis = params[0].value.b;
+    TEE_SetTAPersistentTime(&time);
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result teewait(uint32_t param_types, TEE_Param params[4])
+{
+    int i;
+
+    // Param 0 is an input value
+    if (TEE_PARAM_TYPE_VALUE_INPUT != TEE_PARAM_TYPE_GET(param_types, 0)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    // Other parameters must be of type TEE_PARAM_TYPE_NONE
+    for (i=1; i<4; i++) {
+        if (TEE_PARAM_TYPE_NONE != TEE_PARAM_TYPE_GET(param_types, i)) {
+            return TEE_ERROR_BAD_PARAMETERS;
+        }
+    }
+
+    return TEE_Wait(params[0].value.a);
+}
+
+static TEE_Result incvalue(uint32_t param_types, TEE_Param params[4])
+{
+    int i;
+
+    // Param 0 is an input/output value
+    if (TEE_PARAM_TYPE_VALUE_INOUT != TEE_PARAM_TYPE_GET(param_types, 0)) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    // Other parameters must be of type TEE_PARAM_TYPE_NONE
+    for (i=1; i<4; i++) {
+        if (TEE_PARAM_TYPE_NONE != TEE_PARAM_TYPE_GET(param_types, i)) {
+            return TEE_ERROR_BAD_PARAMETERS;
+        }
+    }
+
+    params[0].value.b = params[0].value.a+1;
+    return TEE_SUCCESS;
+}
diff --git a/ta/helloworld_ext_ta/hello_world_ta.h b/ta/helloworld_ext_ta/hello_world_ta.h
new file mode 100644
index 0000000..987f766
--- /dev/null
+++ b/ta/helloworld_ext_ta/hello_world_ta.h
@@ -0,0 +1,35 @@
+/**
+ * Copyright (C) STM SA 2013. All rights reserved.
+ * This code is ST-Ericsson proprietary and confidential.
+ * Any use of the code for whatever purpose is subject to
+ * specific written permission of ST-Ericsson SA.
+ */
+
+#ifndef TA_HELLO_WORLD_H
+#define TA_HELLO_WORLD_H
+
+/* This UUID is generated with uuidgen
+   the ITU-T UUID generator at http://www.itu.int/ITU-T/asn1/uuid.html */
+#define TA_HELLO_WORLD_UUID { 0x1ca38dfc, 0x6c04, 0x11e4, \
+		{ 0x9d, 0xbb, 0x10, 0x1f, 0x74, 0xf3, 0x9d, 0x1d } }
+
+/* The TAFs ID implemented in this TA */
+#define TA_HELLO_WORLD_CMD_PRINT_HELLO_WORLD    0
+#define TA_HELLO_WORLD_CMD_ADD                  1
+#define TA_HELLO_WORLD_CMD_SETGLOBAL            2
+#define TA_HELLO_WORLD_CMD_GETGLOBAL            3
+#define TA_HELLO_WORLD_CMD_GETREETIME           4
+#define TA_HELLO_WORLD_CMD_GETPERSISTANTTIME    5
+#define TA_HELLO_WORLD_CMD_SETPERSISTANTTIME    6
+#define TA_HELLO_WORLD_CMD_WAIT                 7
+#define TA_HELLO_WORLD_CMD_GETSYSTEMTIME        8
+#define TA_HELLO_WORLD_CMD_INCVALUE             9
+#define TA_HELLO_WORLD_CMD_PARAMS              10
+
+/* Common structures */
+typedef struct {
+    int in1, in2;
+    int out;
+} t_add;
+
+#endif /*TA_HELLO_WORLD_H*/
diff --git a/ta/helloworld_ext_ta/sub.mk b/ta/helloworld_ext_ta/sub.mk
new file mode 100644
index 0000000..b7d38b7
--- /dev/null
+++ b/ta/helloworld_ext_ta/sub.mk
@@ -0,0 +1,3 @@
+global-incdirs-y += .
+srcs-y += hello_world_ta.c
+srcs-y += hello_world_params.c
\ No newline at end of file
diff --git a/ta/helloworld_ext_ta/user_ta_header_defines.h b/ta/helloworld_ext_ta/user_ta_header_defines.h
new file mode 100644
index 0000000..aa44873
--- /dev/null
+++ b/ta/helloworld_ext_ta/user_ta_header_defines.h
@@ -0,0 +1,38 @@
+/**
+ * Copyright (C) ST-Ericsson SA 2011. All rights reserved.
+ * This code is ST-Ericsson proprietary and confidential.
+ * Any use of the code for whatever purpose is subject to
+ * specific written permission of ST-Ericsson SA.
+ *
+ * Author: jens.wiklander@stericsson.com
+ */
+
+/*
+ * The name of this file must not be modified
+ */
+
+#ifndef USER_TA_HEADER_DEFINES_H
+#define USER_TA_HEADER_DEFINES_H
+
+#include <hello_world_ta.h>
+#include <user_ta_header.h>
+
+#define TA_UUID TA_HELLO_WORLD_UUID
+
+// TA_FLAG_MULTI_SESSION && !TA_FLAG_SINGLE_INSTANCE flag is important
+// as tested in ytest
+#define TA_FLAGS                    (TA_FLAG_MULTI_SESSION | TA_FLAG_EXEC_DDR)
+#if 0
+#define TA_STACK_SIZE               (2 * 1024)
+#define TA_DATA_SIZE                (32 * 1024)
+#else
+#define TA_STACK_SIZE               (32 * 1024) //(2 * 1024)
+#define TA_DATA_SIZE                (896 * 1024) //(32 * 1024)
+#endif
+
+#define TA_CURRENT_TA_EXT_PROPERTIES \
+    { "gp.ta.description", USER_TA_PROP_TYPE_STRING, \
+        "Hello World Application" }, \
+    { "gp.ta.version", USER_TA_PROP_TYPE_U32, &(const uint32_t){ 0x0100 } }
+
+#endif /*USER_TA_HEADER_DEFINES_H*/
-- 
1.9.1

