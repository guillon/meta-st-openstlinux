From a6fabb06a7b0906942ab5267103a5ce22b4883c2 Mon Sep 17 00:00:00 2001
From: Vincent Abriou <vincent.abriou@st.com>
Date: Wed, 10 Aug 2016 11:43:43 +0200
Subject: [PATCH 48/61] compositor-st: interlaced buffers support

Wait for 2 VSYNC signals when displaying an interlaced frame, as it is
displayed twice (top field, then bottom field).
Use the "interlaced" property of the dmabuf buffer when creating a DRM
FB

The gl-renderer shall not reject interlaced buffers at import.
In the nominal use case the interlaced buffers are sent to a DRM
plane (overlay view) which processes the deinterlacing.
In the backup case (video rotation,... ) the buffer is handled by GL, in
which case there is no deinterlacing unless we use a specific shader,
not available for the time being.

Change-Id: I546b637a4dbe52d7a294b149bfe92885b001e712
Signed-off-by: Vincent Abriou <vincent.abriou@st.com>
---
 libweston/compositor-st.c | 35 +++++++++++++++++++++++++++++++++--
 libweston/gl-renderer.c   |  4 ----
 2 files changed, 33 insertions(+), 6 deletions(-)

diff --git a/libweston/compositor-st.c b/libweston/compositor-st.c
index 34f41b7..cfd884c 100644
--- a/libweston/compositor-st.c
+++ b/libweston/compositor-st.c
@@ -61,6 +61,7 @@
 #include "vaapi-recorder.h"
 #include "presentation-time-server-protocol.h"
 #include "linux-dmabuf.h"
+#include "linux-dmabuf-unstable-v1-server-protocol.h"
 
 #ifndef DRM_CAP_TIMESTAMP_MONOTONIC
 #define DRM_CAP_TIMESTAMP_MONOTONIC 0x6
@@ -136,7 +137,7 @@ struct drm_mode {
 };
 
 struct drm_fb {
-	uint32_t fb_id, stride, handle, size;
+	uint32_t fb_id, stride, handle, size, flags;
 	int fd;
 	int is_client_buffer;
 	struct weston_buffer_reference buffer_ref;
@@ -216,6 +217,8 @@ struct drm_sprite {
 	uint32_t dest_x, dest_y;
 	uint32_t dest_w, dest_h;
 
+	bool vblank_pending;
+
 	uint32_t formats[];
 };
 
@@ -507,9 +510,15 @@ drm_fb_get_from_dmabuf(struct linux_dmabuf_buffer *dmabuf_buffer,
 		offsets[i] = dmabuf_buffer->attributes.offset[i];
 	}
 
+	if (dmabuf_buffer->attributes.flags & ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_INTERLACED)
+		fb->flags |= DRM_MODE_FB_INTERLACED;
+
+	if (dmabuf_buffer->attributes.flags & ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_BOTTOM_FIRST)
+		fb->flags |= DRM_MODE_FB_BFF;
+
 	ret = drmModeAddFB2(backend->drm.fd, width, height,
 			format, handles, pitches, offsets,
-			&fb->fb_id, 0);
+			&fb->fb_id, fb->flags);
 	if (ret) {
 		weston_log("addfb2 failed\n");
 		goto err_free;
@@ -800,6 +809,11 @@ drm_output_repaint(struct weston_output *output_base,
 			.request.sequence = 1,
 		};
 
+		if (s->vblank_pending) {
+			weston_xlog(" do not refresh the sprite=%p (currently in processing)\n", s);
+			continue;
+		}
+
 		if ((!s->current && !s->next) ||
 		    !drm_sprite_crtc_supported(output, s->possible_crtcs))
 			continue;
@@ -820,9 +834,19 @@ drm_output_repaint(struct weston_output *output_base,
 		if (ret)
 			weston_log(" setplane failed: %d: %s\n",
 				ret, strerror(errno));
+		else
+			s->vblank_pending = true;
 
 		vbl.request.type |= drm_waitvblank_pipe(output);
 
+		if (fb_id) {
+			/* Wait for 2 Vsync in case of interlaced buffer */
+			if (s->next->flags & DRM_MODE_FB_INTERLACED) {
+				weston_log(" interlaced frame vblank\n");
+				vbl.request.sequence = 2;
+			}
+		}
+
 		/*
 		 * Queue a vblank signal so we know when the surface
 		 * becomes active on the display or has been replaced.
@@ -948,6 +972,7 @@ vblank_handler(int fd, unsigned int frame, unsigned int sec, unsigned int usec,
 	drm_output_release_fb(output, s->current);
 	s->current = s->next;
 	s->next = NULL;
+	s->vblank_pending = false;
 
 	if (!output->page_flip_pending) {
 		ts.tv_sec = sec;
@@ -1135,6 +1160,11 @@ drm_output_prepare_overlay_view(struct drm_output *output,
 				format_ok = 1;
 		}
 
+		if (s->vblank_pending && format_ok) {
+			weston_xlog("    sprite is currently being rendered\n");
+			return NULL;
+		}
+
 		if ((!s->next) && format_ok) {
 			found = 1;
 			break;
@@ -2779,6 +2809,7 @@ create_sprites(struct drm_backend *b)
 		sprite->plane_id = plane->plane_id;
 		sprite->current = NULL;
 		sprite->next = NULL;
+		sprite->vblank_pending = false;
 		sprite->backend = b;
 		sprite->count_formats = plane->count_formats;
 		memcpy(sprite->formats, plane->formats,
diff --git a/libweston/gl-renderer.c b/libweston/gl-renderer.c
index 69b0e4a..1be7c83 100644
--- a/libweston/gl-renderer.c
+++ b/libweston/gl-renderer.c
@@ -1861,10 +1861,6 @@ gl_renderer_import_dmabuf(struct weston_compositor *ec,
 			return false;
 	}
 
-	/* reject all flags we do not recognize or handle */
-	if (dmabuf->attributes.flags & ~ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_Y_INVERT)
-		return false;
-
 	image = import_dmabuf(gr, dmabuf);
 	if (!image)
 		return false;
-- 
2.7.4

