From 3b9271bc8dbcfcbc2a164ec5d1ea78fb1265776c Mon Sep 17 00:00:00 2001
From: Vincent Abriou <vincent.abriou@st.com>
Date: Mon, 10 Oct 2016 13:51:06 +0200
Subject: [PATCH 35/61] [DEMO]: add simple-egl-cube and slideshow applications

Change-Id: Icdb15eb8d7fd4ea81f86a7d31ee0abf57bb46d9a
Signed-off-by: Vincent Abriou <vincent.abriou@st.com>
---
 Makefile.am               |   15 +-
 clients/esTransform.c     |  239 ++++++++++
 clients/esUtil.h          |  304 ++++++++++++
 clients/simple-egl-cube.c | 1127 +++++++++++++++++++++++++++++++++++++++++++++
 clients/slideshow.c       |  581 +++++++++++++++++++++++
 5 files changed, 2265 insertions(+), 1 deletion(-)
 create mode 100644 clients/esTransform.c
 create mode 100644 clients/esUtil.h
 create mode 100644 clients/simple-egl-cube.c
 create mode 100644 clients/slideshow.c

diff --git a/Makefile.am b/Makefile.am
index 6366c6f..ae277ae 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -503,6 +503,7 @@ endif
 demo_clients =					\
 	weston-flower				\
 	weston-image				\
+	weston-slideshow			\
 	weston-cliptest				\
 	weston-dnd				\
 	weston-smoke				\
@@ -574,7 +575,7 @@ weston_multi_resource_LDADD = $(SIMPLE_CLIENT_LIBS) libshared.la $(CLOCK_GETTIME
 endif
 
 if BUILD_SIMPLE_EGL_CLIENTS
-demo_clients += weston-simple-egl
+demo_clients += weston-simple-egl weston-simple-egl-cube
 weston_simple_egl_SOURCES = clients/simple-egl.c
 nodist_weston_simple_egl_SOURCES =		\
 	protocol/xdg-shell-unstable-v6-protocol.c		\
@@ -583,6 +584,14 @@ nodist_weston_simple_egl_SOURCES =		\
 	protocol/ivi-application-client-protocol.h
 weston_simple_egl_CFLAGS = $(AM_CFLAGS) $(SIMPLE_EGL_CLIENT_CFLAGS)
 weston_simple_egl_LDADD = $(SIMPLE_EGL_CLIENT_LIBS) -lm
+weston_simple_egl_cube_SOURCES = clients/simple-egl-cube.c
+nodist_weston_simple_egl_cube_SOURCES =		\
+	protocol/xdg-shell-unstable-v6-protocol.c		\
+	protocol/xdg-shell-unstable-v6-client-protocol.h	\
+	clients/esTransform.c				\
+	clients/esUtil.h
+weston_simple_eg_cube_CFLAGS = $(AM_CFLAGS) $(SIMPLE_EGL_CLIENT_CFLAGS)
+weston_simple_egl_cube_LDADD = $(SIMPLE_EGL_CLIENT_LIBS) -lm
 endif
 
 if BUILD_SIMPLE_DMABUF_INTEL_CLIENT
@@ -667,6 +676,10 @@ weston_image_SOURCES = clients/image.c
 weston_image_LDADD = libtoytoolkit.la
 weston_image_CFLAGS = $(AM_CFLAGS) $(CLIENT_CFLAGS)
 
+weston_slideshow_SOURCES = clients/slideshow.c
+weston_slideshow_LDADD = libtoytoolkit.la
+weston_slideshow_CFLAGS = $(AM_CFLAGS) $(CLIENT_CFLAGS)
+
 weston_cliptest_SOURCES =				\
 	clients/cliptest.c				\
 	libweston/vertex-clipping.c			\
diff --git a/clients/esTransform.c b/clients/esTransform.c
new file mode 100644
index 0000000..599f9ed
--- /dev/null
+++ b/clients/esTransform.c
@@ -0,0 +1,239 @@
+//
+// Book:      OpenGL(R) ES 2.0 Programming Guide
+// Authors:   Aaftab Munshi, Dan Ginsburg, Dave Shreiner
+// ISBN-10:   0321502795
+// ISBN-13:   9780321502797
+// Publisher: Addison-Wesley Professional
+// URLs:      http://safari.informit.com/9780321563835
+//            http://www.opengles-book.com
+//
+
+/*
+ * (c) 2009 Aaftab Munshi, Dan Ginsburg, Dave Shreiner
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+// ESUtil.c
+//
+//    A utility library for OpenGL ES.  This library provides a
+//    basic common framework for the example applications in the
+//    OpenGL ES 2.0 Programming Guide.
+//
+
+///
+//  Includes
+//
+#include "esUtil.h"
+#include <math.h>
+#include <string.h>
+
+#define PI 3.1415926535897932384626433832795f
+
+void ESUTIL_API
+esScale(ESMatrix *result, GLfloat sx, GLfloat sy, GLfloat sz)
+{
+    result->m[0][0] *= sx;
+    result->m[0][1] *= sx;
+    result->m[0][2] *= sx;
+    result->m[0][3] *= sx;
+
+    result->m[1][0] *= sy;
+    result->m[1][1] *= sy;
+    result->m[1][2] *= sy;
+    result->m[1][3] *= sy;
+
+    result->m[2][0] *= sz;
+    result->m[2][1] *= sz;
+    result->m[2][2] *= sz;
+    result->m[2][3] *= sz;
+}
+
+void ESUTIL_API
+esTranslate(ESMatrix *result, GLfloat tx, GLfloat ty, GLfloat tz)
+{
+    result->m[3][0] += (result->m[0][0] * tx + result->m[1][0] * ty
+            + result->m[2][0] * tz);
+    result->m[3][1] += (result->m[0][1] * tx + result->m[1][1] * ty
+            + result->m[2][1] * tz);
+    result->m[3][2] += (result->m[0][2] * tx + result->m[1][2] * ty
+            + result->m[2][2] * tz);
+    result->m[3][3] += (result->m[0][3] * tx + result->m[1][3] * ty
+            + result->m[2][3] * tz);
+}
+
+void ESUTIL_API
+esRotate(ESMatrix *result, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
+{
+   GLfloat sinAngle, cosAngle;
+   GLfloat mag = sqrtf(x * x + y * y + z * z);
+
+   sinAngle = sinf ( angle * PI / 180.0f );
+   cosAngle = cosf ( angle * PI / 180.0f );
+   if ( mag > 0.0f )
+   {
+      GLfloat xx, yy, zz, xy, yz, zx, xs, ys, zs;
+      GLfloat oneMinusCos;
+      ESMatrix rotMat;
+
+      x /= mag;
+      y /= mag;
+      z /= mag;
+
+      xx = x * x;
+      yy = y * y;
+      zz = z * z;
+      xy = x * y;
+      yz = y * z;
+      zx = z * x;
+      xs = x * sinAngle;
+      ys = y * sinAngle;
+      zs = z * sinAngle;
+      oneMinusCos = 1.0f - cosAngle;
+
+      rotMat.m[0][0] = (oneMinusCos * xx) + cosAngle;
+      rotMat.m[0][1] = (oneMinusCos * xy) - zs;
+      rotMat.m[0][2] = (oneMinusCos * zx) + ys;
+      rotMat.m[0][3] = 0.0F;
+
+      rotMat.m[1][0] = (oneMinusCos * xy) + zs;
+      rotMat.m[1][1] = (oneMinusCos * yy) + cosAngle;
+      rotMat.m[1][2] = (oneMinusCos * yz) - xs;
+      rotMat.m[1][3] = 0.0F;
+
+      rotMat.m[2][0] = (oneMinusCos * zx) - ys;
+      rotMat.m[2][1] = (oneMinusCos * yz) + xs;
+      rotMat.m[2][2] = (oneMinusCos * zz) + cosAngle;
+      rotMat.m[2][3] = 0.0F;
+
+      rotMat.m[3][0] = 0.0F;
+      rotMat.m[3][1] = 0.0F;
+      rotMat.m[3][2] = 0.0F;
+      rotMat.m[3][3] = 1.0F;
+
+      esMatrixMultiply( result, &rotMat, result );
+   }
+}
+
+void ESUTIL_API
+esFrustum(ESMatrix *result, float left, float right, float bottom, float top, float nearZ, float farZ)
+{
+    float       deltaX = right - left;
+    float       deltaY = top - bottom;
+    float       deltaZ = farZ - nearZ;
+    ESMatrix    frust;
+
+    if ( (nearZ <= 0.0f) || (farZ <= 0.0f) ||
+         (deltaX <= 0.0f) || (deltaY <= 0.0f) || (deltaZ <= 0.0f) )
+        return;
+
+    frust.m[0][0] = 2.0f * nearZ / deltaX;
+    frust.m[0][1] = frust.m[0][2] = frust.m[0][3] = 0.0f;
+
+    frust.m[1][1] = 2.0f * nearZ / deltaY;
+    frust.m[1][0] = frust.m[1][2] = frust.m[1][3] = 0.0f;
+
+    frust.m[2][0] = (right + left) / deltaX;
+    frust.m[2][1] = (top + bottom) / deltaY;
+    frust.m[2][2] = -(nearZ + farZ) / deltaZ;
+    frust.m[2][3] = -1.0f;
+
+    frust.m[3][2] = -2.0f * nearZ * farZ / deltaZ;
+    frust.m[3][0] = frust.m[3][1] = frust.m[3][3] = 0.0f;
+
+    esMatrixMultiply(result, &frust, result);
+}
+
+
+void ESUTIL_API
+esPerspective(ESMatrix *result, float fovy, float aspect, float nearZ, float farZ)
+{
+   GLfloat frustumW, frustumH;
+
+   frustumH = tanf( fovy / 360.0f * PI ) * nearZ;
+   frustumW = frustumH * aspect;
+
+   esFrustum( result, -frustumW, frustumW, -frustumH, frustumH, nearZ, farZ );
+}
+
+void ESUTIL_API
+esOrtho(ESMatrix *result, float left, float right, float bottom, float top, float nearZ, float farZ)
+{
+    float       deltaX = right - left;
+    float       deltaY = top - bottom;
+    float       deltaZ = farZ - nearZ;
+    ESMatrix    ortho;
+
+    if ( (deltaX == 0.0f) || (deltaY == 0.0f) || (deltaZ == 0.0f) )
+        return;
+
+    esMatrixLoadIdentity(&ortho);
+    ortho.m[0][0] = 2.0f / deltaX;
+    ortho.m[3][0] = -(right + left) / deltaX;
+    ortho.m[1][1] = 2.0f / deltaY;
+    ortho.m[3][1] = -(top + bottom) / deltaY;
+    ortho.m[2][2] = -2.0f / deltaZ;
+    ortho.m[3][2] = -(nearZ + farZ) / deltaZ;
+
+    esMatrixMultiply(result, &ortho, result);
+}
+
+
+void ESUTIL_API
+esMatrixMultiply(ESMatrix *result, ESMatrix *srcA, ESMatrix *srcB)
+{
+    ESMatrix    tmp;
+    int         i;
+
+	for (i=0; i<4; i++)
+	{
+		tmp.m[i][0] =	(srcA->m[i][0] * srcB->m[0][0]) +
+						(srcA->m[i][1] * srcB->m[1][0]) +
+						(srcA->m[i][2] * srcB->m[2][0]) +
+						(srcA->m[i][3] * srcB->m[3][0]) ;
+
+		tmp.m[i][1] =	(srcA->m[i][0] * srcB->m[0][1]) +
+						(srcA->m[i][1] * srcB->m[1][1]) +
+						(srcA->m[i][2] * srcB->m[2][1]) +
+						(srcA->m[i][3] * srcB->m[3][1]) ;
+
+		tmp.m[i][2] =	(srcA->m[i][0] * srcB->m[0][2]) +
+						(srcA->m[i][1] * srcB->m[1][2]) +
+						(srcA->m[i][2] * srcB->m[2][2]) +
+						(srcA->m[i][3] * srcB->m[3][2]) ;
+
+		tmp.m[i][3] =	(srcA->m[i][0] * srcB->m[0][3]) +
+						(srcA->m[i][1] * srcB->m[1][3]) +
+						(srcA->m[i][2] * srcB->m[2][3]) +
+						(srcA->m[i][3] * srcB->m[3][3]) ;
+	}
+    memcpy(result, &tmp, sizeof(ESMatrix));
+}
+
+
+void ESUTIL_API
+esMatrixLoadIdentity(ESMatrix *result)
+{
+    memset(result, 0x0, sizeof(ESMatrix));
+    result->m[0][0] = 1.0f;
+    result->m[1][1] = 1.0f;
+    result->m[2][2] = 1.0f;
+    result->m[3][3] = 1.0f;
+}
+
diff --git a/clients/esUtil.h b/clients/esUtil.h
new file mode 100644
index 0000000..af8e0cd
--- /dev/null
+++ b/clients/esUtil.h
@@ -0,0 +1,304 @@
+//
+// Book:      OpenGL(R) ES 2.0 Programming Guide
+// Authors:   Aaftab Munshi, Dan Ginsburg, Dave Shreiner
+// ISBN-10:   0321502795
+// ISBN-13:   9780321502797
+// Publisher: Addison-Wesley Professional
+// URLs:      http://safari.informit.com/9780321563835
+//            http://www.opengles-book.com
+//
+
+/*
+ * (c) 2009 Aaftab Munshi, Dan Ginsburg, Dave Shreiner
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+//
+/// \file ESUtil.h
+/// \brief A utility library for OpenGL ES.  This library provides a
+///        basic common framework for the example applications in the
+///        OpenGL ES 2.0 Programming Guide.
+//
+#ifndef ESUTIL_H
+#define ESUTIL_H
+
+///
+//  Includes
+//
+#include <GLES2/gl2.h>
+#include <EGL/egl.h>
+
+#ifdef __cplusplus
+
+extern "C" {
+#endif
+
+
+///
+//  Macros
+//
+#define ESUTIL_API
+#define ESCALLBACK
+
+
+/// esCreateWindow flag - RGB color buffer
+#define ES_WINDOW_RGB           0
+/// esCreateWindow flag - ALPHA color buffer
+#define ES_WINDOW_ALPHA         1
+/// esCreateWindow flag - depth buffer
+#define ES_WINDOW_DEPTH         2
+/// esCreateWindow flag - stencil buffer
+#define ES_WINDOW_STENCIL       4
+/// esCreateWindow flat - multi-sample buffer
+#define ES_WINDOW_MULTISAMPLE   8
+
+
+///
+// Types
+//
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+typedef struct
+{
+    GLfloat   m[4][4];
+} ESMatrix;
+
+typedef struct _escontext
+{
+   /// Put your user data here...
+   void*       userData;
+
+   /// Window width
+   GLint       width;
+
+   /// Window height
+   GLint       height;
+
+   /// Window handle
+   EGLNativeWindowType  hWnd;
+
+   /// EGL display
+   EGLDisplay  eglDisplay;
+
+   /// EGL context
+   EGLContext  eglContext;
+
+   /// EGL surface
+   EGLSurface  eglSurface;
+
+   /// Callbacks
+   void (ESCALLBACK *drawFunc) ( struct _escontext * );
+   void (ESCALLBACK *keyFunc) ( struct _escontext *, unsigned char, int, int );
+   void (ESCALLBACK *updateFunc) ( struct _escontext *, float deltaTime );
+} ESContext;
+
+
+///
+//  Public Functions
+//
+
+//
+///
+/// \brief Initialize ES framework context.  This must be called before calling any other functions.
+/// \param esContext Application context
+//
+void ESUTIL_API esInitContext ( ESContext *esContext );
+
+//
+/// \brief Create a window with the specified parameters
+/// \param esContext Application context
+/// \param title Name for title bar of window
+/// \param width Width in pixels of window to create
+/// \param height Height in pixels of window to create
+/// \param flags Bitfield for the window creation flags
+///         ES_WINDOW_RGB     - specifies that the color buffer should have R,G,B channels
+///         ES_WINDOW_ALPHA   - specifies that the color buffer should have alpha
+///         ES_WINDOW_DEPTH   - specifies that a depth buffer should be created
+///         ES_WINDOW_STENCIL - specifies that a stencil buffer should be created
+///         ES_WINDOW_MULTISAMPLE - specifies that a multi-sample buffer should be created
+/// \return GL_TRUE if window creation is succesful, GL_FALSE otherwise
+GLboolean ESUTIL_API esCreateWindow ( ESContext *esContext, const char *title, GLint width, GLint height, GLuint flags );
+
+//
+/// \brief Start the main loop for the OpenGL ES application
+/// \param esContext Application context
+//
+void ESUTIL_API esMainLoop ( ESContext *esContext );
+
+//
+/// \brief Register a draw callback function to be used to render each frame
+/// \param esContext Application context
+/// \param drawFunc Draw callback function that will be used to render the scene
+//
+void ESUTIL_API esRegisterDrawFunc ( ESContext *esContext, void (ESCALLBACK *drawFunc) ( ESContext* ) );
+
+///
+/// \brief Register an update callback function to be used to update on each time step
+/// \param esContext Application context
+/// \param updateFunc Update callback function that will be used to render the scene
+//
+void ESUTIL_API esRegisterUpdateFunc ( ESContext *esContext, void (ESCALLBACK *updateFunc) ( ESContext*, float ) );
+
+//
+/// \brief Register an keyboard input processing callback function
+/// \param esContext Application context
+/// \param keyFunc Key callback function for application processing of keyboard input
+//
+void ESUTIL_API esRegisterKeyFunc ( ESContext *esContext,
+                                    void (ESCALLBACK *drawFunc) ( ESContext*, unsigned char, int, int ) );
+//
+/// \brief Log a message to the debug output for the platform
+/// \param formatStr Format string for error log.
+//
+void ESUTIL_API esLogMessage ( const char *formatStr, ... );
+
+//
+///
+/// \brief Load a shader, check for compile errors, print error messages to output log
+/// \param type Type of shader (GL_VERTEX_SHADER or GL_FRAGMENT_SHADER)
+/// \param shaderSrc Shader source string
+/// \return A new shader object on success, 0 on failure
+//
+GLuint ESUTIL_API esLoadShader ( GLenum type, const char *shaderSrc );
+
+//
+///
+/// \brief Load a vertex and fragment shader, create a program object, link program.
+///        Errors output to log.
+/// \param vertShaderSrc Vertex shader source code
+/// \param fragShaderSrc Fragment shader source code
+/// \return A new program object linked with the vertex/fragment shader pair, 0 on failure
+//
+GLuint ESUTIL_API esLoadProgram ( const char *vertShaderSrc, const char *fragShaderSrc );
+
+
+//
+// \brief Generates geometry for a sphere.  Allocates memory for the vertex data and stores
+///        the results in the arrays.  Generate index list for a TRIANGLE_STRIP
+/// \param numSlices The number of slices in the sphere
+/// \param vertices If not NULL, will contain array of float3 positions
+/// \param normals If not NULL, will contain array of float3 normals
+/// \param texCoords If not NULL, will contain array of float2 texCoords
+/// \param indices If not NULL, will contain the array of indices for the triangle strip
+/// \return The number of indices required for rendering the buffers (the number of indices stored in the indices array
+///         if it is not NULL ) as a GL_TRIANGLE_STRIP
+//
+int ESUTIL_API esGenSphere ( int numSlices, float radius, GLfloat **vertices, GLfloat **normals,
+                             GLfloat **texCoords, GLuint **indices );
+
+//
+/// \brief Generates geometry for a cube.  Allocates memory for the vertex data and stores
+///        the results in the arrays.  Generate index list for a TRIANGLES
+/// \param scale The size of the cube, use 1.0 for a unit cube.
+/// \param vertices If not NULL, will contain array of float3 positions
+/// \param normals If not NULL, will contain array of float3 normals
+/// \param texCoords If not NULL, will contain array of float2 texCoords
+/// \param indices If not NULL, will contain the array of indices for the triangle strip
+/// \return The number of indices required for rendering the buffers (the number of indices stored in the indices array
+///         if it is not NULL ) as a GL_TRIANGLES
+//
+int ESUTIL_API esGenCube ( float scale, GLfloat **vertices, GLfloat **normals,
+                           GLfloat **texCoords, GLuint **indices );
+
+//
+/// \brief Loads a 24-bit TGA image from a file
+/// \param fileName Name of the file on disk
+/// \param width Width of loaded image in pixels
+/// \param height Height of loaded image in pixels
+///  \return Pointer to loaded image.  NULL on failure.
+//
+char* ESUTIL_API esLoadTGA ( char *fileName, int *width, int *height );
+
+
+//
+/// \brief multiply matrix specified by result with a scaling matrix and return new matrix in result
+/// \param result Specifies the input matrix.  Scaled matrix is returned in result.
+/// \param sx, sy, sz Scale factors along the x, y and z axes respectively
+//
+void ESUTIL_API esScale(ESMatrix *result, GLfloat sx, GLfloat sy, GLfloat sz);
+
+//
+/// \brief multiply matrix specified by result with a translation matrix and return new matrix in result
+/// \param result Specifies the input matrix.  Translated matrix is returned in result.
+/// \param tx, ty, tz Scale factors along the x, y and z axes respectively
+//
+void ESUTIL_API esTranslate(ESMatrix *result, GLfloat tx, GLfloat ty, GLfloat tz);
+
+//
+/// \brief multiply matrix specified by result with a rotation matrix and return new matrix in result
+/// \param result Specifies the input matrix.  Rotated matrix is returned in result.
+/// \param angle Specifies the angle of rotation, in degrees.
+/// \param x, y, z Specify the x, y and z coordinates of a vector, respectively
+//
+void ESUTIL_API esRotate(ESMatrix *result, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
+
+//
+// \brief multiply matrix specified by result with a perspective matrix and return new matrix in result
+/// \param result Specifies the input matrix.  new matrix is returned in result.
+/// \param left, right Coordinates for the left and right vertical clipping planes
+/// \param bottom, top Coordinates for the bottom and top horizontal clipping planes
+/// \param nearZ, farZ Distances to the near and far depth clipping planes.  Both distances must be positive.
+//
+void ESUTIL_API esFrustum(ESMatrix *result, float left, float right, float bottom, float top, float nearZ, float farZ);
+
+//
+/// \brief multiply matrix specified by result with a perspective matrix and return new matrix in result
+/// \param result Specifies the input matrix.  new matrix is returned in result.
+/// \param fovy Field of view y angle in degrees
+/// \param aspect Aspect ratio of screen
+/// \param nearZ Near plane distance
+/// \param farZ Far plane distance
+//
+void ESUTIL_API esPerspective(ESMatrix *result, float fovy, float aspect, float nearZ, float farZ);
+
+//
+/// \brief multiply matrix specified by result with a perspective matrix and return new matrix in result
+/// \param result Specifies the input matrix.  new matrix is returned in result.
+/// \param left, right Coordinates for the left and right vertical clipping planes
+/// \param bottom, top Coordinates for the bottom and top horizontal clipping planes
+/// \param nearZ, farZ Distances to the near and far depth clipping planes.  These values are negative if plane is behind the viewer
+//
+void ESUTIL_API esOrtho(ESMatrix *result, float left, float right, float bottom, float top, float nearZ, float farZ);
+
+//
+/// \brief perform the following operation - result matrix = srcA matrix * srcB matrix
+/// \param result Returns multiplied matrix
+/// \param srcA, srcB Input matrices to be multiplied
+//
+void ESUTIL_API esMatrixMultiply(ESMatrix *result, ESMatrix *srcA, ESMatrix *srcB);
+
+//
+//// \brief return an indentity matrix 
+//// \param result returns identity matrix
+//
+void ESUTIL_API esMatrixLoadIdentity(ESMatrix *result);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // ESUTIL_H
+
diff --git a/clients/simple-egl-cube.c b/clients/simple-egl-cube.c
new file mode 100644
index 0000000..26844a8
--- /dev/null
+++ b/clients/simple-egl-cube.c
@@ -0,0 +1,1127 @@
+/*
+ * Copyright © 2011 Benjamin Franzke
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include "config.h"
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <math.h>
+#include <assert.h>
+#include <signal.h>
+
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include <linux/input.h>
+
+#include <wayland-client.h>
+#include <wayland-egl.h>
+#include <wayland-cursor.h>
+
+#include <GLES2/gl2.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+#include "xdg-shell-unstable-v6-client-protocol.h"
+#include <sys/types.h>
+#include <unistd.h>
+#include "esUtil.h"
+
+#include "shared/platform.h"
+#include "weston-egl-ext.h"
+
+struct window;
+struct seat;
+
+struct display {
+	struct wl_display *display;
+	struct wl_registry *registry;
+	struct wl_compositor *compositor;
+	struct zxdg_shell_v6 *shell;
+	struct wl_seat *seat;
+	struct wl_pointer *pointer;
+	struct wl_touch *touch;
+	struct wl_keyboard *keyboard;
+	struct wl_shm *shm;
+	struct wl_cursor_theme *cursor_theme;
+	struct wl_cursor *default_cursor;
+	struct wl_surface *cursor_surface;
+	struct {
+		EGLDisplay dpy;
+		EGLContext ctx;
+		EGLConfig conf;
+	} egl;
+	struct window *window;
+
+	PFNEGLSWAPBUFFERSWITHDAMAGEEXTPROC swap_buffers_with_damage;
+};
+
+struct geometry {
+	int width, height;
+};
+
+struct window {
+	struct display *display;
+	struct geometry geometry, window_size;
+	struct {
+		GLuint rotation_uniform;
+		GLuint pos;
+		GLuint col;
+	} gl;
+
+	uint32_t benchmark_time, frames;
+	struct wl_egl_window *native;
+	struct wl_surface *surface;
+	struct zxdg_surface_v6 *xdg_surface;
+	struct zxdg_toplevel_v6 *xdg_toplevel;
+	EGLSurface egl_surface;
+	struct wl_callback *callback;
+	int fullscreen, opaque, buffer_size, frame_sync;
+	bool wait_for_configure;
+};
+static struct {
+	GLuint program;
+	GLint modelviewmatrix, modelviewprojectionmatrix, normalmatrix;
+	GLuint vbo;
+	GLuint positionsoffset, colorsoffset, normalsoffset, texuvoffset;
+	GLuint vertex_shader, fragment_shader;
+	GLuint textures[1];
+	int picture_width;
+	int picture_height;
+} gl;
+
+static const char *vert_shader_text =
+	"uniform mat4 modelviewMatrix;      \n"
+	"uniform mat4 modelviewprojectionMatrix;\n"
+	"uniform mat3 normalMatrix;         \n"
+	"                                   \n"
+	"attribute vec4 in_position;        \n"
+	"attribute vec3 in_normal;          \n"
+	"attribute vec4 in_color;           \n"
+	"\n"
+	"vec4 lightSource = vec4(2.0, 2.0, 20.0, 0.0);\n"
+	"                                   \n"
+	"varying vec4 vVaryingColor;        \n"
+	"                                   \n"
+	"void main()                        \n"
+	"{                                  \n"
+	"    gl_Position = modelviewprojectionMatrix * in_position;\n"
+	"    vec3 vEyeNormal = normalMatrix * in_normal;\n"
+	"    vec4 vPosition4 = modelviewMatrix * in_position;\n"
+	"    vec3 vPosition3 = vPosition4.xyz / vPosition4.w;\n"
+	"    vec3 vLightDir = normalize(lightSource.xyz - vPosition3);\n"
+	"    float diff = max(0.0, dot(vEyeNormal, vLightDir));\n"
+	"    vVaryingColor = vec4(diff * in_color.rgb, 1.0);\n"
+	"}                                  \n";
+
+
+static const char *frag_shader_text =
+	"precision mediump float;           \n"
+	"                                   \n"
+	"varying vec4 vVaryingColor;        \n"
+	"                                   \n"
+	"void main()                        \n"
+	"{                                  \n"
+	"    gl_FragColor = vVaryingColor;  \n"
+	"}                                  \n";
+
+static int running = 1;
+
+static void
+init_egl(struct display *display, struct window *window)
+{
+	static const EGLint context_attribs[] = {
+		EGL_CONTEXT_CLIENT_VERSION, 2,
+		EGL_NONE
+	};
+	const char *extensions;
+
+	EGLint config_attribs[] = {
+		EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+		EGL_RED_SIZE, 1,
+		EGL_GREEN_SIZE, 1,
+		EGL_BLUE_SIZE, 1,
+		EGL_ALPHA_SIZE, 1,
+		EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+		EGL_NONE
+	};
+
+	EGLint major, minor, n, count, i, size;
+	EGLConfig *configs;
+	EGLBoolean ret;
+
+	if (window->opaque || window->buffer_size == 16)
+		config_attribs[9] = 0;
+
+	display->egl.dpy =
+		weston_platform_get_egl_display(EGL_PLATFORM_WAYLAND_KHR,
+						display->display, NULL);
+	assert(display->egl.dpy);
+
+	ret = eglInitialize(display->egl.dpy, &major, &minor);
+	assert(ret == EGL_TRUE);
+	ret = eglBindAPI(EGL_OPENGL_ES_API);
+	assert(ret == EGL_TRUE);
+
+	if (!eglGetConfigs(display->egl.dpy, NULL, 0, &count) || count < 1)
+		assert(0);
+
+	configs = calloc(count, sizeof *configs);
+	assert(configs);
+
+	ret = eglChooseConfig(display->egl.dpy, config_attribs,
+			      configs, count, &n);
+	assert(ret && n >= 1);
+
+	for (i = 0; i < n; i++) {
+		eglGetConfigAttrib(display->egl.dpy,
+				   configs[i], EGL_BUFFER_SIZE, &size);
+		if (window->buffer_size == size) {
+			display->egl.conf = configs[i];
+			break;
+		}
+	}
+	free(configs);
+	if (display->egl.conf == NULL) {
+		fprintf(stderr, "did not find config with buffer size %d\n",
+			window->buffer_size);
+		exit(EXIT_FAILURE);
+	}
+
+	display->egl.ctx = eglCreateContext(display->egl.dpy,
+					    display->egl.conf,
+					    EGL_NO_CONTEXT, context_attribs);
+	assert(display->egl.ctx);
+
+	display->swap_buffers_with_damage = NULL;
+	extensions = eglQueryString(display->egl.dpy, EGL_EXTENSIONS);
+	if (extensions &&
+	    weston_check_egl_extension(extensions, "EGL_EXT_swap_buffers_with_damage") &&
+	    weston_check_egl_extension(extensions, "EGL_EXT_buffer_age"))
+		display->swap_buffers_with_damage =
+			(PFNEGLSWAPBUFFERSWITHDAMAGEEXTPROC)
+			eglGetProcAddress("eglSwapBuffersWithDamageEXT");
+
+	if (display->swap_buffers_with_damage)
+		printf("has EGL_EXT_buffer_age and EGL_EXT_swap_buffers_with_damage\n");
+
+}
+
+static void
+fini_egl(struct display *display)
+{
+	eglTerminate(display->egl.dpy);
+	eglReleaseThread();
+}
+
+static GLuint
+create_shader(struct window *window, const char *source, GLenum shader_type)
+{
+	GLuint shader;
+	GLint status;
+
+	shader = glCreateShader(shader_type);
+	assert(shader != 0);
+
+	glShaderSource(shader, 1, (const char **) &source, NULL);
+	glCompileShader(shader);
+
+	glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
+	if (!status) {
+		char log[1000];
+		GLsizei len;
+		glGetShaderInfoLog(shader, 1000, &len, log);
+		fprintf(stderr, "Error: compiling %s: %*s\n",
+			shader_type == GL_VERTEX_SHADER ? "vertex" : "fragment",
+			len, log);
+		exit(1);
+	}
+
+	return shader;
+}
+static const GLfloat vVertices[] = {
+	// front
+	-1.0f, -1.0f, +1.0f, // point blue
+	+1.0f, -1.0f, +1.0f, // point magenta
+	-1.0f, +1.0f, +1.0f, // point cyan
+	+1.0f, +1.0f, +1.0f, // point white
+	// back
+	+1.0f, -1.0f, -1.0f, // point red
+	-1.0f, -1.0f, -1.0f, // point black
+	+1.0f, +1.0f, -1.0f, // point yellow
+	-1.0f, +1.0f, -1.0f, // point green
+	// right
+	+1.0f, -1.0f, +1.0f, // point magenta
+	+1.0f, -1.0f, -1.0f, // point red
+	+1.0f, +1.0f, +1.0f, // point white
+	+1.0f, +1.0f, -1.0f, // point yellow
+	// left
+	-1.0f, -1.0f, -1.0f, // point black
+	-1.0f, -1.0f, +1.0f, // point blue
+	-1.0f, +1.0f, -1.0f, // point green
+	-1.0f, +1.0f, +1.0f, // point cyan
+	// top
+	-1.0f, +1.0f, +1.0f, // point cyan
+	+1.0f, +1.0f, +1.0f, // point white
+	-1.0f, +1.0f, -1.0f, // point green
+	+1.0f, +1.0f, -1.0f, // point yellow
+	// bottom
+	-1.0f, -1.0f, -1.0f, // point black
+	+1.0f, -1.0f, -1.0f, // point red
+	-1.0f, -1.0f, +1.0f, // point blue
+	+1.0f, -1.0f, +1.0f  // point magenta
+};
+
+static const GLfloat vColors[] = {
+	// front
+	0.0f,  0.0f,  1.0f, // blue
+	1.0f,  0.0f,  1.0f, // magenta
+	0.0f,  1.0f,  1.0f, // cyan
+	1.0f,  1.0f,  1.0f, // white
+	// back
+	1.0f,  0.0f,  0.0f, // red
+	0.0f,  0.0f,  0.0f, // black
+	1.0f,  1.0f,  0.0f, // yellow
+	0.0f,  1.0f,  0.0f, // green
+	// right
+	1.0f,  0.0f,  1.0f, // magenta
+	1.0f,  0.0f,  0.0f, // red
+	1.0f,  1.0f,  1.0f, // white
+	1.0f,  1.0f,  0.0f, // yellow
+	// left
+	0.0f,  0.0f,  0.0f, // black
+	0.0f,  0.0f,  1.0f, // blue
+	0.0f,  1.0f,  0.0f, // green
+	0.0f,  1.0f,  1.0f, // cyan
+	// top
+	0.0f,  1.0f,  1.0f, // cyan
+	1.0f,  1.0f,  1.0f, // white
+	0.0f,  1.0f,  0.0f, // green
+	1.0f,  1.0f,  0.0f, // yellow
+	// bottom
+	0.0f,  0.0f,  0.0f, // black
+	1.0f,  0.0f,  0.0f, // red
+	0.0f,  0.0f,  1.0f, // blue
+	1.0f,  0.0f,  1.0f  // magenta
+	};
+
+static const GLfloat vNormals[] = {
+	// front
+	+0.0f, +0.0f, +1.0f, // forward
+	+0.0f, +0.0f, +1.0f, // forward
+	+0.0f, +0.0f, +1.0f, // forward
+	+0.0f, +0.0f, +1.0f, // forward
+	// back
+	+0.0f, +0.0f, -1.0f, // backbard
+	+0.0f, +0.0f, -1.0f, // backbard
+	+0.0f, +0.0f, -1.0f, // backbard
+	+0.0f, +0.0f, -1.0f, // backbard
+	// right
+	+1.0f, +0.0f, +0.0f, // right
+	+1.0f, +0.0f, +0.0f, // right
+	+1.0f, +0.0f, +0.0f, // right
+	+1.0f, +0.0f, +0.0f, // right
+	// left
+	-1.0f, +0.0f, +0.0f, // left
+	-1.0f, +0.0f, +0.0f, // left
+	-1.0f, +0.0f, +0.0f, // left
+	-1.0f, +0.0f, +0.0f, // left
+	// top
+	+0.0f, +1.0f, +0.0f, // up
+	+0.0f, +1.0f, +0.0f, // up
+	+0.0f, +1.0f, +0.0f, // up
+	+0.0f, +1.0f, +0.0f, // up
+	// bottom
+	+0.0f, -1.0f, +0.0f, // down
+	+0.0f, -1.0f, +0.0f, // down
+	+0.0f, -1.0f, +0.0f, // down
+	+0.0f, -1.0f, +0.0f  // down
+};
+
+	static const GLfloat vTexUVs[] = {
+	// front
+	0.0f,  1.0f,
+	1.0f,  1.0f,
+	0.0f,  0.0f,
+	1.0f,  0.0f,
+	// back
+	0.0f,  1.0f,
+	1.0f,  1.0f,
+	0.0f,  0.0f,
+	1.0f,  0.0f,
+	// right
+	0.0f,  1.0f,
+	1.0f,  1.0f,
+	0.0f,  0.0f,
+	1.0f,  0.0f,
+	// left
+	0.0f,  1.0f,
+	1.0f,  1.0f,
+	0.0f,  0.0f,
+	1.0f,  0.0f,
+	// top
+	0.0f,  1.0f,
+	1.0f,  1.0f,
+	0.0f,  0.0f,
+	1.0f,  0.0f,
+	// bottom
+	0.0f,  1.0f,
+	1.0f,  1.0f,
+	0.0f,  0.0f,
+	1.0f,  0.0f,
+};
+
+static void
+init_gl(struct window *window)
+{
+	GLuint frag, vert;
+	GLuint program;
+	GLint status;
+
+	frag = create_shader(window, frag_shader_text, GL_FRAGMENT_SHADER);
+	vert = create_shader(window, vert_shader_text, GL_VERTEX_SHADER);
+
+	program = glCreateProgram();
+	glAttachShader(program, frag);
+	glAttachShader(program, vert);
+
+	glBindAttribLocation(program, 0, "in_position");
+	glBindAttribLocation(program, 1, "in_normal");
+	glBindAttribLocation(program, 2, "in_color");
+	glBindAttribLocation(program, 3, "in_texuv");
+
+	glLinkProgram(program);
+
+	glGetProgramiv(program, GL_LINK_STATUS, &status);
+	if (!status) {
+		char log[1000];
+		GLsizei len;
+		glGetProgramInfoLog(program, 1000, &len, log);
+		fprintf(stderr, "Error: linking:\n%*s\n", len, log);
+		exit(1);
+	}
+
+	glUseProgram(program);
+
+	window->gl.pos = 0;
+	window->gl.col = 1;
+
+	glBindAttribLocation(program, window->gl.pos, "pos");
+	glBindAttribLocation(program, window->gl.col, "color");
+	glLinkProgram(program);
+
+	gl.modelviewmatrix = glGetUniformLocation(program, "modelviewMatrix");
+	gl.modelviewprojectionmatrix = glGetUniformLocation(program, "modelviewprojectionMatrix");
+	gl.normalmatrix = glGetUniformLocation(program, "normalMatrix");
+
+	GLfloat p_x = 1.0;
+	const GLfloat vlocalNormals[] = {
+	// front
+	+0.0f, +0.0f, p_x, // forward
+	+0.0f, +0.0f, p_x, // forward
+	+0.0f, +0.0f, p_x, // forward
+	+0.0f, +0.0f, p_x, // forward
+	// back
+	+0.0f, +0.0f, -1*p_x, // backbard
+	+0.0f, +0.0f, -1*p_x, // backbard
+	+0.0f, +0.0f, -1*p_x, // backbard
+	+0.0f, +0.0f, -1*p_x, // backbard
+	// right
+	p_x, +0.0f, +0.0f, // right
+	p_x, +0.0f, +0.0f, // right
+	p_x, +0.0f, +0.0f, // right
+	p_x, +0.0f, +0.0f, // right
+	// left
+	-1*p_x, +0.0f, +0.0f, // left
+	-1*p_x, +0.0f, +0.0f, // left
+	-1*p_x, +0.0f, +0.0f, // left
+	-1*p_x, +0.0f, +0.0f, // left
+	// top
+	+0.0f, p_x, +0.0f, // up
+	+0.0f, p_x, +0.0f, // up
+	+0.0f, p_x, +0.0f, // up
+	+0.0f, p_x, +0.0f, // up
+	// bottom
+	+0.0f, -1*p_x, +0.0f, // down
+	+0.0f, -1*p_x, +0.0f, // down
+	+0.0f, -1*p_x, +0.0f, // down
+	+0.0f, -1*p_x, +0.0f  // down
+};
+
+	gl.positionsoffset = 0;
+	gl.colorsoffset = sizeof(vVertices);
+	gl.normalsoffset = sizeof(vVertices) + sizeof(vColors);
+	gl.texuvoffset = sizeof(vVertices) + sizeof(vColors) + sizeof(vlocalNormals);
+	glGenBuffers(1, &gl.vbo);
+	glBindBuffer(GL_ARRAY_BUFFER, gl.vbo);
+	glBufferData(GL_ARRAY_BUFFER, sizeof(vVertices) + sizeof(vColors) + sizeof(vNormals) + sizeof(vTexUVs), 0, GL_STATIC_DRAW);
+	glBufferSubData(GL_ARRAY_BUFFER, gl.positionsoffset, sizeof(vVertices), &vVertices[0]);
+	glBufferSubData(GL_ARRAY_BUFFER, gl.colorsoffset, sizeof(vColors), &vColors[0]);
+	glBufferSubData(GL_ARRAY_BUFFER, gl.normalsoffset, sizeof(vNormals), &vlocalNormals[0]);
+	glBufferSubData(GL_ARRAY_BUFFER, gl.texuvoffset, sizeof(vTexUVs), &vTexUVs[0]);
+	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid*)gl.positionsoffset);
+	glEnableVertexAttribArray(0);
+	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid*)gl.normalsoffset);
+	glEnableVertexAttribArray(1);
+	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid*)gl.colorsoffset);
+	glEnableVertexAttribArray(2);
+
+	glVertexAttribPointer(3, 2, GL_FLOAT, GL_FALSE, 0, (const GLvoid*)gl.texuvoffset);
+	glEnableVertexAttribArray(3);
+
+	glLinkProgram(program);
+
+	window->gl.rotation_uniform =
+		glGetUniformLocation(program, "rotation");
+}
+
+static void
+handle_surface_configure(void *data, struct zxdg_surface_v6 *surface,
+			 uint32_t serial)
+{
+	struct window *window = data;
+
+	zxdg_surface_v6_ack_configure(surface, serial);
+
+	window->wait_for_configure = false;
+}
+
+static const struct zxdg_surface_v6_listener xdg_surface_listener = {
+	handle_surface_configure
+};
+
+static void
+handle_toplevel_configure(void *data, struct zxdg_toplevel_v6 *toplevel,
+			  int32_t width, int32_t height,
+			  struct wl_array *states)
+{
+	struct window *window = data;
+	uint32_t *p;
+
+	window->fullscreen = 0;
+	wl_array_for_each(p, states) {
+		uint32_t state = *p;
+		switch (state) {
+		case ZXDG_TOPLEVEL_V6_STATE_FULLSCREEN:
+			window->fullscreen = 1;
+			break;
+		}
+	}
+
+	if (width > 0 && height > 0) {
+		if (!window->fullscreen) {
+			window->window_size.width = width;
+			window->window_size.height = height;
+		}
+		window->geometry.width = width;
+		window->geometry.height = height;
+	} else if (!window->fullscreen) {
+		window->geometry = window->window_size;
+	}
+
+	if (window->native)
+		wl_egl_window_resize(window->native,
+				     window->geometry.width,
+				     window->geometry.height, 0, 0);
+}
+
+static void
+handle_toplevel_close(void *data, struct zxdg_toplevel_v6 *xdg_toplevel)
+{
+	running = 0;
+}
+
+static const struct zxdg_toplevel_v6_listener xdg_toplevel_listener = {
+	handle_toplevel_configure,
+	handle_toplevel_close,
+};
+
+
+static void
+create_xdg_surface(struct window *window, struct display *display)
+{
+	window->xdg_surface = zxdg_shell_v6_get_xdg_surface(display->shell,
+							    window->surface);
+	zxdg_surface_v6_add_listener(window->xdg_surface,
+				     &xdg_surface_listener, window);
+
+	window->xdg_toplevel =
+		zxdg_surface_v6_get_toplevel(window->xdg_surface);
+	zxdg_toplevel_v6_add_listener(window->xdg_toplevel,
+				      &xdg_toplevel_listener, window);
+
+	zxdg_toplevel_v6_set_title(window->xdg_toplevel, "simple-egl");
+
+	window->wait_for_configure = true;
+	wl_surface_commit(window->surface);
+}
+
+static void
+create_surface(struct window *window)
+{
+	struct display *display = window->display;
+	EGLBoolean ret;
+
+	window->surface = wl_compositor_create_surface(display->compositor);
+
+	window->native =
+		wl_egl_window_create(window->surface,
+				     window->geometry.width,
+				     window->geometry.height);
+	window->egl_surface =
+		weston_platform_create_egl_surface(display->egl.dpy,
+						   display->egl.conf,
+						   window->native, NULL);
+
+
+	if (display->shell) {
+		create_xdg_surface(window, display);
+	} else {
+		assert(0);
+	}
+
+	ret = eglMakeCurrent(window->display->egl.dpy, window->egl_surface,
+			     window->egl_surface, window->display->egl.ctx);
+	assert(ret == EGL_TRUE);
+
+	if (!window->frame_sync)
+		eglSwapInterval(display->egl.dpy, 0);
+
+	if (!display->shell)
+		return;
+
+	if (window->fullscreen)
+		zxdg_toplevel_v6_set_fullscreen(window->xdg_toplevel, NULL);
+}
+
+static void
+destroy_surface(struct window *window)
+{
+	/* Required, otherwise segfault in egl_dri2.c: dri2_make_current()
+	 * on eglReleaseThread(). */
+	eglMakeCurrent(window->display->egl.dpy, EGL_NO_SURFACE, EGL_NO_SURFACE,
+		       EGL_NO_CONTEXT);
+
+	eglDestroySurface(window->display->egl.dpy, window->egl_surface);
+	wl_egl_window_destroy(window->native);
+
+	if (window->xdg_toplevel)
+		zxdg_toplevel_v6_destroy(window->xdg_toplevel);
+	if (window->xdg_surface)
+		zxdg_surface_v6_destroy(window->xdg_surface);
+	wl_surface_destroy(window->surface);
+
+	if (window->callback)
+		wl_callback_destroy(window->callback);
+}
+
+static int i = 0;
+static void
+redraw(void *data, struct wl_callback *callback, uint32_t time)
+{
+	struct window *window = data;
+	struct display *display = window->display;
+
+	static const int32_t  benchmark_interval = 5;
+	struct wl_region *region;
+	EGLint rect[4];
+	EGLint buffer_age = 0;
+	struct timeval tv;
+	ESMatrix modelview;
+
+	assert(window->callback == callback);
+	window->callback = NULL;
+
+	if (callback)
+		wl_callback_destroy(callback);
+
+	gettimeofday(&tv, NULL);
+	time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+	if (window->frames == 0)
+		window->benchmark_time = time;
+	if (time - window->benchmark_time > (benchmark_interval * 1000)) {
+		printf("%d frames in %d seconds: %f fps\n",
+		       window->frames,
+		       benchmark_interval,
+		       (float) window->frames / benchmark_interval);
+		window->benchmark_time = time;
+		window->frames = 0;
+	}
+
+	if (display->swap_buffers_with_damage)
+		eglQuerySurface(display->egl.dpy, window->egl_surface,
+				EGL_BUFFER_AGE_EXT, &buffer_age);
+
+	glViewport(0, 0, window->geometry.width, window->geometry.height);
+
+	glClearColor(0.0, 0.0, 0.0, 0.0);
+	glClear(GL_COLOR_BUFFER_BIT);
+
+	esMatrixLoadIdentity(&modelview);
+	esTranslate(&modelview, 0.0f, 0.0f, -8.0f);
+	esRotate(&modelview, 45.0f + (0.25f * i), 1.0f, 0.0f, 0.0f);
+	esRotate(&modelview, 45.0f - (0.5f * i), 0.0f, 1.0f, 0.0f);
+	esRotate(&modelview, 10.0f + (0.15f * i), 0.0f, 0.0f, 1.0f);
+	i++;
+
+	GLfloat aspect = (GLfloat)(window->geometry.width) / (GLfloat)(window->geometry.height);
+
+	ESMatrix projection;
+	esMatrixLoadIdentity(&projection);
+	esFrustum(&projection, -2.3f, +2.3f, -2.3f * aspect, +2.3f * aspect, 6.0f, 10.0f);
+
+	ESMatrix modelviewprojection;
+	esMatrixLoadIdentity(&modelviewprojection);
+	esMatrixMultiply(&modelviewprojection, &modelview, &projection);
+
+	float normal[9];
+	normal[0] = modelview.m[0][0];
+	normal[1] = modelview.m[0][1];
+	normal[2] = modelview.m[0][2];
+	normal[3] = modelview.m[1][0];
+	normal[4] = modelview.m[1][1];
+	normal[5] = modelview.m[1][2];
+	normal[6] = modelview.m[2][0];
+	normal[7] = modelview.m[2][1];
+	normal[8] = modelview.m[2][2];
+
+	glUniformMatrix4fv(gl.modelviewmatrix, 1, GL_FALSE, &modelview.m[0][0]);
+	glUniformMatrix4fv(gl.modelviewprojectionmatrix, 1, GL_FALSE, &modelviewprojection.m[0][0]);
+	glUniformMatrix3fv(gl.normalmatrix, 1, GL_FALSE, normal);
+
+	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid*)gl.positionsoffset);
+	glEnableVertexAttribArray(0);
+	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid*)gl.normalsoffset);
+	glEnableVertexAttribArray(1);
+	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid*)gl.colorsoffset);
+	glEnableVertexAttribArray(2);
+
+	glEnable(GL_CULL_FACE);
+
+	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+	glDrawArrays(GL_TRIANGLE_STRIP, 4, 4);
+	glDrawArrays(GL_TRIANGLE_STRIP, 8, 4);
+	glDrawArrays(GL_TRIANGLE_STRIP, 12, 4);
+	glDrawArrays(GL_TRIANGLE_STRIP, 16, 4);
+	glDrawArrays(GL_TRIANGLE_STRIP, 20, 4);
+
+	glDisableVertexAttribArray(window->gl.pos);
+	glDisableVertexAttribArray(window->gl.col);
+
+	if (window->opaque || window->fullscreen) {
+		region = wl_compositor_create_region(window->display->compositor);
+		wl_region_add(region, 0, 0,
+			      window->geometry.width,
+			      window->geometry.height);
+		wl_surface_set_opaque_region(window->surface, region);
+		wl_region_destroy(region);
+	} else {
+		wl_surface_set_opaque_region(window->surface, NULL);
+	}
+
+	if (display->swap_buffers_with_damage && buffer_age > 0) {
+		rect[0] = window->geometry.width / 4 - 1;
+		rect[1] = window->geometry.height / 4 - 1;
+		rect[2] = window->geometry.width / 2 + 2;
+		rect[3] = window->geometry.height / 2 + 2;
+		display->swap_buffers_with_damage(display->egl.dpy,
+						  window->egl_surface,
+						  rect, 1);
+	} else {
+		eglSwapBuffers(display->egl.dpy, window->egl_surface);
+	}
+	window->frames++;
+}
+
+static void
+pointer_handle_enter(void *data, struct wl_pointer *pointer,
+		     uint32_t serial, struct wl_surface *surface,
+		     wl_fixed_t sx, wl_fixed_t sy)
+{
+	struct display *display = data;
+	struct wl_buffer *buffer;
+	struct wl_cursor *cursor = display->default_cursor;
+	struct wl_cursor_image *image;
+
+	if (display->window->fullscreen)
+		wl_pointer_set_cursor(pointer, serial, NULL, 0, 0);
+	else if (cursor) {
+		image = display->default_cursor->images[0];
+		buffer = wl_cursor_image_get_buffer(image);
+		if (!buffer)
+			return;
+		wl_pointer_set_cursor(pointer, serial,
+				      display->cursor_surface,
+				      image->hotspot_x,
+				      image->hotspot_y);
+		wl_surface_attach(display->cursor_surface, buffer, 0, 0);
+		wl_surface_damage(display->cursor_surface, 0, 0,
+				  image->width, image->height);
+		wl_surface_commit(display->cursor_surface);
+	}
+}
+
+static void
+pointer_handle_leave(void *data, struct wl_pointer *pointer,
+		     uint32_t serial, struct wl_surface *surface)
+{
+}
+
+static void
+pointer_handle_motion(void *data, struct wl_pointer *pointer,
+		      uint32_t time, wl_fixed_t sx, wl_fixed_t sy)
+{
+}
+
+static void
+pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
+		      uint32_t serial, uint32_t time, uint32_t button,
+		      uint32_t state)
+{
+	struct display *display = data;
+
+	if (!display->window->xdg_toplevel)
+		return;
+
+	if (button == BTN_LEFT && state == WL_POINTER_BUTTON_STATE_PRESSED)
+		zxdg_toplevel_v6_move(display->window->xdg_toplevel,
+				      display->seat, serial);
+}
+
+static void
+pointer_handle_axis(void *data, struct wl_pointer *wl_pointer,
+		    uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+	pointer_handle_enter,
+	pointer_handle_leave,
+	pointer_handle_motion,
+	pointer_handle_button,
+	pointer_handle_axis,
+};
+
+static void
+touch_handle_down(void *data, struct wl_touch *wl_touch,
+		  uint32_t serial, uint32_t time, struct wl_surface *surface,
+		  int32_t id, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+	struct display *d = (struct display *)data;
+
+	if (!d->shell)
+		return;
+
+	zxdg_toplevel_v6_move(d->window->xdg_toplevel, d->seat, serial);
+}
+
+static void
+touch_handle_up(void *data, struct wl_touch *wl_touch,
+		uint32_t serial, uint32_t time, int32_t id)
+{
+}
+
+static void
+touch_handle_motion(void *data, struct wl_touch *wl_touch,
+		    uint32_t time, int32_t id, wl_fixed_t x_w, wl_fixed_t y_w)
+{
+}
+
+static void
+touch_handle_frame(void *data, struct wl_touch *wl_touch)
+{
+}
+
+static void
+touch_handle_cancel(void *data, struct wl_touch *wl_touch)
+{
+}
+
+static const struct wl_touch_listener touch_listener = {
+	touch_handle_down,
+	touch_handle_up,
+	touch_handle_motion,
+	touch_handle_frame,
+	touch_handle_cancel,
+};
+
+static void
+keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+		       uint32_t format, int fd, uint32_t size)
+{
+}
+
+static void
+keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+		      uint32_t serial, struct wl_surface *surface,
+		      struct wl_array *keys)
+{
+}
+
+static void
+keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+		      uint32_t serial, struct wl_surface *surface)
+{
+}
+
+static void
+keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+		    uint32_t serial, uint32_t time, uint32_t key,
+		    uint32_t state)
+{
+	struct display *d = data;
+
+	if (!d->shell)
+		return;
+
+	if (key == KEY_F11 && state) {
+		if (d->window->fullscreen)
+			zxdg_toplevel_v6_unset_fullscreen(d->window->xdg_toplevel);
+		else
+			zxdg_toplevel_v6_set_fullscreen(d->window->xdg_toplevel,
+							NULL);
+	} else if (key == KEY_ESC && state)
+		running = 0;
+}
+
+static void
+keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+			  uint32_t serial, uint32_t mods_depressed,
+			  uint32_t mods_latched, uint32_t mods_locked,
+			  uint32_t group)
+{
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+	keyboard_handle_keymap,
+	keyboard_handle_enter,
+	keyboard_handle_leave,
+	keyboard_handle_key,
+	keyboard_handle_modifiers,
+};
+
+static void
+seat_handle_capabilities(void *data, struct wl_seat *seat,
+			 enum wl_seat_capability caps)
+{
+	struct display *d = data;
+
+	if ((caps & WL_SEAT_CAPABILITY_POINTER) && !d->pointer) {
+		d->pointer = wl_seat_get_pointer(seat);
+		wl_pointer_add_listener(d->pointer, &pointer_listener, d);
+	} else if (!(caps & WL_SEAT_CAPABILITY_POINTER) && d->pointer) {
+		wl_pointer_destroy(d->pointer);
+		d->pointer = NULL;
+	}
+
+	if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !d->keyboard) {
+		d->keyboard = wl_seat_get_keyboard(seat);
+		wl_keyboard_add_listener(d->keyboard, &keyboard_listener, d);
+	} else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && d->keyboard) {
+		wl_keyboard_destroy(d->keyboard);
+		d->keyboard = NULL;
+	}
+
+	if ((caps & WL_SEAT_CAPABILITY_TOUCH) && !d->touch) {
+		d->touch = wl_seat_get_touch(seat);
+		wl_touch_set_user_data(d->touch, d);
+		wl_touch_add_listener(d->touch, &touch_listener, d);
+	} else if (!(caps & WL_SEAT_CAPABILITY_TOUCH) && d->touch) {
+		wl_touch_destroy(d->touch);
+		d->touch = NULL;
+	}
+}
+
+static const struct wl_seat_listener seat_listener = {
+	seat_handle_capabilities,
+};
+
+static void
+xdg_shell_ping(void *data, struct zxdg_shell_v6 *shell, uint32_t serial)
+{
+	zxdg_shell_v6_pong(shell, serial);
+}
+
+static const struct zxdg_shell_v6_listener xdg_shell_listener = {
+	xdg_shell_ping,
+};
+
+static void
+registry_handle_global(void *data, struct wl_registry *registry,
+		       uint32_t name, const char *interface, uint32_t version)
+{
+	struct display *d = data;
+
+	if (strcmp(interface, "wl_compositor") == 0) {
+		d->compositor =
+			wl_registry_bind(registry, name,
+					 &wl_compositor_interface, 1);
+	} else if (strcmp(interface, "zxdg_shell_v6") == 0) {
+		d->shell = wl_registry_bind(registry, name,
+					    &zxdg_shell_v6_interface, 1);
+		zxdg_shell_v6_add_listener(d->shell, &xdg_shell_listener, d);
+	} else if (strcmp(interface, "wl_seat") == 0) {
+		d->seat = wl_registry_bind(registry, name,
+					   &wl_seat_interface, 1);
+		wl_seat_add_listener(d->seat, &seat_listener, d);
+	} else if (strcmp(interface, "wl_shm") == 0) {
+		d->shm = wl_registry_bind(registry, name,
+					  &wl_shm_interface, 1);
+		d->cursor_theme = wl_cursor_theme_load(NULL, 32, d->shm);
+		if (!d->cursor_theme) {
+			fprintf(stderr, "unable to load default theme\n");
+			return;
+		}
+		d->default_cursor =
+			wl_cursor_theme_get_cursor(d->cursor_theme, "left_ptr");
+		if (!d->default_cursor) {
+			fprintf(stderr, "unable to load default left pointer\n");
+			// TODO: abort ?
+		}
+	}
+}
+
+static void
+registry_handle_global_remove(void *data, struct wl_registry *registry,
+			      uint32_t name)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+	registry_handle_global,
+	registry_handle_global_remove
+};
+
+static void
+signal_int(int signum)
+{
+	running = 0;
+}
+
+static void
+usage(int error_code)
+{
+	fprintf(stderr, "Usage: simple-egl [OPTIONS]\n\n"
+		"  -f\tRun in fullscreen mode\n"
+		"  -o\tCreate an opaque surface\n"
+		"  -s\tUse a 16 bpp EGL config\n"
+		"  -b\tDon't sync to compositor redraw (eglSwapInterval 0)\n"
+		"  -h\tThis help text\n\n");
+
+	exit(error_code);
+}
+
+int
+main(int argc, char **argv)
+{
+	struct sigaction sigint;
+	struct display display = { 0 };
+	struct window  window  = { 0 };
+	int i, ret = 0;
+
+	window.display = &display;
+	display.window = &window;
+	window.geometry.width  = 250;
+	window.geometry.height = 250;
+	window.window_size = window.geometry;
+	window.buffer_size = 32;
+	window.frame_sync = 1;
+
+	for (i = 1; i < argc; i++) {
+		if (strcmp("-f", argv[i]) == 0)
+			window.fullscreen = 1;
+		else if (strcmp("-o", argv[i]) == 0)
+			window.opaque = 1;
+		else if (strcmp("-s", argv[i]) == 0)
+			window.buffer_size = 16;
+		else if (strcmp("-b", argv[i]) == 0)
+			window.frame_sync = 0;
+		else if (strcmp("-w", argv[i]) == 0) {
+			window.geometry.width  = atoi(argv[i + 1]);
+			window.geometry.height = atoi(argv[i + 1]);
+			window.window_size = window.geometry;
+			i++;
+		}
+		else if (strcmp("-h", argv[i]) == 0)
+			usage(EXIT_SUCCESS);
+		else
+			usage(EXIT_FAILURE);
+	}
+
+	display.display = wl_display_connect(NULL);
+	assert(display.display);
+
+	display.registry = wl_display_get_registry(display.display);
+	wl_registry_add_listener(display.registry,
+				 &registry_listener, &display);
+
+	wl_display_roundtrip(display.display);
+
+	init_egl(&display, &window);
+	create_surface(&window);
+	init_gl(&window);
+
+	display.cursor_surface =
+		wl_compositor_create_surface(display.compositor);
+
+	sigint.sa_handler = signal_int;
+	sigemptyset(&sigint.sa_mask);
+	sigint.sa_flags = SA_RESETHAND;
+	sigaction(SIGINT, &sigint, NULL);
+
+	/* The mainloop here is a little subtle.  Redrawing will cause
+	 * EGL to read events so we can just call
+	 * wl_display_dispatch_pending() to handle any events that got
+	 * queued up as a side effect. */
+	while (running && ret != -1) {
+		if (window.wait_for_configure) {
+			wl_display_dispatch(display.display);
+		} else {
+			wl_display_dispatch_pending(display.display);
+			redraw(&window, NULL, 0);
+		}
+	}
+
+	fprintf(stderr, "simple-egl exiting\n");
+
+	destroy_surface(&window);
+	fini_egl(&display);
+
+	wl_surface_destroy(display.cursor_surface);
+	if (display.cursor_theme)
+		wl_cursor_theme_destroy(display.cursor_theme);
+
+	if (display.shell)
+		zxdg_shell_v6_destroy(display.shell);
+
+	if (display.compositor)
+		wl_compositor_destroy(display.compositor);
+
+	wl_registry_destroy(display.registry);
+	wl_display_flush(display.display);
+	wl_display_disconnect(display.display);
+
+	return 0;
+}
diff --git a/clients/slideshow.c b/clients/slideshow.c
new file mode 100644
index 0000000..21d43d3
--- /dev/null
+++ b/clients/slideshow.c
@@ -0,0 +1,581 @@
+/*
+ * Copyright © 2008 Kristian Høgsberg
+ * Copyright © 2009 Chris Wilson
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include "config.h"
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <fcntl.h>
+#include <libgen.h>
+#include <unistd.h>
+#include <math.h>
+#include <time.h>
+#include <cairo.h>
+#include <assert.h>
+#include <linux/input.h>
+#include <sys/timerfd.h>
+#include <sys/epoll.h>
+
+#include <wayland-client.h>
+#include "shared/helpers.h"
+#include "shared/xalloc.h"
+
+#include "window.h"
+#include "../shared/cairo-util.h"
+
+static int window_width = 1280;
+static int window_height = 720;
+static int slideshow_delay = 5;
+
+struct image {
+	struct window *window;
+	struct widget *widget;
+	struct display *display;
+	char *filename;
+	cairo_surface_t *image;
+	int fullscreen;
+	int *image_counter;
+	int32_t width, height;
+
+	struct {
+		double x;
+		double y;
+	} pointer;
+	bool button_pressed;
+
+	bool initialized;
+	cairo_matrix_t matrix;
+
+	cairo_surface_t **images;
+	int *initialized_list;
+	int images_number;
+	int current_image_index;
+};
+
+struct clock {
+	struct image *image;
+	struct task clock_task;
+	int clock_fd;
+};
+
+void clock_func(struct task *task, uint32_t events);
+static int clock_timer_reset(struct clock *clock);
+struct clock *init_timer(struct image *image);
+
+static double
+get_scale(struct image *image)
+{
+	assert(image->matrix.xy == 0.0 &&
+	       image->matrix.yx == 0.0 &&
+	       image->matrix.xx == image->matrix.yy);
+	return image->matrix.xx;
+}
+
+static void
+clamp_view(struct image *image)
+{
+	struct rectangle allocation;
+	double scale = get_scale(image);
+	double sw, sh;
+
+	sw = image->width * scale;
+	sh = image->height * scale;
+	widget_get_allocation(image->widget, &allocation);
+
+	if (sw < allocation.width) {
+		image->matrix.x0 =
+			(allocation.width - image->width * scale) / 2;
+	} else {
+		if (image->matrix.x0 > 0.0)
+			image->matrix.x0 = 0.0;
+		if (sw + image->matrix.x0 < allocation.width)
+			image->matrix.x0 = allocation.width - sw;
+	}
+
+	if (sh < allocation.width) {
+		image->matrix.y0 =
+			(allocation.height - image->height * scale) / 2;
+	} else {
+		if (image->matrix.y0 > 0.0)
+			image->matrix.y0 = 0.0;
+		if (sh + image->matrix.y0 < allocation.height)
+			image->matrix.y0 = allocation.height - sh;
+	}
+}
+
+static void
+redraw_handler(struct widget *widget, void *data)
+{
+	struct image *image = data;
+	struct rectangle allocation;
+	cairo_t *cr;
+	cairo_surface_t *surface;
+	double width, height, doc_aspect, window_aspect, scale;
+	cairo_matrix_t matrix;
+	cairo_matrix_t translate;
+
+	surface = window_get_surface(image->window);
+	cr = cairo_create(surface);
+	widget_get_allocation(image->widget, &allocation);
+	cairo_rectangle(cr, allocation.x, allocation.y,
+			allocation.width, allocation.height);
+	cairo_clip(cr);
+	cairo_push_group(cr);
+	cairo_translate(cr, allocation.x, allocation.y);
+
+	cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
+	cairo_set_source_rgba(cr, 0, 0, 0, 1);
+	cairo_paint(cr);
+
+	if (!image->initialized_list[image->current_image_index]) {
+		image->initialized_list[image->current_image_index] = 1;
+		width = cairo_image_surface_get_width(image->images[image->current_image_index]);
+		height = cairo_image_surface_get_height(image->images[image->current_image_index]);
+
+		doc_aspect = width / height;
+		window_aspect = (double) allocation.width / allocation.height;
+		if (doc_aspect < window_aspect)
+			scale = allocation.height / height;
+		else
+			scale = allocation.width / width;
+
+		image->width = width;
+		image->height = height;
+		cairo_matrix_init_scale(&image->matrix, scale, scale);
+
+		clamp_view(image);
+	}
+
+	matrix = image->matrix;
+	cairo_matrix_init_translate(&translate, allocation.x, allocation.y);
+	cairo_matrix_multiply(&matrix, &matrix, &translate);
+	cairo_set_matrix(cr, &matrix);
+
+	cairo_set_source_surface(cr, image->images[image->current_image_index], 0, 0);
+	cairo_set_operator(cr, CAIRO_OPERATOR_OVER);
+	cairo_paint(cr);
+
+	cairo_pop_group_to_source(cr);
+	cairo_paint(cr);
+	cairo_destroy(cr);
+
+	cairo_surface_destroy(surface);
+}
+
+static void
+resize_handler(struct widget *widget,
+	       int32_t width, int32_t height, void *data)
+{
+	struct image *image = data;
+
+	clamp_view(image);
+}
+
+static void
+keyboard_focus_handler(struct window *window,
+		       struct input *device, void *data)
+{
+	struct image *image = data;
+
+	window_schedule_redraw(image->window);
+}
+
+static int
+enter_handler(struct widget *widget,
+	      struct input *input,
+	      float x, float y, void *data)
+{
+	struct image *image = data;
+	struct rectangle allocation;
+
+	widget_get_allocation(image->widget, &allocation);
+	x -= allocation.x;
+	y -= allocation.y;
+
+	image->pointer.x = x;
+	image->pointer.y = y;
+
+	return 1;
+}
+
+static void
+move_viewport(struct image *image, double dx, double dy)
+{
+	double scale = get_scale(image);
+
+	if (!image->initialized)
+		return;
+
+	cairo_matrix_translate(&image->matrix, -dx/scale, -dy/scale);
+	clamp_view(image);
+
+	window_schedule_redraw(image->window);
+}
+
+static int
+motion_handler(struct widget *widget,
+	       struct input *input, uint32_t time,
+	       float x, float y, void *data)
+{
+	struct image *image = data;
+	struct rectangle allocation;
+
+	widget_get_allocation(image->widget, &allocation);
+	x -= allocation.x;
+	y -= allocation.y;
+
+	if (image->button_pressed)
+		move_viewport(image, image->pointer.x - x,
+			      image->pointer.y - y);
+
+	image->pointer.x = x;
+	image->pointer.y = y;
+
+	return image->button_pressed ? CURSOR_DRAGGING : CURSOR_LEFT_PTR;
+}
+
+static void
+button_handler(struct widget *widget,
+	       struct input *input, uint32_t time,
+	       uint32_t button,
+	       enum wl_pointer_button_state state,
+	       void *data)
+{
+	struct image *image = data;
+
+	switch (button) {
+	case BTN_LEFT:
+		image->button_pressed =
+			state == WL_POINTER_BUTTON_STATE_PRESSED;
+
+		if (state == WL_POINTER_BUTTON_STATE_PRESSED) {
+			input_set_pointer_image(input, CURSOR_DRAGGING);
+			window_move(image->window, input,
+				    display_get_serial(image->display));
+		}
+		break;
+	}
+}
+
+static void
+zoom(struct image *image, double scale)
+{
+	double x = image->pointer.x;
+	double y = image->pointer.y;
+	cairo_matrix_t scale_matrix;
+
+	if (!image->initialized)
+		return;
+
+	if (get_scale(image) * scale > 20.0 ||
+	    get_scale(image) * scale < 0.02)
+		return;
+
+	cairo_matrix_init_identity(&scale_matrix);
+	cairo_matrix_translate(&scale_matrix, x, y);
+	cairo_matrix_scale(&scale_matrix, scale, scale);
+	cairo_matrix_translate(&scale_matrix, -x, -y);
+
+	cairo_matrix_multiply(&image->matrix, &image->matrix, &scale_matrix);
+	clamp_view(image);
+}
+
+static void
+key_handler(struct window *window, struct input *input, uint32_t time,
+	    uint32_t key, uint32_t sym, enum wl_keyboard_key_state state,
+	    void *data)
+{
+	struct image *image = data;
+
+	if (state == WL_KEYBOARD_KEY_STATE_RELEASED)
+		return;
+
+	switch (sym) {
+	case XKB_KEY_minus:
+		zoom(image, 0.8);
+		window_schedule_redraw(image->window);
+		break;
+	case XKB_KEY_equal:
+	case XKB_KEY_plus:
+		zoom(image, 1.2);
+		window_schedule_redraw(image->window);
+		break;
+	case XKB_KEY_1:
+		image->matrix.xx = 1.0;
+		image->matrix.xy = 0.0;
+		image->matrix.yx = 0.0;
+		image->matrix.yy = 1.0;
+		clamp_view(image);
+		window_schedule_redraw(image->window);
+		break;
+	case XKB_KEY_Left:
+	case XKB_KEY_Down:
+		image->current_image_index--;
+		if (image->current_image_index < 0 )
+			image->current_image_index = image->images_number - 1;
+		window_schedule_redraw(image->window);
+		break;
+
+	case XKB_KEY_Right:
+	case XKB_KEY_Up:
+		image->current_image_index++;
+		if (image->current_image_index >= image->images_number)
+			image->current_image_index = 0;
+		window_schedule_redraw(image->window);
+		break;
+
+	}
+}
+
+static void
+axis_handler(struct widget *widget, struct input *input, uint32_t time,
+	     uint32_t axis, wl_fixed_t value, void *data)
+{
+	struct image *image = data;
+
+	if (axis == WL_POINTER_AXIS_VERTICAL_SCROLL &&
+	    input_get_modifiers(input) == MOD_CONTROL_MASK) {
+		/* set zoom level to 2% per 10 axis units */
+		zoom(image, (1.0 - wl_fixed_to_double(value) / 500.0));
+
+		window_schedule_redraw(image->window);
+	} else if (input_get_modifiers(input) == 0) {
+		if (axis == WL_POINTER_AXIS_VERTICAL_SCROLL)
+			move_viewport(image, 0, wl_fixed_to_double(value));
+		else if (axis == WL_POINTER_AXIS_HORIZONTAL_SCROLL)
+			move_viewport(image, wl_fixed_to_double(value), 0);
+	}
+}
+
+static void
+fullscreen_handler(struct window *window, void *data)
+{
+	struct image *image = data;
+
+	image->fullscreen ^= 1;
+	window_set_fullscreen(window, image->fullscreen);
+}
+
+static void
+close_handler(void *data)
+{
+	struct image *image = data;
+
+	*image->image_counter -= 1;
+
+	if (*image->image_counter == 0)
+		display_exit(image->display);
+
+	widget_destroy(image->widget);
+	window_destroy(image->window);
+
+	free(image);
+}
+
+static struct image *
+image_create_slideshow(struct display *display, char *filename[],
+	     int number_of_counter, int *image_counter)
+{
+	struct image *image;
+	char *b, *copy, title[512];
+	int i;
+
+	image = zalloc(sizeof *image);
+	if (image == NULL)
+		return image;
+
+	image->images = zalloc( (sizeof image->images) * number_of_counter);
+	image->initialized_list = zalloc((sizeof image->initialized_list) * number_of_counter);
+
+	for (i = 0; i < number_of_counter; i++) {
+		copy = strdup(filename[i]);
+		b = basename(copy);
+		snprintf(title, sizeof title, "Wayland Image - %s", b);
+		free(copy);
+
+		image->images[i] = load_cairo_surface(filename[i]);
+		if (!image->images[i]) {
+			fprintf(stderr, "could not find the image %s!\n", filename[i]);
+			free(image->images[i]);
+			return NULL;
+		}
+		fprintf(stderr, "image loaded: %s\n", filename[i]);
+		image->initialized_list[i] = 0;
+	}
+	image->images_number = number_of_counter;
+	image->current_image_index = 0;
+
+	image->window = window_create(display);
+	image->widget =  window_add_widget(image->window, image);
+	window_set_title(image->window, title);
+	image->display = display;
+	image->image_counter = image_counter;
+	*image_counter += 1;
+	image->initialized = false;
+
+	window_set_user_data(image->window, image);
+	widget_set_redraw_handler(image->widget, redraw_handler);
+	widget_set_resize_handler(image->widget, resize_handler);
+	window_set_keyboard_focus_handler(image->window,
+					  keyboard_focus_handler);
+	window_set_fullscreen_handler(image->window, fullscreen_handler);
+	window_set_close_handler(image->window, close_handler);
+
+	widget_set_default_cursor(image->widget, CURSOR_HAND1);
+
+	widget_set_enter_handler(image->widget, enter_handler);
+	widget_set_motion_handler(image->widget, motion_handler);
+	widget_set_button_handler(image->widget, button_handler);
+	widget_set_axis_handler(image->widget, axis_handler);
+	window_set_key_handler(image->window, key_handler);
+	widget_schedule_resize(image->widget, window_width, window_height);
+
+	return image;
+}
+
+static int
+clock_timer_reset(struct clock *clock)
+{
+	struct itimerspec its;
+	fprintf(stderr, "->clock_timer_reset\n");
+
+	its.it_interval.tv_sec = slideshow_delay;
+	its.it_interval.tv_nsec = 0;
+	its.it_value.tv_sec = slideshow_delay;
+	its.it_value.tv_nsec = 0;
+	if (timerfd_settime(clock->clock_fd, 0, &its, NULL) < 0) {
+		fprintf(stderr, "could not set timerfd\n: %m");
+		return -1;
+	}
+
+	return 0;
+}
+
+void
+clock_func(struct task *task, uint32_t events)
+{
+	struct clock *clock =
+		container_of(task, struct clock, clock_task);
+	uint64_t exp;
+
+	clock->image->current_image_index++;
+	if (clock->image->current_image_index >=
+			clock->image->images_number)
+		clock->image->current_image_index = 0;
+
+	window_schedule_redraw(clock->image->window);
+
+	if (read(clock->clock_fd, &exp, sizeof exp) != sizeof exp)
+		abort();
+}
+
+struct clock *
+init_timer(struct image *image)
+{
+	int timerfd;
+	struct clock *clock;
+
+	clock = xzalloc(sizeof *clock);
+
+	timerfd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC);
+	if (timerfd < 0) {
+		fprintf(stderr, "could not create timerfd\n: %m");
+		return NULL;
+	}
+
+	clock->clock_fd = timerfd;
+	clock->clock_task.run = clock_func;
+	clock->image = image;
+
+	display_watch_fd(clock->image->display, clock->clock_fd,
+			 EPOLLIN, &clock->clock_task);
+	clock_timer_reset(clock);
+	return clock;
+}
+
+int
+main(int argc, char *argv[])
+{
+	struct display *d;
+	int i;
+	int image_counter = 0;
+	struct image *image;
+	int nparam = argc;
+
+	for (i = 1; i < argc; i++) {
+		if (strcmp("--width", argv[i]) == 0 &&
+			 i + 1 < argc) {
+			window_width = atoi(argv[i + 1]);
+			i++;
+			nparam = nparam - 2;
+		} else if (strcmp("--height", argv[i]) == 0 &&
+			 i + 1 < argc) {
+			window_height = atoi(argv[i + 1]);
+			i++;
+			nparam = nparam - 2;
+		} else if (strcmp("--delay", argv[i]) == 0 &&
+			 i + 1 < argc) {
+			slideshow_delay = atoi(argv[i + 1]);
+			i++;
+			nparam = nparam - 2;
+		} else if (strcmp("--help", argv[i]) == 0) {
+			printf("Usage: %s [OPTIONS] <list of files>\n"
+				"  --width <width>\n"
+				"  --height <height>\n"
+				"  --delay <delay on second>\n",
+				argv[0]);
+			return 1;
+		}
+	}
+	if ( (nparam -1)  <= 0) {
+			printf("Usage: %s [OPTIONS] <list of files>\n"
+			       "  --width <width>\n"
+			       "  --height <height>\n"
+			       "  --delay <delay on second>\n",
+			       argv[0]);
+			return 1;
+	}
+
+	d = display_create(&argc, argv);
+	if (d == NULL) {
+		fprintf(stderr, "failed to create display: %m\n");
+		return -1;
+	}
+
+	image = image_create_slideshow(d, (argv + argc - (nparam-1)), nparam -1, &image_counter);
+
+	printf("Type enter on console to show the picture\n");
+	getchar();
+
+	init_timer(image);
+
+	if (image_counter > 0)
+		display_run(d);
+
+	display_destroy(d);
+
+	return 0;
+}
-- 
2.7.4

