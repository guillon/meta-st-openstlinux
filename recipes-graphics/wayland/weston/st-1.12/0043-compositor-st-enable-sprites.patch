From 8cbde3d492f65bb8350142bba6ccd750a1af892b Mon Sep 17 00:00:00 2001
From: Vincent Abriou <vincent.abriou@st.com>
Date: Mon, 8 Aug 2016 16:56:57 +0200
Subject: [PATCH 43/61] compositor-st: enable sprites

- Enable sprites (sprites_are_broken set to 0)
- If drmModeAddFB2 fails, do not stop trying to use sprites
- Add weston_xlog related to sprite assignment.

Change-Id: Ib48791ca7a1e0edd9b060cd7a8c35dd30f5f2ee4
Signed-off-by: Fabien Dessenne <fabien.dessenne@st.com>
---
 libweston/compositor-st.c | 55 ++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 45 insertions(+), 10 deletions(-)

diff --git a/libweston/compositor-st.c b/libweston/compositor-st.c
index eb136d7..b1daf62 100644
--- a/libweston/compositor-st.c
+++ b/libweston/compositor-st.c
@@ -426,8 +426,6 @@ drm_fb_get_from_bo(struct gbm_bo *bo,
 				    &fb->fb_id, 0);
 		if (ret) {
 			weston_log("addfb2 failed: %m\n");
-			backend->no_addfb2 = 1;
-			backend->sprites_are_broken = 1;
 		}
 	}
 
@@ -582,6 +580,8 @@ drm_output_render_pixman(struct drm_output *output, pixman_region32_t *damage)
 	struct weston_compositor *ec = output->base.compositor;
 	pixman_region32_t total_damage, previous_damage;
 
+	weston_xlog("%s\n",__func__);
+
 	pixman_region32_init(&total_damage);
 	pixman_region32_init(&previous_damage);
 
@@ -675,6 +675,8 @@ drm_output_repaint(struct weston_output *output_base,
 	struct drm_mode *mode;
 	int ret = 0;
 
+	weston_xlog("%s: output_base=%p\n", __func__, output_base);
+
 	if (output->disable_pending || output->destroy_pending)
 		return -1;
 
@@ -686,6 +688,7 @@ drm_output_repaint(struct weston_output *output_base,
 	mode = container_of(output->base.current_mode, struct drm_mode, base);
 	if (!output->current ||
 	    output->current->stride != output->next->stride) {
+		weston_xlog(" drmModeSetCrtc output->crtc_id = %d\n", output->crtc_id);
 		ret = drmModeSetCrtc(backend->drm.fd, output->crtc_id,
 				     output->next->fb_id, 0, 0,
 				     &output->connector_id, 1,
@@ -697,6 +700,7 @@ drm_output_repaint(struct weston_output *output_base,
 		output_base->set_dpms(output_base, WESTON_DPMS_ON);
 	}
 
+	weston_xlog(" drmModePageFlip output->crtc_id = %d\n", output->crtc_id);
 	if (drmModePageFlip(backend->drm.fd, output->crtc_id,
 			    output->next->fb_id,
 			    DRM_MODE_PAGE_FLIP_EVENT, output) < 0) {
@@ -725,6 +729,9 @@ drm_output_repaint(struct weston_output *output_base,
 		if (s->next && !backend->sprites_hidden)
 			fb_id = s->next->fb_id;
 
+		weston_xlog(" refresh the sprite=%p crtc_id=%d plane_id=%d possible_crtcs=%d fb_id=%d\n",
+				s, output->crtc_id, s->plane_id, s->possible_crtcs, fb_id);
+
 		ret = drmModeSetPlane(backend->drm.fd, s->plane_id,
 				      output->crtc_id, fb_id, flags,
 				      s->dest_x, s->dest_y,
@@ -732,7 +739,7 @@ drm_output_repaint(struct weston_output *output_base,
 				      s->src_x, s->src_y,
 				      s->src_w, s->src_h);
 		if (ret)
-			weston_log("setplane failed: %d: %s\n",
+			weston_log(" setplane failed: %d: %s\n",
 				ret, strerror(errno));
 
 		vbl.request.type |= drm_waitvblank_pipe(output);
@@ -744,7 +751,7 @@ drm_output_repaint(struct weston_output *output_base,
 		vbl.request.signal = (unsigned long)s;
 		ret = drmWaitVBlank(backend->drm.fd, &vbl);
 		if (ret) {
-			weston_log("vblank event request failed: %d: %s\n",
+			weston_log(" vblank event request failed: %d: %s\n",
 				ret, strerror(errno));
 		}
 
@@ -885,6 +892,9 @@ page_flip_handler(int fd, unsigned int frame,
 
 	drm_output_update_msc(output, frame);
 
+	weston_xlog("%s: crtc_id=%d (sec=%d usec=%d)\n",
+			__func__, output->crtc_id, sec, usec);
+
 	/* We don't set page_flip_pending on start_repaint_loop, in that case
 	 * we just want to page flip to the current buffer to get an accurate
 	 * timestamp */
@@ -965,6 +975,8 @@ drm_output_prepare_overlay_view(struct drm_output *output,
 	uint32_t format;
 	wl_fixed_t sx1, sy1, sx2, sy2;
 
+	weston_xlog("   %s: output_base->id = %d\n", __func__, output->base.id);
+
 	if (b->gbm == NULL)
 		return NULL;
 
@@ -1262,6 +1274,9 @@ drm_assign_planes(struct weston_output *output_base)
 	struct weston_view *ev, *next;
 	pixman_region32_t overlap, surface_overlap;
 	struct weston_plane *primary, *next_plane;
+	int i = 0;
+
+	weston_xlog("%s: output=%p\n", __func__, output);
 
 	/*
 	 * Find a surface for each sprite in the output using some heuristics:
@@ -1281,6 +1296,9 @@ drm_assign_planes(struct weston_output *output_base)
 
 	wl_list_for_each_safe(ev, next, &output_base->compositor->view_list, link) {
 		struct weston_surface *es = ev->surface;
+		weston_xlog(" assigning surface %d %p (%dx%d)...\n", i, es,
+				ev->surface->width, ev->surface->height);
+		i++;
 
 		/* Test whether this buffer can ever go into a plane:
 		 * non-shm, or small enough to be a cursor.
@@ -1304,16 +1322,34 @@ drm_assign_planes(struct weston_output *output_base)
 					  &ev->transform.boundingbox);
 
 		next_plane = NULL;
-		if (pixman_region32_not_empty(&surface_overlap))
+		if (pixman_region32_not_empty(&surface_overlap)) {
 			next_plane = primary;
-		if (next_plane == NULL)
+			if (next_plane)
+				weston_xlog(" ...assigned to primary (cause=overlap)\n");
+		}
+
+		if (next_plane == NULL) {
 			next_plane = drm_output_prepare_cursor_view(output, ev);
-		if (next_plane == NULL)
+			if (next_plane)
+				weston_xlog(" ...assigned to cursor\n");
+		}
+
+		if (next_plane == NULL) {
 			next_plane = drm_output_prepare_scanout_view(output, ev);
-		if (next_plane == NULL)
+			if (next_plane)
+				weston_xlog(" ...assigned to scanout\n");
+		}
+
+		if (next_plane == NULL) {
 			next_plane = drm_output_prepare_overlay_view(output, ev);
-		if (next_plane == NULL)
+			if (next_plane)
+				weston_xlog(" ...assigned to overlay\n");
+		}
+
+		if (next_plane == NULL) {
 			next_plane = primary;
+			weston_xlog(" ...assigned to primary (default)\n");
+		}
 
 		weston_view_move_to_plane(ev, next_plane);
 
@@ -3174,7 +3210,6 @@ drm_backend_create(struct weston_compositor *compositor,
 	 *
 	 * These can be enabled again when nuclear/atomic support lands.
 	 */
-	b->sprites_are_broken = 1;
 	b->compositor = compositor;
 	b->use_pixman = config->use_pixman;
 	b->use_current_mode = config->use_current_mode;
-- 
2.7.4

