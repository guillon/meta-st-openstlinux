From b62d5d9e00a68aaca2da32819e28c1248ddba29f Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@st.com>
Date: Fri, 3 Feb 2017 13:20:59 +0100
Subject: [PATCH 1/4] ST compositor adaptation

---
 Makefile.am                     |   76 +-
 compositor/main.c               |  815 ++++----
 configure.ac                    |   33 +-
 libweston/compositor-drm.c      |  440 +++--
 libweston/compositor-drm.h      |   50 +-
 libweston/compositor-fbdev.c    |   87 +-
 libweston/compositor-fbdev.h    |    4 +-
 libweston/compositor-headless.c |  152 +-
 libweston/compositor-headless.h |    8 +-
 libweston/compositor-rdp.c      |  139 +-
 libweston/compositor-rdp.h      |   26 +-
 libweston/compositor-st.c       | 3905 +++++++++++++++++++++++++++++++++++++++
 libweston/compositor-wayland.c  |  409 ++--
 libweston/compositor-wayland.h  |   12 +-
 libweston/compositor-x11.c      |  313 ++--
 libweston/compositor-x11.h      |   13 +-
 libweston/compositor.c          |  417 ++++-
 libweston/compositor.h          |   61 +-
 libweston/gl-renderer.c         |  331 +++-
 libweston/linux-dmabuf.c        |   60 +-
 libweston/linux-dmabuf.h        |   25 +-
 libweston/weston-egl-ext.h      |   20 +
 22 files changed, 6301 insertions(+), 1095 deletions(-)
 create mode 100644 libweston/compositor-st.c

diff --git a/Makefile.am b/Makefile.am
index 1e63a58..7e9dff5 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -72,11 +72,17 @@ install-libweston_moduleLTLIBRARIES install-moduleLTLIBRARIES: install-libLTLIBR
 lib_LTLIBRARIES = libweston-@LIBWESTON_MAJOR@.la
 libweston_@LIBWESTON_MAJOR@_la_CPPFLAGS = $(AM_CPPFLAGS) -DIN_WESTON
 libweston_@LIBWESTON_MAJOR@_la_CFLAGS = $(AM_CFLAGS) $(COMPOSITOR_CFLAGS) $(LIBUNWIND_CFLAGS)
+if ENABLE_DRM_COMPOSITOR
+libweston_@LIBWESTON_MAJOR@_la_CFLAGS += $(DRM_COMPOSITOR_CFLAGS)
+endif
 libweston_@LIBWESTON_MAJOR@_la_LIBADD = $(COMPOSITOR_LIBS) $(LIBUNWIND_LIBS) \
 	$(DLOPEN_LIBS) -lm $(CLOCK_GETTIME_LIBS) \
 	$(LIBINPUT_BACKEND_LIBS) libshared.la
 libweston_@LIBWESTON_MAJOR@_la_LDFLAGS = -version-info $(LT_VERSION_INFO)
 
+# Add this to allow pixman-renderer to be aware of DRM_FORMAT.
+libweston_@LIBWESTON_MAJOR@_la_CFLAGS += $(LIBDRM_CFLAGS)
+
 libweston_@LIBWESTON_MAJOR@_la_SOURCES =			\
 	libweston/git-version.h				\
 	libweston/log.c					\
@@ -285,6 +291,7 @@ libwestoninclude_HEADERS =			\
 	libweston/compositor-rdp.h		\
 	libweston/compositor-wayland.h		\
 	libweston/compositor-x11.h		\
+	libweston/windowed-output-api.h		\
 	libweston/plugin-registry.h		\
 	libweston/timeline-object.h		\
 	shared/matrix.h				\
@@ -376,6 +383,48 @@ drm_backend_la_CFLAGS += $(LIBVA_CFLAGS)
 endif
 endif
 
+if ENABLE_ST_COMPOSITOR
+libweston_module_LTLIBRARIES += st-backend.la
+st_backend_la_LDFLAGS = -module -avoid-version
+st_backend_la_LIBADD =				\
+	$(COMPOSITOR_LIBS)			\
+	$(ST_COMPOSITOR_LIBS)			\
+	$(INPUT_BACKEND_LIBS)			\
+	libshared.la				\
+	$(CLOCK_GETTIME_LIBS)			\
+	libsession-helper.la
+st_backend_la_CFLAGS =				\
+	$(COMPOSITOR_CFLAGS)			\
+	$(EGL_CFLAGS)				\
+	$(ST_COMPOSITOR_CFLAGS)			\
+	$(AM_CFLAGS)
+st_backend_la_SOURCES =				\
+	libweston/compositor-st.c		\
+	libweston/compositor-drm.h		\
+	$(INPUT_BACKEND_SOURCES)		\
+	shared/helpers.h			\
+	shared/timespec-util.h			\
+	libweston/libbacklight.c		\
+	libweston/libbacklight.h
+
+if ENABLE_DISPLAY_CAPTURE
+st_backend_la_SOURCES += protocol/capture-protocol.c
+
+BUILT_SOURCES +=				\
+	protocol/capture-protocol.c		\
+	protocol/capture-server-protocol.h
+
+EXTRA_DIST +=					\
+	protocol/capture.xml
+endif
+
+if ENABLE_VAAPI_RECORDER
+st_backend_la_SOURCES += libweston/vaapi-recorder.c libweston/vaapi-recorder.h
+st_backend_la_LIBADD += $(LIBVA_LIBS)
+st_backend_la_CFLAGS += $(LIBVA_CFLAGS)
+endif
+endif
+
 if ENABLE_WAYLAND_COMPOSITOR
 libweston_module_LTLIBRARIES += wayland-backend.la
 wayland_backend_la_LDFLAGS = -module -avoid-version
@@ -499,6 +548,7 @@ endif
 demo_clients =					\
 	weston-flower				\
 	weston-image				\
+	weston-slideshow			\
 	weston-cliptest				\
 	weston-dnd				\
 	weston-smoke				\
@@ -570,7 +620,7 @@ weston_multi_resource_LDADD = $(SIMPLE_CLIENT_LIBS) libshared.la $(CLOCK_GETTIME
 endif
 
 if BUILD_SIMPLE_EGL_CLIENTS
-demo_clients += weston-simple-egl
+demo_clients += weston-simple-egl weston-simple-egl-cube
 weston_simple_egl_SOURCES = clients/simple-egl.c
 nodist_weston_simple_egl_SOURCES =		\
 	protocol/xdg-shell-unstable-v6-protocol.c		\
@@ -579,6 +629,14 @@ nodist_weston_simple_egl_SOURCES =		\
 	protocol/ivi-application-client-protocol.h
 weston_simple_egl_CFLAGS = $(AM_CFLAGS) $(SIMPLE_EGL_CLIENT_CFLAGS)
 weston_simple_egl_LDADD = $(SIMPLE_EGL_CLIENT_LIBS) -lm
+weston_simple_egl_cube_SOURCES = clients/simple-egl-cube.c
+nodist_weston_simple_egl_cube_SOURCES =		\
+	protocol/xdg-shell-unstable-v6-protocol.c		\
+	protocol/xdg-shell-unstable-v6-client-protocol.h	\
+	clients/esTransform.c				\
+	clients/esUtil.h
+weston_simple_eg_cube_CFLAGS = $(AM_CFLAGS) $(SIMPLE_EGL_CLIENT_CFLAGS)
+weston_simple_egl_cube_LDADD = $(SIMPLE_EGL_CLIENT_LIBS) -lm
 endif
 
 if BUILD_SIMPLE_DMABUF_INTEL_CLIENT
@@ -653,6 +711,18 @@ nodist_weston_screenshooter_SOURCES =			\
 weston_screenshooter_LDADD = $(CLIENT_LIBS) libshared.la
 weston_screenshooter_CFLAGS = $(AM_CFLAGS) $(CLIENT_CFLAGS)
 
+if ENABLE_DISPLAY_CAPTURE
+demo_clients += weston-simple-capture
+nodist_weston_simple_capture_SOURCES =			\
+	protocol/capture-protocol.c		\
+	protocol/capture-client-protocol.h
+weston_simple_capture_SOURCES = clients/simple-capture.c
+weston_simple_capture_CFLAGS = $(AM_CFLAGS) $(SIMPLE_CLIENT_CFLAGS)
+weston_simple_capture_LDADD = $(SIMPLE_CLIENT_LIBS)
+
+BUILT_SOURCES += protocol/capture-client-protocol.h
+endif
+
 weston_terminal_SOURCES = 				\
 	clients/terminal.c				\
 	shared/helpers.h
@@ -663,6 +733,10 @@ weston_image_SOURCES = clients/image.c
 weston_image_LDADD = libtoytoolkit.la
 weston_image_CFLAGS = $(AM_CFLAGS) $(CLIENT_CFLAGS)
 
+weston_slideshow_SOURCES = clients/slideshow.c
+weston_slideshow_LDADD = libtoytoolkit.la
+weston_slideshow_CFLAGS = $(AM_CFLAGS) $(CLIENT_CFLAGS)
+
 weston_cliptest_SOURCES =				\
 	clients/cliptest.c				\
 	libweston/vertex-clipping.c			\
diff --git a/compositor/main.c b/compositor/main.c
index bbdfe87..fe22f01 100644
--- a/compositor/main.c
+++ b/compositor/main.c
@@ -63,11 +63,21 @@
 #include "compositor-fbdev.h"
 #include "compositor-x11.h"
 #include "compositor-wayland.h"
+#include "windowed-output-api.h"
 
 #define WINDOW_TITLE "Weston Compositor"
 
+struct wet_output_config {
+	int width;
+	int height;
+	int32_t scale;
+	uint32_t transform;
+};
+
 struct wet_compositor {
 	struct weston_config *config;
+	struct wet_output_config *parsed_options;
+	struct wl_listener pending_output_listener;
 };
 
 static FILE *weston_logfile = NULL;
@@ -425,6 +435,39 @@ to_wet_compositor(struct weston_compositor *compositor)
 	return weston_compositor_get_user_data(compositor);
 }
 
+static void
+wet_set_pending_output_handler(struct weston_compositor *ec,
+			       wl_notify_func_t handler)
+{
+	struct wet_compositor *compositor = to_wet_compositor(ec);
+
+	compositor->pending_output_listener.notify = handler;
+	wl_signal_add(&ec->output_pending_signal, &compositor->pending_output_listener);
+}
+
+static struct wet_output_config *
+wet_init_parsed_options(struct weston_compositor *ec)
+{
+	struct wet_compositor *compositor = to_wet_compositor(ec);
+	struct wet_output_config *config;
+
+	config = zalloc(sizeof *config);
+
+	if (!config) {
+		perror("out of memory");
+		return NULL;
+	}
+
+	config->width = 0;
+	config->height = 0;
+	config->scale = 0;
+	config->transform = UINT32_MAX;
+
+	compositor->parsed_options = config;
+
+	return config;
+}
+
 WL_EXPORT struct weston_config *
 wet_get_config(struct weston_compositor *ec)
 {
@@ -940,46 +983,108 @@ handle_exit(struct weston_compositor *c)
 	wl_display_terminate(c->wl_display);
 }
 
-static enum weston_drm_backend_output_mode
-drm_configure_output(struct weston_compositor *c,
-		     bool use_current_mode,
-		     const char *name,
-		     struct weston_drm_backend_output_config *config)
+static void
+wet_output_set_scale(struct weston_output *output,
+		     struct weston_config_section *section,
+		     int32_t default_scale,
+		     int32_t parsed_scale)
 {
-	struct weston_config *wc = wet_get_config(c);
-	struct weston_config_section *section;
-	char *s;
-	int scale;
-	enum weston_drm_backend_output_mode mode =
-		WESTON_DRM_BACKEND_OUTPUT_PREFERRED;
+	int32_t scale = default_scale;
 
-	section = weston_config_get_section(wc, "output", "name", name);
-	weston_config_section_get_string(section, "mode", &s, "preferred");
-	if (strcmp(s, "off") == 0) {
-		free(s);
-		return WESTON_DRM_BACKEND_OUTPUT_OFF;
+	if (section)
+		weston_config_section_get_int(section, "scale", &scale, default_scale);
+
+	if (parsed_scale)
+		scale = parsed_scale;
+
+	weston_output_set_scale(output, scale);
+}
+
+/* UINT32_MAX is treated as invalid because 0 is a valid
+ * enumeration value and the parameter is unsigned
+ */
+static void
+wet_output_set_transform(struct weston_output *output,
+			 struct weston_config_section *section,
+			 uint32_t default_transform,
+			 uint32_t parsed_transform)
+{
+	char *t;
+	uint32_t transform = default_transform;
+
+	if (section) {
+		weston_config_section_get_string(section,
+						 "transform", &t, "normal");
+
+		if (weston_parse_transform(t, &transform) < 0) {
+			weston_log("Invalid transform \"%s\" for output %s\n",
+				   t, output->name);
+			transform = default_transform;
+		}
+		free(t);
 	}
 
-	if (use_current_mode || strcmp(s, "current") == 0) {
-		mode = WESTON_DRM_BACKEND_OUTPUT_CURRENT;
-	} else if (strcmp(s, "preferred") != 0) {
-		config->modeline = s;
-		s = NULL;
+	if (parsed_transform != UINT32_MAX)
+		transform = parsed_transform;
+
+	weston_output_set_transform(output, transform);
+}
+
+static int
+wet_configure_windowed_output_from_config(struct weston_output *output,
+					  struct wet_output_config *defaults)
+{
+	const struct weston_windowed_output_api *api =
+		weston_windowed_output_get_api(output->compositor);
+
+	struct weston_config *wc = wet_get_config(output->compositor);
+	struct weston_config_section *section = NULL;
+	struct wet_compositor *compositor = to_wet_compositor(output->compositor);
+	struct wet_output_config *parsed_options = compositor->parsed_options;
+	int width = defaults->width;
+	int height = defaults->height;
+
+	assert(parsed_options);
+
+	if (!api) {
+		weston_log("Cannot use weston_windowed_output_api.\n");
+		return -1;
 	}
-	free(s);
 
-	weston_config_section_get_int(section, "scale", &scale, 1);
-	config->base.scale = scale >= 1 ? scale : 1;
-	weston_config_section_get_string(section, "transform", &s, "normal");
-	if (weston_parse_transform(s, &config->base.transform) < 0)
-		weston_log("Invalid transform \"%s\" for output %s\n",
-			   s, name);
-	free(s);
+	section = weston_config_get_section(wc, "output", "name", output->name);
 
-	weston_config_section_get_string(section,
-					 "gbm-format", &config->gbm_format, NULL);
-	weston_config_section_get_string(section, "seat", &config->seat, "");
-	return mode;
+	if (section) {
+		char *mode;
+
+		weston_config_section_get_string(section, "mode", &mode, NULL);
+		if (!mode || sscanf(mode, "%dx%d", &width,
+				    &height) != 2) {
+			weston_log("Invalid mode for output %s. Using defaults.\n",
+				   output->name);
+			width = defaults->width;
+			height = defaults->height;
+		}
+		free(mode);
+	}
+
+	if (parsed_options->width)
+		width = parsed_options->width;
+
+	if (parsed_options->height)
+		height = parsed_options->height;
+
+	wet_output_set_scale(output, section, defaults->scale, parsed_options->scale);
+	wet_output_set_transform(output, section, defaults->transform, parsed_options->transform);
+
+	if (api->output_set_size(output, width, height) < 0) {
+		weston_log("Cannot configure output \"%s\" using weston_windowed_output_api.\n",
+			   output->name);
+		return -1;
+	}
+
+	weston_output_enable(output);
+
+	return 0;
 }
 
 static void
@@ -1006,6 +1111,65 @@ configure_input_device(struct weston_compositor *compositor,
 	}
 }
 
+static void
+drm_backend_output_configure(struct wl_listener *listener, void *data)
+{
+	struct weston_output *output = data;
+	struct weston_config *wc = wet_get_config(output->compositor);
+	struct weston_config_section *section;
+	const struct weston_drm_output_api *api = weston_drm_output_get_api(output->compositor);
+	enum weston_drm_backend_output_mode mode =
+		WESTON_DRM_BACKEND_OUTPUT_PREFERRED;
+
+	char *s;
+	char *modeline = NULL;
+	char *gbm_format = NULL;
+	char *seat = NULL;
+
+	if (!api) {
+		weston_log("Cannot use weston_drm_output_api.\n");
+		return;
+	}
+
+	section = weston_config_get_section(wc, "output", "name", output->name);
+	weston_config_section_get_string(section, "mode", &s, "preferred");
+
+	if (strcmp(s, "off") == 0) {
+		weston_output_disable(output);
+		free(s);
+		return;
+	} else if (strcmp(s, "current") == 0) {
+		mode = WESTON_DRM_BACKEND_OUTPUT_CURRENT;
+	} else if (strcmp(s, "preferred") != 0) {
+		modeline = s;
+		s = NULL;
+	}
+	free(s);
+
+	if (api->set_mode(output, mode, modeline) < 0) {
+		weston_log("Cannot configure an output using weston_drm_output_api.\n");
+		free(modeline);
+		return;
+	}
+	free(modeline);
+
+	wet_output_set_scale(output, section, 1, 0);
+	wet_output_set_transform(output, section, WL_OUTPUT_TRANSFORM_NORMAL, UINT32_MAX);
+
+	weston_config_section_get_string(section,
+					 "gbm-format", &gbm_format, NULL);
+
+	api->set_gbm_format(output, gbm_format);
+	free(gbm_format);
+
+	weston_config_section_get_string(section, "seat", &seat, "");
+
+	api->set_seat(output, seat);
+	free(seat);
+
+	weston_output_enable(output);
+}
+
 static int
 load_drm_backend(struct weston_compositor *c,
 		 int *argc, char **argv, struct weston_config *wc)
@@ -1031,12 +1195,13 @@ load_drm_backend(struct weston_compositor *c,
 
 	config.base.struct_version = WESTON_DRM_BACKEND_CONFIG_VERSION;
 	config.base.struct_size = sizeof(struct weston_drm_backend_config);
-	config.configure_output = drm_configure_output;
 	config.configure_device = configure_input_device;
 
 	ret = weston_compositor_load_backend(c, WESTON_BACKEND_DRM,
 					     &config.base);
 
+	wet_set_pending_output_handler(c, drm_backend_output_configure);
+
 	free(config.gbm_format);
 	free(config.seat_id);
 
@@ -1044,30 +1209,87 @@ load_drm_backend(struct weston_compositor *c,
 }
 
 static int
+load_st_backend(struct weston_compositor *c,
+		 int *argc, char **argv, struct weston_config *wc)
+{
+	struct weston_drm_backend_config config = {{ 0, }};
+	struct weston_config_section *section;
+	int ret = 0;
+
+	const struct weston_option options[] = {
+		{ WESTON_OPTION_INTEGER, "connector", 0, &config.connector },
+		{ WESTON_OPTION_STRING, "seat", 0, &config.seat_id },
+		{ WESTON_OPTION_INTEGER, "tty", 0, &config.tty },
+		{ WESTON_OPTION_BOOLEAN, "current-mode", 0, &config.use_current_mode },
+		{ WESTON_OPTION_BOOLEAN, "use-pixman", 0, &config.use_pixman },
+	};
+
+	parse_options(options, ARRAY_LENGTH(options), argc, argv);
+
+	section = weston_config_get_section(wc, "core", NULL, NULL);
+	weston_config_section_get_string(section,
+					 "gbm-format", &config.gbm_format,
+					 NULL);
+
+	config.base.struct_version = WESTON_DRM_BACKEND_CONFIG_VERSION;
+	config.base.struct_size = sizeof(struct weston_drm_backend_config);
+	config.configure_device = configure_input_device;
+
+	ret = weston_compositor_load_backend(c, WESTON_BACKEND_ST,
+					     &config.base);
+
+	wet_set_pending_output_handler(c, drm_backend_output_configure);
+
+	free(config.gbm_format);
+	free(config.seat_id);
+
+	return ret;
+}
+
+static void
+headless_backend_output_configure(struct wl_listener *listener, void *data)
+{
+	struct weston_output *output = data;
+	struct wet_output_config defaults = {
+		.width = 1024,
+		.height = 640,
+		.scale = 1,
+		.transform = WL_OUTPUT_TRANSFORM_NORMAL
+	};
+
+	if (wet_configure_windowed_output_from_config(output, &defaults) < 0)
+		weston_log("Cannot configure output \"%s\".\n", output->name);
+}
+
+static int
 load_headless_backend(struct weston_compositor *c,
 		      int *argc, char **argv, struct weston_config *wc)
 {
+	const struct weston_windowed_output_api *api;
 	struct weston_headless_backend_config config = {{ 0, }};
+	int no_outputs = 0;
 	int ret = 0;
 	char *transform = NULL;
 
-	config.width = 1024;
-	config.height = 640;
+	struct wet_output_config *parsed_options = wet_init_parsed_options(c);
+	if (!parsed_options)
+		return -1;
 
 	const struct weston_option options[] = {
-		{ WESTON_OPTION_INTEGER, "width", 0, &config.width },
-		{ WESTON_OPTION_INTEGER, "height", 0, &config.height },
+		{ WESTON_OPTION_INTEGER, "width", 0, &parsed_options->width },
+		{ WESTON_OPTION_INTEGER, "height", 0, &parsed_options->height },
 		{ WESTON_OPTION_BOOLEAN, "use-pixman", 0, &config.use_pixman },
 		{ WESTON_OPTION_STRING, "transform", 0, &transform },
-		{ WESTON_OPTION_BOOLEAN, "no-outputs", 0, &config.no_outputs },
+		{ WESTON_OPTION_BOOLEAN, "no-outputs", 0, &no_outputs },
 	};
 
 	parse_options(options, ARRAY_LENGTH(options), argc, argv);
 
-	config.transform = WL_OUTPUT_TRANSFORM_NORMAL;
 	if (transform) {
-		if (weston_parse_transform(transform, &config.transform) < 0)
+		if (weston_parse_transform(transform, &parsed_options->transform) < 0) {
 			weston_log("Invalid transform \"%s\"\n", transform);
+			parsed_options->transform = UINT32_MAX;
+		}
 		free(transform);
 	}
 
@@ -1078,7 +1300,59 @@ load_headless_backend(struct weston_compositor *c,
 	ret = weston_compositor_load_backend(c, WESTON_BACKEND_HEADLESS,
 					     &config.base);
 
-	return ret;
+	if (ret < 0)
+		return ret;
+
+	wet_set_pending_output_handler(c, headless_backend_output_configure);
+
+	if (!no_outputs) {
+		api = weston_windowed_output_get_api(c);
+
+		if (!api) {
+			weston_log("Cannot use weston_windowed_output_api.\n");
+			return -1;
+		}
+
+		if (api->output_create(c, "headless") < 0)
+			return -1;
+	}
+
+	return 0;
+}
+
+static void
+rdp_backend_output_configure(struct wl_listener *listener, void *data)
+{
+	struct weston_output *output = data;
+	struct wet_compositor *compositor = to_wet_compositor(output->compositor);
+	struct wet_output_config *parsed_options = compositor->parsed_options;
+	const struct weston_rdp_output_api *api = weston_rdp_output_get_api(output->compositor);
+	int width = 640;
+	int height = 480;
+
+	assert(parsed_options);
+
+	if (!api) {
+		weston_log("Cannot use weston_rdp_output_api.\n");
+		return;
+	}
+
+	if (parsed_options->width)
+		width = parsed_options->width;
+
+	if (parsed_options->height)
+		height = parsed_options->height;
+
+	weston_output_set_scale(output, 1);
+	weston_output_set_transform(output, WL_OUTPUT_TRANSFORM_NORMAL);
+
+	if (api->output_set_size(output, width, height) < 0) {
+		weston_log("Cannot configure output \"%s\" using weston_rdp_output_api.\n",
+			   output->name);
+		return;
+	}
+
+	weston_output_enable(output);
 }
 
 static void
@@ -1087,8 +1361,6 @@ weston_rdp_backend_config_init(struct weston_rdp_backend_config *config)
 	config->base.struct_version = WESTON_RDP_BACKEND_CONFIG_VERSION;
 	config->base.struct_size = sizeof(struct weston_rdp_backend_config);
 
-	config->width = 640;
-	config->height = 480;
 	config->bind_address = NULL;
 	config->port = 3389;
 	config->rdp_key = NULL;
@@ -1105,12 +1377,16 @@ load_rdp_backend(struct weston_compositor *c,
 	struct weston_rdp_backend_config config  = {{ 0, }};
 	int ret = 0;
 
+	struct wet_output_config *parsed_options = wet_init_parsed_options(c);
+	if (!parsed_options)
+		return -1;
+
 	weston_rdp_backend_config_init(&config);
 
 	const struct weston_option rdp_options[] = {
 		{ WESTON_OPTION_BOOLEAN, "env-socket", 0, &config.env_socket },
-		{ WESTON_OPTION_INTEGER, "width", 0, &config.width },
-		{ WESTON_OPTION_INTEGER, "height", 0, &config.height },
+		{ WESTON_OPTION_INTEGER, "width", 0, &parsed_options->width },
+		{ WESTON_OPTION_INTEGER, "height", 0, &parsed_options->height },
 		{ WESTON_OPTION_STRING,  "address", 0, &config.bind_address },
 		{ WESTON_OPTION_INTEGER, "port", 0, &config.port },
 		{ WESTON_OPTION_BOOLEAN, "no-clients-resize", 0, &config.no_clients_resize },
@@ -1124,20 +1400,40 @@ load_rdp_backend(struct weston_compositor *c,
 	ret = weston_compositor_load_backend(c, WESTON_BACKEND_RDP,
 					     &config.base);
 
+	if (ret < 0)
+		goto out;
+
+	wet_set_pending_output_handler(c, rdp_backend_output_configure);
+
+out:
 	free(config.bind_address);
 	free(config.rdp_key);
 	free(config.server_cert);
 	free(config.server_key);
+
 	return ret;
 }
 
+static void
+fbdev_backend_output_configure(struct wl_listener *listener, void *data)
+{
+	struct weston_output *output = data;
+	struct weston_config *wc = wet_get_config(output->compositor);
+	struct weston_config_section *section;
+
+	section = weston_config_get_section(wc, "output", "name", "fbdev");
+
+	wet_output_set_transform(output, section, WL_OUTPUT_TRANSFORM_NORMAL, UINT32_MAX);
+	weston_output_set_scale(output, 1);
+
+	weston_output_enable(output);
+}
+
 static int
 load_fbdev_backend(struct weston_compositor *c,
 		      int *argc, char **argv, struct weston_config *wc)
 {
 	struct weston_fbdev_backend_config config = {{ 0, }};
-	struct weston_config_section *section;
-	char *s = NULL;
 	int ret = 0;
 
 	const struct weston_option fbdev_options[] = {
@@ -1150,12 +1446,6 @@ load_fbdev_backend(struct weston_compositor *c,
 	if (!config.device)
 		config.device = strdup("/dev/fb0");
 
-	section = weston_config_get_section(wc, "output", "name", "fbdev");
-	weston_config_section_get_string(section, "transform", &s, "normal");
-	if (weston_parse_transform(s, &config.output_transform) < 0)
-		weston_log("Invalid transform \"%s\" for output fbdev\n", s);
-	free(s);
-
 	config.base.struct_version = WESTON_FBDEV_BACKEND_CONFIG_VERSION;
 	config.base.struct_size = sizeof(struct weston_fbdev_backend_config);
 	config.configure_device = configure_input_device;
@@ -1164,53 +1454,53 @@ load_fbdev_backend(struct weston_compositor *c,
 	ret = weston_compositor_load_backend(c, WESTON_BACKEND_FBDEV,
 					     &config.base);
 
-	free(config.device);
+	if (ret < 0)
+		goto out;
 
+	wet_set_pending_output_handler(c, fbdev_backend_output_configure);
+
+out:
+	free(config.device);
 	return ret;
 }
 
-static int
-weston_x11_backend_config_append_output_config(struct weston_x11_backend_config *config,
-					       struct weston_x11_backend_output_config *output_config) {
-	struct weston_x11_backend_output_config *new_outputs;
-
-	new_outputs = realloc(config->outputs, (config->num_outputs+1) *
-			      sizeof(struct weston_x11_backend_output_config));
-	if (new_outputs == NULL)
-		return -1;
-
-	config->outputs = new_outputs;
-	config->outputs[config->num_outputs].width = output_config->width;
-	config->outputs[config->num_outputs].height = output_config->height;
-	config->outputs[config->num_outputs].transform = output_config->transform;
-	config->outputs[config->num_outputs].scale = output_config->scale;
-	config->outputs[config->num_outputs].name = strdup(output_config->name);
-	config->num_outputs++;
+static void
+x11_backend_output_configure(struct wl_listener *listener, void *data)
+{
+	struct weston_output *output = data;
+	struct wet_output_config defaults = {
+		.width = 1024,
+		.height = 600,
+		.scale = 1,
+		.transform = WL_OUTPUT_TRANSFORM_NORMAL
+	};
 
-	return 0;
+	if (wet_configure_windowed_output_from_config(output, &defaults) < 0)
+		weston_log("Cannot configure output \"%s\".\n", output->name);
 }
 
 static int
 load_x11_backend(struct weston_compositor *c,
 		 int *argc, char **argv, struct weston_config *wc)
 {
-	struct weston_x11_backend_output_config default_output;
+	char *default_output;
+	const struct weston_windowed_output_api *api;
 	struct weston_x11_backend_config config = {{ 0, }};
 	struct weston_config_section *section;
 	int ret = 0;
-	int option_width = 0;
-	int option_height = 0;
-	int option_scale = 0;
 	int option_count = 1;
 	int output_count = 0;
 	char const *section_name;
 	int i;
-	uint32_t j;
+
+	struct wet_output_config *parsed_options = wet_init_parsed_options(c);
+	if (!parsed_options)
+		return -1;
 
 	const struct weston_option options[] = {
-	       { WESTON_OPTION_INTEGER, "width", 0, &option_width },
-	       { WESTON_OPTION_INTEGER, "height", 0, &option_height },
-	       { WESTON_OPTION_INTEGER, "scale", 0, &option_scale },
+	       { WESTON_OPTION_INTEGER, "width", 0, &parsed_options->width },
+	       { WESTON_OPTION_INTEGER, "height", 0, &parsed_options->height },
+	       { WESTON_OPTION_INTEGER, "scale", 0, &parsed_options->scale },
 	       { WESTON_OPTION_BOOLEAN, "fullscreen", 'f', &config.fullscreen },
 	       { WESTON_OPTION_INTEGER, "output-count", 0, &option_count },
 	       { WESTON_OPTION_BOOLEAN, "no-input", 0, &config.no_input },
@@ -1219,312 +1509,203 @@ load_x11_backend(struct weston_compositor *c,
 
 	parse_options(options, ARRAY_LENGTH(options), argc, argv);
 
+	config.base.struct_version = WESTON_X11_BACKEND_CONFIG_VERSION;
+	config.base.struct_size = sizeof(struct weston_x11_backend_config);
+
+	/* load the actual backend and configure it */
+	ret = weston_compositor_load_backend(c, WESTON_BACKEND_X11,
+					     &config.base);
+
+	if (ret < 0)
+		return ret;
+
+	wet_set_pending_output_handler(c, x11_backend_output_configure);
+
+	api = weston_windowed_output_get_api(c);
+
+	if (!api) {
+		weston_log("Cannot use weston_windowed_output_api.\n");
+		return -1;
+	}
+
 	section = NULL;
 	while (weston_config_next_section(wc, &section, &section_name)) {
-		struct weston_x11_backend_output_config current_output = { 0, };
-		char *t;
-		char *mode;
+		char *output_name;
+
+		if (output_count >= option_count)
+			break;
 
 		if (strcmp(section_name, "output") != 0) {
 			continue;
 		}
 
-		weston_config_section_get_string(section, "name", &current_output.name, NULL);
-		if (current_output.name == NULL || current_output.name[0] != 'X') {
-			free(current_output.name);
+		weston_config_section_get_string(section, "name", &output_name, NULL);
+		if (output_name == NULL || output_name[0] != 'X') {
+			free(output_name);
 			continue;
 		}
 
-		weston_config_section_get_string(section, "mode", &mode, "1024x600");
-		if (sscanf(mode, "%dx%d", &current_output.width,
-			   &current_output.height) != 2) {
-			weston_log("Invalid mode \"%s\" for output %s\n",
-				   mode, current_output.name);
-			current_output.width = 1024;
-			current_output.height = 600;
-		}
-		free(mode);
-		if (current_output.width < 1)
-			current_output.width = 1024;
-		if (current_output.height < 1)
-			current_output.height = 600;
-		if (option_width)
-			current_output.width = option_width;
-		if (option_height)
-			current_output.height = option_height;
-
-		weston_config_section_get_int(section, "scale", &current_output.scale, 1);
-		if (option_scale)
-			current_output.scale = option_scale;
-
-		weston_config_section_get_string(section,
-						 "transform", &t, "normal");
-		if (weston_parse_transform(t, &current_output.transform) < 0)
-			weston_log("Invalid transform \"%s\" for output %s\n",
-				   t, current_output.name);
-		free(t);
-
-		if (weston_x11_backend_config_append_output_config(&config, &current_output) < 0) {
-			ret = -1;
-			goto out;
+		if (api->output_create(c, output_name) < 0) {
+			free(output_name);
+			return -1;
 		}
+		free(output_name);
 
 		output_count++;
-		if (output_count >= option_count)
-			break;
 	}
 
-	default_output.name = NULL;
-	default_output.width = option_width ? option_width : 1024;
-	default_output.height = option_height ? option_height : 600;
-	default_output.scale = option_scale ? option_scale : 1;
-	default_output.transform = WL_OUTPUT_TRANSFORM_NORMAL;
+	default_output = NULL;
 
 	for (i = output_count; i < option_count; i++) {
-		if (asprintf(&default_output.name, "screen%d", i) < 0) {
-			ret = -1;
-			goto out;
+		if (asprintf(&default_output, "screen%d", i) < 0) {
+			return -1;
 		}
 
-		if (weston_x11_backend_config_append_output_config(&config, &default_output) < 0) {
-			ret = -1;
-			free(default_output.name);
-			goto out;
+		if (api->output_create(c, default_output) < 0) {
+			free(default_output);
+			return -1;
 		}
-		free(default_output.name);
+		free(default_output);
 	}
 
-	config.base.struct_version = WESTON_X11_BACKEND_CONFIG_VERSION;
-	config.base.struct_size = sizeof(struct weston_x11_backend_config);
-
-	/* load the actual backend and configure it */
-	ret = weston_compositor_load_backend(c, WESTON_BACKEND_X11,
-					     &config.base);
-
-out:
-	for (j = 0; j < config.num_outputs; ++j)
-		free(config.outputs[j].name);
-	free(config.outputs);
-
-	return ret;
+	return 0;
 }
 
 static void
-weston_wayland_output_config_init(struct weston_wayland_backend_output_config *output_config,
-				  struct weston_config_section *config_section,
-				  int option_width, int option_height,
-				  int option_scale)
+wayland_backend_output_configure_hotplug(struct wl_listener *listener, void *data)
 {
-	char *mode, *t, *str;
-	unsigned int slen;
-
-	weston_config_section_get_string(config_section, "name", &output_config->name,
-					 NULL);
-	if (output_config->name) {
-		slen = strlen(output_config->name);
-		slen += strlen(WINDOW_TITLE " - ");
-		str = malloc(slen + 1);
-		if (str)
-			snprintf(str, slen + 1, WINDOW_TITLE " - %s",
-				 output_config->name);
-		free(output_config->name);
-		output_config->name = str;
-	}
-	if (!output_config->name)
-		output_config->name = strdup(WINDOW_TITLE);
-
-	weston_config_section_get_string(config_section,
-					 "mode", &mode, "1024x600");
-	if (sscanf(mode, "%dx%d", &output_config->width, &output_config->height) != 2) {
-		weston_log("Invalid mode \"%s\" for output %s\n",
-			   mode, output_config->name);
-		output_config->width = 1024;
-		output_config->height = 640;
-	}
-	free(mode);
-
-	if (option_width)
-		output_config->width = option_width;
-	if (option_height)
-		output_config->height = option_height;
-
-	weston_config_section_get_int(config_section, "scale", &output_config->scale, 1);
-
-	if (option_scale)
-		output_config->scale = option_scale;
-
-	weston_config_section_get_string(config_section,
-					 "transform", &t, "normal");
-	if (weston_parse_transform(t, &output_config->transform) < 0)
-		weston_log("Invalid transform \"%s\" for output %s\n",
-			   t, output_config->name);
-	free(t);
+	struct weston_output *output = data;
 
+	/* This backend has all values hardcoded, so nothing can be configured here */
+	weston_output_enable(output);
 }
 
 static void
-weston_wayland_backend_config_release(struct weston_wayland_backend_config *config)
-{
-	int i;
-
-	for (i = 0; i < config->num_outputs; ++i) {
-		free(config->outputs[i].name);
-	}
-	free(config->cursor_theme);
-	free(config->display_name);
-	free(config->outputs);
-}
-
-/*
- * Append a new output struct at the end of new_config.outputs and return a
- * pointer to the newly allocated structure or NULL if fail. The allocated
- * structure is NOT cleared nor set to default values.
- */
-static struct weston_wayland_backend_output_config *
-weston_wayland_backend_config_add_new_output(struct weston_wayland_backend_config *config)
+wayland_backend_output_configure(struct wl_listener *listener, void *data)
 {
-	struct weston_wayland_backend_output_config *outputs;
-	const size_t element_size = sizeof(struct weston_wayland_backend_output_config);
+	struct weston_output *output = data;
+	struct wet_output_config defaults = {
+		.width = 1024,
+		.height = 640,
+		.scale = 1,
+		.transform = WL_OUTPUT_TRANSFORM_NORMAL
+	};
 
-	outputs = realloc(config->outputs,
-			  (config->num_outputs + 1) * element_size);
-	if (!outputs)
-		return NULL;
-	config->num_outputs += 1;
-	config->outputs = outputs;
-	return &(config->outputs[config->num_outputs - 1]);
+	if (wet_configure_windowed_output_from_config(output, &defaults) < 0)
+		weston_log("Cannot configure output \"%s\".\n", output->name);
 }
 
 static int
-load_wayland_backend_config(struct weston_compositor *compositor, int *argc,
-			    char *argv[], struct weston_config *wc,
-			    struct weston_wayland_backend_config *config)
+load_wayland_backend(struct weston_compositor *c,
+		     int *argc, char **argv, struct weston_config *wc)
 {
+	struct weston_wayland_backend_config config = {{ 0, }};
 	struct weston_config_section *section;
-	struct weston_wayland_backend_output_config *oc;
-	int count, width, height, scale;
+	const struct weston_windowed_output_api *api;
 	const char *section_name;
-	char *name;
+	char *output_name = NULL;
+	int count = 1;
+	int ret = 0;
+	int i;
+
+	struct wet_output_config *parsed_options = wet_init_parsed_options(c);
+	if (!parsed_options)
+		return -1;
+
+	config.cursor_size = 32;
+	config.cursor_theme = NULL;
+	config.display_name = NULL;
+	config.fullscreen = 0;
+	config.sprawl = 0;
+	config.use_pixman = 0;
 
 	const struct weston_option wayland_options[] = {
-		{ WESTON_OPTION_INTEGER, "width", 0, &width },
-		{ WESTON_OPTION_INTEGER, "height", 0, &height },
-		{ WESTON_OPTION_INTEGER, "scale", 0, &scale },
-		{ WESTON_OPTION_STRING, "display", 0, &config->display_name },
-		{ WESTON_OPTION_BOOLEAN, "use-pixman", 0, &config->use_pixman },
+		{ WESTON_OPTION_INTEGER, "width", 0, &parsed_options->width },
+		{ WESTON_OPTION_INTEGER, "height", 0, &parsed_options->height },
+		{ WESTON_OPTION_INTEGER, "scale", 0, &parsed_options->scale },
+		{ WESTON_OPTION_STRING, "display", 0, &config.display_name },
+		{ WESTON_OPTION_BOOLEAN, "use-pixman", 0, &config.use_pixman },
 		{ WESTON_OPTION_INTEGER, "output-count", 0, &count },
-		{ WESTON_OPTION_BOOLEAN, "fullscreen", 0, &config->fullscreen },
-		{ WESTON_OPTION_BOOLEAN, "sprawl", 0, &config->sprawl },
+		{ WESTON_OPTION_BOOLEAN, "fullscreen", 0, &config.fullscreen },
+		{ WESTON_OPTION_BOOLEAN, "sprawl", 0, &config.sprawl },
 	};
 
-	width = 0;
-	height = 0;
-	scale = 0;
-	config->display_name = NULL;
-	config->use_pixman = 0;
-	count = 1;
-	config->fullscreen = 0;
-	config->sprawl = 0;
-	parse_options(wayland_options,
-		      ARRAY_LENGTH(wayland_options), argc, argv);
-
-	config->cursor_size = 32;
-	config->cursor_theme = NULL;
-	config->base.struct_size = sizeof(struct weston_wayland_backend_config);
-	config->base.struct_version = WESTON_WAYLAND_BACKEND_CONFIG_VERSION;
+	parse_options(wayland_options, ARRAY_LENGTH(wayland_options), argc, argv);
 
 	section = weston_config_get_section(wc, "shell", NULL, NULL);
 	weston_config_section_get_string(section, "cursor-theme",
-					 &config->cursor_theme, NULL);
+					 &config.cursor_theme, NULL);
 	weston_config_section_get_int(section, "cursor-size",
-				      &config->cursor_size, 32);
+				      &config.cursor_size, 32);
 
-	if (config->sprawl) {
-		/* do nothing, everything is already set */
-		return 0;
-	}
+	config.base.struct_size = sizeof(struct weston_wayland_backend_config);
+	config.base.struct_version = WESTON_WAYLAND_BACKEND_CONFIG_VERSION;
 
-	if (config->fullscreen) {
-		oc = weston_wayland_backend_config_add_new_output(config);
-		if (!oc)
-			return -1;
+	/* load the actual wayland backend and configure it */
+	ret = weston_compositor_load_backend(c, WESTON_BACKEND_WAYLAND,
+					     &config.base);
+
+	free(config.cursor_theme);
+	free(config.display_name);
 
-		oc->width = width;
-		oc->height = height;
-		oc->name = NULL;
-		oc->transform = WL_OUTPUT_TRANSFORM_NORMAL;
-		oc->scale = 1;
+	if (ret < 0)
+		return ret;
+
+	api = weston_windowed_output_get_api(c);
+
+	if (api == NULL) {
+		/* We will just assume if load_backend() finished cleanly and
+		 * windowed_output_api is not present that wayland backend is
+		 * started with --sprawl or runs on fullscreen-shell. */
+		wet_set_pending_output_handler(c, wayland_backend_output_configure_hotplug);
 
 		return 0;
 	}
 
+	wet_set_pending_output_handler(c, wayland_backend_output_configure);
+
 	section = NULL;
 	while (weston_config_next_section(wc, &section, &section_name)) {
-		if (!section_name || strcmp(section_name, "output") != 0)
+		if (count == 0)
+			break;
+
+		if (strcmp(section_name, "output") != 0) {
 			continue;
-		weston_config_section_get_string(section, "name", &name, NULL);
-		if (name == NULL)
+		}
+
+		weston_config_section_get_string(section, "name", &output_name, NULL);
+
+		if (output_name == NULL)
 			continue;
 
-		if (name[0] != 'W' || name[1] != 'L') {
-			free(name);
+		if (output_name[0] != 'W' || output_name[1] != 'L') {
+			free(output_name);
 			continue;
 		}
-		free(name);
 
-		oc = weston_wayland_backend_config_add_new_output(config);
-		if (!oc)
+		if (api->output_create(c, output_name) < 0) {
+			free(output_name);
 			return -1;
+		}
+		free(output_name);
 
-		weston_wayland_output_config_init(oc, section, width,
-						  height, scale);
 		--count;
 	}
 
-	if (!width)
-		width = 1024;
-	if (!height)
-		height = 640;
-	if (!scale)
-		scale = 1;
-
-	while (count > 0) {
-		oc = weston_wayland_backend_config_add_new_output(config);
-		if (!oc)
+	for (i = 0; i < count; i++) {
+		if (asprintf(&output_name, "wayland%d", i) < 0)
 			return -1;
 
-		oc->width = width;
-		oc->height = height;
-		oc->name = NULL;
-		oc->transform = WL_OUTPUT_TRANSFORM_NORMAL;
-		oc->scale = scale;
-
-		--count;
+		if (api->output_create(c, output_name) < 0) {
+			free(output_name);
+			return -1;
+		}
+		free(output_name);
 	}
 
 	return 0;
 }
 
-static int
-load_wayland_backend(struct weston_compositor *c,
-		     int *argc, char **argv, struct weston_config *wc)
-{
-	struct weston_wayland_backend_config config = {{ 0, }};
-	int ret = 0;
-
-	ret = load_wayland_backend_config(c, argc, argv, wc, &config);
-	if (ret < 0) {
-		weston_wayland_backend_config_release(&config);
-		return ret;
-	}
-
-	/* load the actual wayland backend and configure it */
-	ret = weston_compositor_load_backend(c, WESTON_BACKEND_WAYLAND,
-					     &config.base);
-	weston_wayland_backend_config_release(&config);
-	return ret;
-}
-
 
 static int
 load_backend(struct weston_compositor *compositor, const char *backend,
@@ -1538,6 +1719,8 @@ load_backend(struct weston_compositor *compositor, const char *backend,
 		return load_fbdev_backend(compositor, argc, argv, config);
 	else if (strstr(backend, "drm-backend.so"))
 		return load_drm_backend(compositor, argc, argv, config);
+	else if (strstr(backend, "st-backend.so"))
+		return load_st_backend(compositor, argc, argv, config);
 	else if (strstr(backend, "x11-backend.so"))
 		return load_x11_backend(compositor, argc, argv, config);
 	else if (strstr(backend, "wayland-backend.so"))
@@ -1660,6 +1843,7 @@ int main(int argc, char *argv[])
 	if (load_configuration(&config, noconfig, config_file) < 0)
 		goto out_signals;
 	user_data.config = config;
+	user_data.parsed_options = NULL;
 
 	section = weston_config_get_section(config, "core", NULL, NULL);
 
@@ -1688,6 +1872,8 @@ int main(int argc, char *argv[])
 		goto out;
 	}
 
+	weston_pending_output_coldplug(ec);
+
 	catch_signals();
 	segv_compositor = ec;
 
@@ -1771,6 +1957,9 @@ int main(int argc, char *argv[])
 	ret = ec->exit_code;
 
 out:
+	/* free(NULL) is valid, and it won't be NULL if it's used */
+	free(user_data.parsed_options);
+
 	weston_compositor_destroy(ec);
 
 out_signals:
diff --git a/configure.ac b/configure.ac
index a89c1e2..1a3e167 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,10 +1,10 @@
 m4_define([weston_major_version],  [1])
 m4_define([weston_minor_version],  [12])
-m4_define([weston_micro_version],  [0])
+m4_define([weston_micro_version],  [90])
 m4_define([weston_version],
           [weston_major_version.weston_minor_version.weston_micro_version])
-m4_define([libweston_major_version], [1])
-m4_define([libweston_minor_version], [12])
+m4_define([libweston_major_version], [2])
+m4_define([libweston_minor_version], [0])
 m4_define([libweston_patch_version], [0])
 
 AC_PREREQ([2.64])
@@ -225,6 +225,18 @@ if test x$enable_drm_compositor = xyes; then
 fi
 
 
+AC_ARG_ENABLE(st-compositor, [  --enable-st-compositor],,
+	      enable_st_compositor=yes)
+AM_CONDITIONAL(ENABLE_ST_COMPOSITOR, test x$enable_st_compositor = xyes)
+if test x$enable_st_compositor = xyes; then
+  AC_DEFINE([BUILD_ST_COMPOSITOR], [1], [Build the ST compositor])
+  PKG_CHECK_MODULES(ST_COMPOSITOR, [libudev >= 136 libdrm >= 2.4.30 gbm mtdev >= 1.1.0])
+  PKG_CHECK_MODULES(ST_COMPOSITOR_GBM, [gbm >= 10.2],
+		    [AC_DEFINE([HAVE_GBM_FD_IMPORT], 1, [gbm supports dmabuf import])],
+		    [AC_MSG_WARN([gbm does not support dmabuf import, will omit that capability])])
+fi
+
+
 PKG_CHECK_MODULES(LIBINPUT_BACKEND, [libinput >= 0.8.0])
 PKG_CHECK_MODULES(COMPOSITOR, [$COMPOSITOR_MODULES])
 
@@ -290,6 +302,18 @@ if test x$enable_screen_sharing = xyes; then
   fi
 fi
 
+AC_ARG_ENABLE([display-capture], [  --enable-display-capture],,
+              enable_display_capture=no)
+AM_CONDITIONAL([ENABLE_DISPLAY_CAPTURE],
+               [test x$enable_display_capture = xyes])
+if test "x$enable_display_capture" = "xyes"; then
+  if test "x$enable_st_compositor" = "xno"; then
+    AC_MSG_ERROR([Display capture requires compositor-st])
+  else
+    AC_DEFINE([ENABLE_DISPLAY_CAPTURE], [1], [Build with capture support])
+  fi
+fi
+
 AC_ARG_WITH(cairo,
 	    AS_HELP_STRING([--with-cairo=@<:@image|gl|glesv2@:>@]
 			   [Which Cairo renderer to use for the clients]),
@@ -448,7 +472,7 @@ AC_ARG_ENABLE(weston-launch, [  --enable-weston-launch],, enable_weston_launch=y
 AM_CONDITIONAL(BUILD_WESTON_LAUNCH, test x$enable_weston_launch == xyes)
 if test x$enable_weston_launch = xyes -a x$use_pam = xyes; then
   WESTON_SEARCH_LIBS([PAM], [pam], [pam_open_session], [have_pam=yes], [have_pam=no])
-  if test x$have_pam == xno; then
+  if test x$have_pam = xno; then
     AC_ERROR([PAM support is explicitly requested, but libpam couldn't be found])
   fi
   AC_DEFINE([HAVE_PAM], [1], [Define if PAM is available])
@@ -720,6 +744,7 @@ AC_MSG_RESULT([
 	RDP Compositor			${enable_rdp_compositor}
 	Screen Sharing			${enable_screen_sharing}
 	JUnit XML output		${enable_junit_xml}
+	Display Capture (ST)		${enable_display_capture}
 
 	Build Clients			${enable_clients}
 	Build EGL Clients		${have_cairo_egl}
diff --git a/libweston/compositor-drm.c b/libweston/compositor-drm.c
index 8319d7c..f61e3d9 100644
--- a/libweston/compositor-drm.c
+++ b/libweston/compositor-drm.c
@@ -52,6 +52,7 @@
 #include "shared/helpers.h"
 #include "shared/timespec-util.h"
 #include "gl-renderer.h"
+#include "weston-egl-ext.h"
 #include "pixman-renderer.h"
 #include "libbacklight.h"
 #include "libinput-seat.h"
@@ -122,16 +123,6 @@ struct drm_backend {
 	int32_t cursor_width;
 	int32_t cursor_height;
 
-        /** Callback used to configure the outputs.
-	 *
-         * This function will be called by the backend when a new DRM
-         * output needs to be configured.
-         */
-        enum weston_drm_backend_output_mode
-	(*configure_output)(struct weston_compositor *compositor,
-			    bool use_current_mode,
-			    const char *name,
-			    struct weston_drm_backend_output_config *output_config);
 	bool use_current_mode;
 };
 
@@ -161,7 +152,8 @@ struct drm_edid {
 };
 
 struct drm_output {
-	struct weston_output   base;
+	struct weston_output base;
+	drmModeConnector *connector;
 
 	uint32_t crtc_id;
 	int pipe;
@@ -176,6 +168,7 @@ struct drm_output {
 	int vblank_pending;
 	int page_flip_pending;
 	int destroy_pending;
+	int disable_pending;
 
 	struct gbm_surface *gbm_surface;
 	struct gbm_bo *gbm_cursor_bo[2];
@@ -681,7 +674,7 @@ drm_output_repaint(struct weston_output *output_base,
 	struct drm_mode *mode;
 	int ret = 0;
 
-	if (output->destroy_pending)
+	if (output->disable_pending || output->destroy_pending)
 		return -1;
 
 	if (!output->next)
@@ -787,7 +780,7 @@ drm_output_start_repaint_loop(struct weston_output *output_base)
 		.request.signal = 0,
 	};
 
-	if (output->destroy_pending)
+	if (output->disable_pending || output->destroy_pending)
 		return;
 
 	if (!output->current) {
@@ -877,7 +870,7 @@ vblank_handler(int fd, unsigned int frame, unsigned int sec, unsigned int usec,
 }
 
 static void
-drm_output_destroy(struct weston_output *output_base);
+drm_output_destroy(struct weston_output *base);
 
 static void
 page_flip_handler(int fd, unsigned int frame,
@@ -904,6 +897,8 @@ page_flip_handler(int fd, unsigned int frame,
 
 	if (output->destroy_pending)
 		drm_output_destroy(&output->base);
+	else if (output->disable_pending)
+		weston_output_disable(&output->base);
 	else if (!output->vblank_pending) {
 		ts.tv_sec = sec;
 		ts.tv_nsec = usec * 1000;
@@ -1344,51 +1339,6 @@ drm_assign_planes(struct weston_output *output_base)
 static void
 drm_output_fini_pixman(struct drm_output *output);
 
-static void
-drm_output_destroy(struct weston_output *output_base)
-{
-	struct drm_output *output = to_drm_output(output_base);
-	struct drm_backend *b = to_drm_backend(output->base.compositor);
-	drmModeCrtcPtr origcrtc = output->original_crtc;
-
-	if (output->page_flip_pending) {
-		output->destroy_pending = 1;
-		weston_log("destroy output while page flip pending\n");
-		return;
-	}
-
-	if (output->backlight)
-		backlight_destroy(output->backlight);
-
-	drmModeFreeProperty(output->dpms_prop);
-
-	/* Turn off hardware cursor */
-	drmModeSetCursor(b->drm.fd, output->crtc_id, 0, 0, 0);
-
-	/* Restore original CRTC state */
-	drmModeSetCrtc(b->drm.fd, origcrtc->crtc_id, origcrtc->buffer_id,
-		       origcrtc->x, origcrtc->y,
-		       &output->connector_id, 1, &origcrtc->mode);
-	drmModeFreeCrtc(origcrtc);
-
-	b->crtc_allocator &= ~(1 << output->crtc_id);
-	b->connector_allocator &= ~(1 << output->connector_id);
-
-	if (b->use_pixman) {
-		drm_output_fini_pixman(output);
-	} else {
-		gl_renderer->output_destroy(output_base);
-		gbm_surface_destroy(output->gbm_surface);
-	}
-
-	weston_plane_release(&output->fb_plane);
-	weston_plane_release(&output->cursor_plane);
-
-	weston_output_destroy(&output->base);
-
-	free(output);
-}
-
 /**
  * Find the closest-matching mode for a given target
  *
@@ -2239,7 +2189,7 @@ static struct drm_mode *
 drm_output_choose_initial_mode(struct drm_backend *backend,
 			       struct drm_output *output,
 			       enum weston_drm_backend_output_mode mode,
-			       struct weston_drm_backend_output_config *config,
+			       const char *modeline,
 			       const drmModeModeInfo *current_mode)
 {
 	struct drm_mode *preferred = NULL;
@@ -2247,21 +2197,21 @@ drm_output_choose_initial_mode(struct drm_backend *backend,
 	struct drm_mode *configured = NULL;
 	struct drm_mode *best = NULL;
 	struct drm_mode *drm_mode;
-	drmModeModeInfo modeline;
+	drmModeModeInfo drm_modeline;
 	int32_t width = 0;
 	int32_t height = 0;
 
-	if (mode == WESTON_DRM_BACKEND_OUTPUT_PREFERRED && config->modeline) {
-		if (sscanf(config->modeline, "%dx%d", &width, &height) != 2) {
+	if (mode == WESTON_DRM_BACKEND_OUTPUT_PREFERRED && modeline) {
+		if (sscanf(modeline, "%dx%d", &width, &height) != 2) {
 			width = -1;
 
-			if (parse_modeline(config->modeline, &modeline) == 0) {
-				configured = drm_output_add_mode(output, &modeline);
+			if (parse_modeline(modeline, &drm_modeline) == 0) {
+				configured = drm_output_add_mode(output, &drm_modeline);
 				if (!configured)
 					return NULL;
 			} else {
 				weston_log("Invalid modeline \"%s\" for output %s\n",
-					   config->modeline, output->base.name);
+					   modeline, output->base.name);
 			}
 		}
 	}
@@ -2330,109 +2280,104 @@ connector_get_current_mode(drmModeConnector *connector, int drm_fd,
 	return 0;
 }
 
-/**
- * Create and configure a Weston output structure
- *
- * Given a DRM connector, create a matching drm_output structure and add it
- * to Weston's output list.
- *
- * @param b Weston backend structure structure
- * @param resources DRM resources for this device
- * @param connector DRM connector to use for this new output
- * @param x Horizontal offset to use into global co-ordinate space
- * @param y Vertical offset to use into global co-ordinate space
- * @param drm_device udev device pointer
- * @returns 0 on success, or -1 on failure
- */
 static int
-create_output_for_connector(struct drm_backend *b,
-			    drmModeRes *resources,
-			    drmModeConnector *connector,
-			    int x, int y, struct udev_device *drm_device)
+drm_output_set_mode(struct weston_output *base,
+		    enum weston_drm_backend_output_mode mode,
+		    const char *modeline)
 {
-	struct drm_output *output;
-	struct drm_mode *drm_mode, *next, *current;
-	struct weston_mode *m;
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
 
+	struct drm_mode *drm_mode, *next, *current;
 	drmModeModeInfo crtc_mode;
 	int i;
-	enum weston_drm_backend_output_mode mode;
-	struct weston_drm_backend_output_config config = {{ 0 }};
 
-	i = find_crtc_for_connector(b, resources, connector);
-	if (i < 0) {
-		weston_log("No usable crtc/encoder pair for connector.\n");
-		return -1;
-	}
-
-	output = zalloc(sizeof *output);
-	if (output == NULL)
-		return -1;
-
-	output->base.subpixel = drm_subpixel_to_wayland(connector->subpixel);
-	output->base.name = make_connector_name(connector);
 	output->base.make = "unknown";
 	output->base.model = "unknown";
 	output->base.serial_number = "unknown";
 	wl_list_init(&output->base.mode_list);
 
-	mode = b->configure_output(b->compositor, b->use_current_mode,
-				   output->base.name, &config);
-	if (parse_gbm_format(config.gbm_format, b->gbm_format, &output->gbm_format) == -1)
-		output->gbm_format = b->gbm_format;
-
-	setup_output_seat_constraint(b, &output->base,
-				     config.seat ? config.seat : "");
-	free(config.seat);
-
-	output->crtc_id = resources->crtcs[i];
-	output->pipe = i;
-	b->crtc_allocator |= (1 << output->crtc_id);
-	output->connector_id = connector->connector_id;
-	b->connector_allocator |= (1 << output->connector_id);
-
 	output->original_crtc = drmModeGetCrtc(b->drm.fd, output->crtc_id);
-	output->dpms_prop = drm_get_prop(b->drm.fd, connector, "DPMS");
 
-	if (connector_get_current_mode(connector, b->drm.fd, &crtc_mode) < 0)
+	if (connector_get_current_mode(output->connector, b->drm.fd, &crtc_mode) < 0)
 		goto err_free;
 
-	for (i = 0; i < connector->count_modes; i++) {
-		drm_mode = drm_output_add_mode(output, &connector->modes[i]);
+	for (i = 0; i < output->connector->count_modes; i++) {
+		drm_mode = drm_output_add_mode(output, &output->connector->modes[i]);
 		if (!drm_mode)
 			goto err_free;
 	}
 
-	if (mode == WESTON_DRM_BACKEND_OUTPUT_OFF) {
-		weston_log("Disabling output %s\n", output->base.name);
-		drmModeSetCrtc(b->drm.fd, output->crtc_id,
-			       0, 0, 0, 0, 0, NULL);
-		goto err_free;
-	}
-
-	current = drm_output_choose_initial_mode(b, output, mode, &config,
-						 &crtc_mode);
+	current = drm_output_choose_initial_mode(b, output, mode, modeline, &crtc_mode);
 	if (!current)
 		goto err_free;
+
 	output->base.current_mode = &current->base;
 	output->base.current_mode->flags |= WL_OUTPUT_MODE_CURRENT;
 
-	weston_output_init(&output->base, b->compositor, x, y,
-			   connector->mmWidth, connector->mmHeight,
-			   config.base.transform, config.base.scale);
+	/* Set native_ fields, so weston_output_mode_switch_to_native() works */
+	output->base.native_mode = output->base.current_mode;
+	output->base.native_scale = output->base.current_scale;
+
+	output->base.mm_width = output->connector->mmWidth;
+	output->base.mm_height = output->connector->mmHeight;
+
+	return 0;
+
+err_free:
+	drmModeFreeCrtc(output->original_crtc);
+	output->original_crtc = NULL;
+
+	wl_list_for_each_safe(drm_mode, next, &output->base.mode_list,
+							base.link) {
+		wl_list_remove(&drm_mode->base.link);
+		free(drm_mode);
+	}
+
+	return -1;
+}
+
+static void
+drm_output_set_gbm_format(struct weston_output *base,
+			  const char *gbm_format)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	if (parse_gbm_format(gbm_format, b->gbm_format, &output->gbm_format) == -1)
+		output->gbm_format = b->gbm_format;
+}
+
+static void
+drm_output_set_seat(struct weston_output *base,
+		    const char *seat)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	setup_output_seat_constraint(b, &output->base,
+				     seat ? seat : "");
+}
+
+static int
+drm_output_enable(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+	struct weston_mode *m;
+
+	output->dpms_prop = drm_get_prop(b->drm.fd, output->connector, "DPMS");
 
 	if (b->use_pixman) {
 		if (drm_output_init_pixman(output, b) < 0) {
 			weston_log("Failed to init output pixman state\n");
-			goto err_output;
+			goto err_free;
 		}
 	} else if (drm_output_init_egl(output, b) < 0) {
 		weston_log("Failed to init output gl state\n");
-		goto err_output;
+		goto err_free;
 	}
 
-	output->backlight = backlight_init(drm_device,
-					   connector->connector_type);
 	if (output->backlight) {
 		weston_log("Initialized backlight, device %s\n",
 			   output->backlight->path);
@@ -2442,15 +2387,8 @@ create_output_for_connector(struct drm_backend *b,
 		weston_log("Failed to initialize backlight\n");
 	}
 
-	weston_compositor_add_output(b->compositor, &output->base);
-
-	find_and_parse_output_edid(b, output, connector);
-	if (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)
-		output->base.connection_internal = 1;
-
 	output->base.start_repaint_loop = drm_output_start_repaint_loop;
 	output->base.repaint = drm_output_repaint;
-	output->base.destroy = drm_output_destroy;
 	output->base.assign_planes = drm_assign_planes;
 	output->base.set_dpms = drm_set_dpms;
 	output->base.switch_mode = drm_output_switch_mode;
@@ -2458,6 +2396,12 @@ create_output_for_connector(struct drm_backend *b,
 	output->base.gamma_size = output->original_crtc->gamma_size;
 	output->base.set_gamma = drm_output_set_gamma;
 
+	output->base.subpixel = drm_subpixel_to_wayland(output->connector->subpixel);
+
+	find_and_parse_output_edid(b, output, output->connector);
+	if (output->connector->connector_type == DRM_MODE_CONNECTOR_LVDS)
+		output->base.connection_internal = 1;
+
 	weston_plane_init(&output->cursor_plane, b->compositor,
 			  INT32_MIN, INT32_MIN);
 	weston_plane_init(&output->fb_plane, b->compositor, 0, 0);
@@ -2475,31 +2419,155 @@ create_output_for_connector(struct drm_backend *b,
 				    ", preferred" : "",
 				    m->flags & WL_OUTPUT_MODE_CURRENT ?
 				    ", current" : "",
-				    connector->count_modes == 0 ?
+				    output->connector->count_modes == 0 ?
 				    ", built-in" : "");
 
-	/* Set native_ fields, so weston_output_mode_switch_to_native() works */
-	output->base.native_mode = output->base.current_mode;
-	output->base.native_scale = output->base.current_scale;
-
 	return 0;
 
-err_output:
-	weston_output_destroy(&output->base);
 err_free:
-	wl_list_for_each_safe(drm_mode, next, &output->base.mode_list,
-							base.link) {
-		wl_list_remove(&drm_mode->base.link);
-		free(drm_mode);
+	drmModeFreeProperty(output->dpms_prop);
+
+	return -1;
+}
+
+static void
+drm_output_deinit(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	if (b->use_pixman) {
+		drm_output_fini_pixman(output);
+	} else {
+		gl_renderer->output_destroy(&output->base);
+		gbm_surface_destroy(output->gbm_surface);
 	}
 
-	drmModeFreeCrtc(output->original_crtc);
+	weston_plane_release(&output->fb_plane);
+	weston_plane_release(&output->cursor_plane);
+
+	drmModeFreeProperty(output->dpms_prop);
+
+	/* Turn off hardware cursor */
+	drmModeSetCursor(b->drm.fd, output->crtc_id, 0, 0, 0);
+}
+
+static void
+drm_output_destroy(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+	drmModeCrtcPtr origcrtc = output->original_crtc;
+
+	if (output->page_flip_pending) {
+		output->destroy_pending = 1;
+		weston_log("destroy output while page flip pending\n");
+		return;
+	}
+
+	if (output->base.enabled)
+		drm_output_deinit(&output->base);
+
+	if (origcrtc) {
+		/* Restore original CRTC state */
+		drmModeSetCrtc(b->drm.fd, origcrtc->crtc_id, origcrtc->buffer_id,
+			       origcrtc->x, origcrtc->y,
+			       &output->connector_id, 1, &origcrtc->mode);
+		drmModeFreeCrtc(origcrtc);
+	}
+
+	weston_output_destroy(&output->base);
+
+	drmModeFreeConnector(output->connector);
+
+	if (output->backlight)
+		backlight_destroy(output->backlight);
+
 	b->crtc_allocator &= ~(1 << output->crtc_id);
 	b->connector_allocator &= ~(1 << output->connector_id);
+
 	free(output);
-	free(config.modeline);
+}
 
-	return -1;
+static int
+drm_output_disable(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	if (output->page_flip_pending) {
+		output->disable_pending = 1;
+		return -1;
+	}
+
+	if (output->base.enabled)
+		drm_output_deinit(&output->base);
+
+	output->disable_pending = 0;
+
+	weston_log("Disabling output %s\n", output->base.name);
+	drmModeSetCrtc(b->drm.fd, output->crtc_id,
+		       0, 0, 0, 0, 0, NULL);
+
+	return 0;
+}
+
+/**
+ * Create a Weston output structure
+ *
+ * Given a DRM connector, create a matching drm_output structure and add it
+ * to Weston's output list. It also takes ownership of the connector, which
+ * is released when output is destroyed.
+ *
+ * @param b Weston backend structure
+ * @param resources DRM resources for this device
+ * @param connector DRM connector to use for this new output
+ * @param drm_device udev device pointer
+ * @returns 0 on success, or -1 on failure
+ */
+static int
+create_output_for_connector(struct drm_backend *b,
+			    drmModeRes *resources,
+			    drmModeConnector *connector,
+			    struct udev_device *drm_device)
+{
+	struct drm_output *output;
+	int i;
+
+	i = find_crtc_for_connector(b, resources, connector);
+	if (i < 0) {
+		weston_log("No usable crtc/encoder pair for connector.\n");
+		return -1;
+	}
+
+	output = zalloc(sizeof *output);
+	if (output == NULL)
+		return -1;
+
+	output->connector = connector;
+	output->crtc_id = resources->crtcs[i];
+	output->pipe = i;
+	output->connector_id = connector->connector_id;
+
+	output->backlight = backlight_init(drm_device,
+					   connector->connector_type);
+
+	output->base.enable = drm_output_enable;
+	output->base.destroy = drm_output_destroy;
+	output->base.disable = drm_output_disable;
+	output->base.name = make_connector_name(connector);
+
+	output->destroy_pending = 0;
+	output->disable_pending = 0;
+	output->original_crtc = NULL;
+
+	b->crtc_allocator |= (1 << output->crtc_id);
+	b->connector_allocator |= (1 << output->connector_id);
+
+	weston_output_init(&output->base, b->compositor);
+	weston_compositor_add_pending_output(&output->base, b->compositor);
+
+	return 0;
 }
 
 static void
@@ -2578,7 +2646,6 @@ create_outputs(struct drm_backend *b, uint32_t option_connector,
 	drmModeConnector *connector;
 	drmModeRes *resources;
 	int i;
-	int x = 0, y = 0;
 
 	resources = drmModeGetResources(b->drm.fd);
 	if (!resources) {
@@ -2610,21 +2677,17 @@ create_outputs(struct drm_backend *b, uint32_t option_connector,
 		    (option_connector == 0 ||
 		     connector->connector_id == option_connector)) {
 			if (create_output_for_connector(b, resources,
-							connector, x, y,
-							drm_device) < 0) {
+							connector, drm_device) < 0) {
 				drmModeFreeConnector(connector);
 				continue;
 			}
-
-			x += container_of(b->compositor->output_list.prev,
-					  struct weston_output,
-					  link)->width;
+		} else {
+			drmModeFreeConnector(connector);
 		}
-
-		drmModeFreeConnector(connector);
 	}
 
-	if (wl_list_empty(&b->compositor->output_list))
+	if (wl_list_empty(&b->compositor->output_list) &&
+	    wl_list_empty(&b->compositor->pending_output_list))
 		weston_log("No currently active connector found.\n");
 
 	drmModeFreeResources(resources);
@@ -2638,7 +2701,6 @@ update_outputs(struct drm_backend *b, struct udev_device *drm_device)
 	drmModeConnector *connector;
 	drmModeRes *resources;
 	struct drm_output *output, *next;
-	int x = 0, y = 0;
 	uint32_t connected = 0, disconnects = 0;
 	int i;
 
@@ -2664,23 +2726,13 @@ update_outputs(struct drm_backend *b, struct udev_device *drm_device)
 		connected |= (1 << connector_id);
 
 		if (!(b->connector_allocator & (1 << connector_id))) {
-			struct weston_output *last =
-				container_of(b->compositor->output_list.prev,
-					     struct weston_output, link);
-
-			/* XXX: not yet needed, we die with 0 outputs */
-			if (!wl_list_empty(&b->compositor->output_list))
-				x = last->x + last->width;
-			else
-				x = 0;
-			y = 0;
 			create_output_for_connector(b, resources,
-						    connector, x, y,
-						    drm_device);
+						    connector, drm_device);
 			weston_log("connector %d connected\n", connector_id);
 
+		} else {
+			drmModeFreeConnector(connector);
 		}
-		drmModeFreeConnector(connector);
 	}
 	drmModeFreeResources(resources);
 
@@ -2695,6 +2747,16 @@ update_outputs(struct drm_backend *b, struct udev_device *drm_device)
 				drm_output_destroy(&output->base);
 			}
 		}
+
+		wl_list_for_each_safe(output, next, &b->compositor->pending_output_list,
+				      base.link) {
+			if (disconnects & (1 << output->connector_id)) {
+				disconnects &= ~(1 << output->connector_id);
+				weston_log("connector %d disconnected\n",
+				       output->connector_id);
+				drm_output_destroy(&output->base);
+			}
+		}
 	}
 }
 
@@ -3078,6 +3140,12 @@ renderer_switch_binding(struct weston_keyboard *keyboard, uint32_t time,
 	switch_to_gl_renderer(b);
 }
 
+static const struct weston_drm_output_api api = {
+	drm_output_set_mode,
+	drm_output_set_gbm_format,
+	drm_output_set_seat,
+};
+
 static struct drm_backend *
 drm_backend_create(struct weston_compositor *compositor,
 		   struct weston_drm_backend_config *config)
@@ -3087,6 +3155,7 @@ drm_backend_create(struct weston_compositor *compositor,
 	struct wl_event_loop *loop;
 	const char *path;
 	const char *seat_id = default_seat;
+	int ret;
 
 	weston_log("initializing drm backend\n");
 
@@ -3107,7 +3176,6 @@ drm_backend_create(struct weston_compositor *compositor,
 	b->sprites_are_broken = 1;
 	b->compositor = compositor;
 	b->use_pixman = config->use_pixman;
-	b->configure_output = config->configure_output;
 	b->use_current_mode = config->use_current_mode;
 
 	if (parse_gbm_format(config->gbm_format, GBM_FORMAT_XRGB8888, &b->gbm_format) < 0)
@@ -3230,6 +3298,14 @@ drm_backend_create(struct weston_compositor *compositor,
 
 	compositor->backend = &b->base;
 
+	ret = weston_plugin_api_register(compositor, WESTON_DRM_OUTPUT_API_NAME,
+					 &api, sizeof(api));
+
+	if (ret < 0) {
+		weston_log("Failed to register output API.\n");
+		goto err_udev_monitor;
+	}
+
 	return b;
 
 err_udev_monitor:
diff --git a/libweston/compositor-drm.h b/libweston/compositor-drm.h
index 1266031..8f89a2b 100644
--- a/libweston/compositor-drm.h
+++ b/libweston/compositor-drm.h
@@ -29,12 +29,13 @@
 #define WESTON_COMPOSITOR_DRM_H
 
 #include "compositor.h"
+#include "plugin-registry.h"
 
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
-#define WESTON_DRM_BACKEND_CONFIG_VERSION 1
+#define WESTON_DRM_BACKEND_CONFIG_VERSION 2
 
 struct libinput_device;
 
@@ -51,8 +52,17 @@ enum weston_drm_backend_output_mode {
 	WESTON_DRM_BACKEND_OUTPUT_PREFERRED,
 };
 
-struct weston_drm_backend_output_config {
-	struct weston_backend_output_config base;
+#define WESTON_DRM_OUTPUT_API_NAME "weston_drm_output_api_v1"
+
+struct weston_drm_output_api {
+	/** The mode to be used by the output. Refer to the documentation
+	 *  of WESTON_DRM_BACKEND_OUTPUT_PREFERRED for details.
+	 *
+	 * Returns 0 on success, -1 on failure.
+	 */
+	int (*set_mode)(struct weston_output *output,
+			enum weston_drm_backend_output_mode mode,
+			const char *modeline);
 
 	/** The pixel format to be used by the output. Valid values are:
 	 * - NULL - The format set at backend creation time will be used;
@@ -60,15 +70,26 @@ struct weston_drm_backend_output_config {
 	 * - "rgb565"
 	 * - "xrgb2101010"
 	 */
-	char *gbm_format;
+	void (*set_gbm_format)(struct weston_output *output,
+			       const char *gbm_format);
+
 	/** The seat to be used by the output. Set to NULL to use the
-	 * default seat. */
-	char *seat;
-	/** The modeline to be used by the output. Refer to the documentation
-	 * of WESTON_DRM_BACKEND_OUTPUT_PREFERRED for details. */
-	char *modeline;
+	 *  default seat.
+	 */
+	void (*set_seat)(struct weston_output *output,
+			 const char *seat);
 };
 
+static inline const struct weston_drm_output_api *
+weston_drm_output_get_api(struct weston_compositor *compositor)
+{
+	const void *api;
+	api = weston_plugin_api_get(compositor, WESTON_DRM_OUTPUT_API_NAME,
+				    sizeof(struct weston_drm_output_api));
+
+	return (const struct weston_drm_output_api *)api;
+}
+
 /** The backend configuration struct.
  *
  * weston_drm_backend_config contains the configuration used by a DRM
@@ -109,17 +130,6 @@ struct weston_drm_backend_config {
 	 */
 	char *gbm_format;
 
-	/** Callback used to configure the outputs.
-	 *
-	 * This function will be called by the backend when a new DRM
-	 * output needs to be configured.
-	 */
-	enum weston_drm_backend_output_mode
-		(*configure_output)(struct weston_compositor *compositor,
-				    bool use_current_mode,
-				    const char *name,
-				    struct weston_drm_backend_output_config *output_config);
-
 	/** Callback used to configure input devices.
 	 *
 	 * This function will be called by the backend when a new input device
diff --git a/libweston/compositor-fbdev.c b/libweston/compositor-fbdev.c
index 852acc0..0c45e98 100644
--- a/libweston/compositor-fbdev.c
+++ b/libweston/compositor-fbdev.c
@@ -426,12 +426,56 @@ static void fbdev_output_destroy(struct weston_output *base);
 static void fbdev_output_disable(struct weston_output *base);
 
 static int
+fbdev_output_enable(struct weston_output *base)
+{
+	struct fbdev_output *output = to_fbdev_output(base);
+	struct fbdev_backend *backend = to_fbdev_backend(base->compositor);
+	int fb_fd;
+	struct wl_event_loop *loop;
+
+	/* Create the frame buffer. */
+	fb_fd = fbdev_frame_buffer_open(output, output->device, &output->fb_info);
+	if (fb_fd < 0) {
+		weston_log("Creating frame buffer failed.\n");
+		return -1;
+	}
+
+	if (fbdev_frame_buffer_map(output, fb_fd) < 0) {
+		weston_log("Mapping frame buffer failed.\n");
+		return -1;
+	}
+
+	output->base.start_repaint_loop = fbdev_output_start_repaint_loop;
+	output->base.repaint = fbdev_output_repaint;
+
+	if (pixman_renderer_output_create(&output->base) < 0)
+		goto out_hw_surface;
+
+	loop = wl_display_get_event_loop(backend->compositor->wl_display);
+	output->finish_frame_timer =
+		wl_event_loop_add_timer(loop, finish_frame_handler, output);
+
+	weston_log("fbdev output %d%d px\n",
+	           output->mode.width, output->mode.height);
+	weston_log_continue(STAMP_SPACE "guessing %d Hz and 96 dpi\n",
+	                    output->mode.refresh / 1000);
+
+	return 0;
+
+out_hw_surface:
+	pixman_image_unref(output->hw_surface);
+	output->hw_surface = NULL;
+	fbdev_frame_buffer_destroy(output);
+
+	return -1;
+}
+
+static int
 fbdev_output_create(struct fbdev_backend *backend,
                     const char *device)
 {
 	struct fbdev_output *output;
 	int fb_fd;
-	struct wl_event_loop *loop;
 
 	weston_log("Creating fbdev output.\n");
 
@@ -449,14 +493,12 @@ fbdev_output_create(struct fbdev_backend *backend,
 		goto out_free;
 	}
 
-	if (fbdev_frame_buffer_map(output, fb_fd) < 0) {
-		weston_log("Mapping frame buffer failed.\n");
-		goto out_free;
-	}
-
-	output->base.start_repaint_loop = fbdev_output_start_repaint_loop;
-	output->base.repaint = fbdev_output_repaint;
+	output->base.name = strdup("fbdev");
 	output->base.destroy = fbdev_output_destroy;
+	output->base.disable = NULL;
+	output->base.enable = fbdev_output_enable;
+
+	weston_output_init(&output->base, backend->compositor);
 
 	/* only one static mode in list */
 	output->mode.flags =
@@ -471,35 +513,16 @@ fbdev_output_create(struct fbdev_backend *backend,
 	output->base.subpixel = WL_OUTPUT_SUBPIXEL_UNKNOWN;
 	output->base.make = "unknown";
 	output->base.model = output->fb_info.id;
-	output->base.name = strdup("fbdev");
 
-	weston_output_init(&output->base, backend->compositor,
-	                   0, 0, output->fb_info.width_mm,
-	                   output->fb_info.height_mm,
-	                   backend->output_transform,
-			   1);
+	output->base.mm_width = output->fb_info.width_mm;
+	output->base.mm_height = output->fb_info.height_mm;
 
-	if (pixman_renderer_output_create(&output->base) < 0)
-		goto out_hw_surface;
+	close(fb_fd);
 
-	loop = wl_display_get_event_loop(backend->compositor->wl_display);
-	output->finish_frame_timer =
-		wl_event_loop_add_timer(loop, finish_frame_handler, output);
-
-	weston_compositor_add_output(backend->compositor, &output->base);
-
-	weston_log("fbdev output %d%d px\n",
-	           output->mode.width, output->mode.height);
-	weston_log_continue(STAMP_SPACE "guessing %d Hz and 96 dpi\n",
-	                    output->mode.refresh / 1000);
+	weston_compositor_add_pending_output(&output->base, backend->compositor);
 
 	return 0;
 
-out_hw_surface:
-	pixman_image_unref(output->hw_surface);
-	output->hw_surface = NULL;
-	weston_output_destroy(&output->base);
-	fbdev_frame_buffer_destroy(output);
 out_free:
 	free(output->device);
 	free(output);
@@ -721,7 +744,6 @@ fbdev_backend_create(struct weston_compositor *compositor,
 	backend->base.restore = fbdev_restore;
 
 	backend->prev_state = WESTON_COMPOSITOR_ACTIVE;
-	backend->output_transform = param->output_transform;
 
 	weston_setup_vt_switch_bindings(compositor);
 
@@ -757,7 +779,6 @@ config_init_to_defaults(struct weston_fbdev_backend_config *config)
 	 * udev, rather than passing a device node in as a parameter. */
 	config->tty = 0; /* default to current tty */
 	config->device = "/dev/fb0"; /* default frame buffer */
-	config->output_transform = WL_OUTPUT_TRANSFORM_NORMAL;
 }
 
 WL_EXPORT int
diff --git a/libweston/compositor-fbdev.h b/libweston/compositor-fbdev.h
index 7b182c7..8b7d900 100644
--- a/libweston/compositor-fbdev.h
+++ b/libweston/compositor-fbdev.h
@@ -34,7 +34,7 @@ extern "C" {
 
 #include "compositor.h"
 
-#define WESTON_FBDEV_BACKEND_CONFIG_VERSION 1
+#define WESTON_FBDEV_BACKEND_CONFIG_VERSION 2
 
 struct libinput_device;
 
@@ -44,8 +44,6 @@ struct weston_fbdev_backend_config {
 	int tty;
 	char *device;
 
-	uint32_t output_transform;
-
 	/** Callback used to configure input devices.
 	 *
 	 * This function will be called by the backend when a new input device
diff --git a/libweston/compositor-headless.c b/libweston/compositor-headless.c
index 8b51207..e7fc397 100644
--- a/libweston/compositor-headless.c
+++ b/libweston/compositor-headless.c
@@ -26,6 +26,7 @@
 
 #include "config.h"
 
+#include <assert.h>
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
@@ -37,6 +38,7 @@
 #include "shared/helpers.h"
 #include "pixman-renderer.h"
 #include "presentation-time-server-protocol.h"
+#include "windowed-output-api.h"
 
 struct headless_backend {
 	struct weston_backend base;
@@ -105,12 +107,14 @@ headless_output_repaint(struct weston_output *output_base,
 	return 0;
 }
 
-static void
-headless_output_destroy(struct weston_output *output_base)
+static int
+headless_output_disable(struct weston_output *base)
 {
-	struct headless_output *output = to_headless_output(output_base);
-	struct headless_backend *b =
-			to_headless_backend(output->base.compositor);
+	struct headless_output *output = to_headless_output(base);
+	struct headless_backend *b = to_headless_backend(base->compositor);
+
+	if (!output->base.enabled)
+		return 0;
 
 	wl_event_source_remove(output->finish_frame_timer);
 
@@ -120,71 +124,123 @@ headless_output_destroy(struct weston_output *output_base)
 		free(output->image_buf);
 	}
 
+	return 0;
+}
+
+static void
+headless_output_destroy(struct weston_output *base)
+{
+	struct headless_output *output = to_headless_output(base);
+
+	headless_output_disable(&output->base);
 	weston_output_destroy(&output->base);
 
 	free(output);
-
-	return;
 }
 
 static int
-headless_backend_create_output(struct headless_backend *b,
-			       struct weston_headless_backend_config *config)
+headless_output_enable(struct weston_output *base)
 {
-	struct weston_compositor *c = b->compositor;
-	struct headless_output *output;
+	struct headless_output *output = to_headless_output(base);
+	struct headless_backend *b = to_headless_backend(base->compositor);
 	struct wl_event_loop *loop;
 
-	output = zalloc(sizeof *output);
-	if (output == NULL)
-		return -1;
+	loop = wl_display_get_event_loop(b->compositor->wl_display);
+	output->finish_frame_timer =
+		wl_event_loop_add_timer(loop, finish_frame_handler, output);
+
+	if (b->use_pixman) {
+		output->image_buf = malloc(output->base.current_mode->width *
+					   output->base.current_mode->height * 4);
+		if (!output->image_buf)
+			goto err_malloc;
+
+		output->image = pixman_image_create_bits(PIXMAN_x8r8g8b8,
+							 output->base.current_mode->width,
+							 output->base.current_mode->height,
+							 output->image_buf,
+							 output->base.current_mode->width * 4);
+
+		if (pixman_renderer_output_create(&output->base) < 0)
+			goto err_renderer;
+
+		pixman_renderer_output_set_buffer(&output->base,
+						  output->image);
+	}
+
+	return 0;
+
+err_renderer:
+	pixman_image_unref(output->image);
+	free(output->image_buf);
+err_malloc:
+	wl_event_source_remove(output->finish_frame_timer);
+
+	return -1;
+}
+
+static int
+headless_output_set_size(struct weston_output *base,
+			 int width, int height)
+{
+	struct headless_output *output = to_headless_output(base);
+	int output_width, output_height;
+
+	/* We can only be called once. */
+	assert(!output->base.current_mode);
+
+	/* Make sure we have scale set. */
+	assert(output->base.scale);
+
+	output_width = width * output->base.scale;
+	output_height = height * output->base.scale;
 
 	output->mode.flags =
 		WL_OUTPUT_MODE_CURRENT | WL_OUTPUT_MODE_PREFERRED;
-	output->mode.width = config->width;
-	output->mode.height = config->height;
+	output->mode.width = output_width;
+	output->mode.height = output_height;
 	output->mode.refresh = 60000;
 	wl_list_init(&output->base.mode_list);
 	wl_list_insert(&output->base.mode_list, &output->mode.link);
 
 	output->base.current_mode = &output->mode;
-	weston_output_init(&output->base, c, 0, 0, config->width,
-			   config->height, config->transform, 1);
-
 	output->base.make = "weston";
 	output->base.model = "headless";
 
-	loop = wl_display_get_event_loop(c->wl_display);
-	output->finish_frame_timer =
-		wl_event_loop_add_timer(loop, finish_frame_handler, output);
+	/* XXX: Calculate proper size. */
+	output->base.mm_width = width;
+	output->base.mm_height = height;
 
 	output->base.start_repaint_loop = headless_output_start_repaint_loop;
 	output->base.repaint = headless_output_repaint;
-	output->base.destroy = headless_output_destroy;
 	output->base.assign_planes = NULL;
 	output->base.set_backlight = NULL;
 	output->base.set_dpms = NULL;
 	output->base.switch_mode = NULL;
 
-	if (b->use_pixman) {
-		output->image_buf = malloc(config->width * config->height * 4);
-		if (!output->image_buf)
-			return -1;
+	return 0;
+}
 
-		output->image = pixman_image_create_bits(PIXMAN_x8r8g8b8,
-							 config->width,
-							 config->height,
-							 output->image_buf,
-							 config->width * 4);
+static int
+headless_output_create(struct weston_compositor *compositor,
+		       const char *name)
+{
+	struct headless_output *output;
 
-		if (pixman_renderer_output_create(&output->base) < 0)
-			return -1;
+	/* name can't be NULL. */
+	assert(name);
 
-		pixman_renderer_output_set_buffer(&output->base,
-						  output->image);
-	}
+	output = zalloc(sizeof *output);
+	if (output == NULL)
+		return -1;
+
+	output->base.name = strdup(name);
+	output->base.destroy = headless_output_destroy;
+	output->base.disable = headless_output_disable;
+	output->base.enable = headless_output_enable;
 
-	weston_compositor_add_output(c, &output->base);
+	weston_output_init(&output->base, compositor);
+	weston_compositor_add_pending_output(&output->base, compositor);
 
 	return 0;
 }
@@ -204,11 +260,17 @@ headless_destroy(struct weston_compositor *ec)
 	free(b);
 }
 
+static const struct weston_windowed_output_api api = {
+	headless_output_set_size,
+	headless_output_create,
+};
+
 static struct headless_backend *
 headless_backend_create(struct weston_compositor *compositor,
 			struct weston_headless_backend_config *config)
 {
 	struct headless_backend *b;
+	int ret;
 
 	b = zalloc(sizeof *b);
 	if (b == NULL)
@@ -226,15 +288,19 @@ headless_backend_create(struct weston_compositor *compositor,
 		pixman_renderer_init(compositor);
 	}
 
-	if (!config->no_outputs) {
-		if (headless_backend_create_output(b, config) < 0)
-			goto err_input;
-	}
-
 	if (!b->use_pixman && noop_renderer_init(compositor) < 0)
 		goto err_input;
 
 	compositor->backend = &b->base;
+
+	ret = weston_plugin_api_register(compositor, WESTON_WINDOWED_OUTPUT_API_NAME,
+					 &api, sizeof(api));
+
+	if (ret < 0) {
+		weston_log("Failed to register output API.\n");
+		goto err_input;
+	}
+
 	return b;
 
 err_input:
diff --git a/libweston/compositor-headless.h b/libweston/compositor-headless.h
index b432b09..c84ed9f 100644
--- a/libweston/compositor-headless.h
+++ b/libweston/compositor-headless.h
@@ -34,19 +34,13 @@ extern "C" {
 
 #include "compositor.h"
 
-#define WESTON_HEADLESS_BACKEND_CONFIG_VERSION 1
+#define WESTON_HEADLESS_BACKEND_CONFIG_VERSION 2
 
 struct weston_headless_backend_config {
 	struct weston_backend_config base;
 
-	int width;
-	int height;
-
 	/** Whether to use the pixman renderer instead of the OpenGL ES renderer. */
 	int use_pixman;
-
-	uint32_t transform;
-	bool no_outputs;
 };
 
 #ifdef  __cplusplus
diff --git a/libweston/compositor-rdp.c b/libweston/compositor-rdp.c
index ee81300..223382c 100644
--- a/libweston/compositor-rdp.c
+++ b/libweston/compositor-rdp.c
@@ -25,6 +25,7 @@
 
 #include "config.h"
 
+#include <assert.h>
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
@@ -371,15 +372,6 @@ rdp_output_repaint(struct weston_output *output_base, pixman_region32_t *damage)
 	return 0;
 }
 
-static void
-rdp_output_destroy(struct weston_output *output_base)
-{
-	struct rdp_output *output = to_rdp_output(output_base);
-
-	wl_event_source_remove(output->finish_frame_timer);
-	free(output);
-}
-
 static int
 finish_frame_handler(void *data)
 {
@@ -471,16 +463,15 @@ rdp_switch_mode(struct weston_output *output, struct weston_mode *target_mode)
 }
 
 static int
-rdp_backend_create_output(struct rdp_backend *b, int width, int height)
+rdp_output_set_size(struct weston_output *base,
+		    int width, int height)
 {
-	struct rdp_output *output;
-	struct wl_event_loop *loop;
+	struct rdp_output *output = to_rdp_output(base);
 	struct weston_mode *currentMode;
 	struct weston_mode initMode;
 
-	output = zalloc(sizeof *output);
-	if (output == NULL)
-		return -1;
+	/* We can only be called once. */
+	assert(!output->base.current_mode);
 
 	wl_list_init(&output->peers);
 	wl_list_init(&output->base.mode_list);
@@ -492,48 +483,103 @@ rdp_backend_create_output(struct rdp_backend *b, int width, int height)
 
 	currentMode = ensure_matching_mode(&output->base, &initMode);
 	if (!currentMode)
-		goto out_free_output;
+		return -1;
 
 	output->base.current_mode = output->base.native_mode = currentMode;
-	weston_output_init(&output->base, b->compositor, 0, 0, width, height,
-			   WL_OUTPUT_TRANSFORM_NORMAL, 1);
-
 	output->base.make = "weston";
 	output->base.model = "rdp";
+
+	/* XXX: Calculate proper size. */
+	output->base.mm_width = width;
+	output->base.mm_height = height;
+
+	output->base.start_repaint_loop = rdp_output_start_repaint_loop;
+	output->base.repaint = rdp_output_repaint;
+	output->base.assign_planes = NULL;
+	output->base.set_backlight = NULL;
+	output->base.set_dpms = NULL;
+	output->base.switch_mode = rdp_switch_mode;
+
+	return 0;
+}
+
+static int
+rdp_output_enable(struct weston_output *base)
+{
+	struct rdp_output *output = to_rdp_output(base);
+	struct rdp_backend *b = to_rdp_backend(base->compositor);
+	struct wl_event_loop *loop;
+
 	output->shadow_surface = pixman_image_create_bits(PIXMAN_x8r8g8b8,
-			width, height,
-		    NULL,
-		    width * 4);
+							  output->base.current_mode->width,
+							  output->base.current_mode->height,
+							  NULL,
+							  output->base.current_mode->width * 4);
 	if (output->shadow_surface == NULL) {
 		weston_log("Failed to create surface for frame buffer.\n");
-		goto out_output;
+		return -1;
 	}
 
-	if (pixman_renderer_output_create(&output->base) < 0)
-		goto out_shadow_surface;
+	if (pixman_renderer_output_create(&output->base) < 0) {
+		pixman_image_unref(output->shadow_surface);
+		return -1;
+	}
 
 	loop = wl_display_get_event_loop(b->compositor->wl_display);
 	output->finish_frame_timer = wl_event_loop_add_timer(loop, finish_frame_handler, output);
 
-	output->base.start_repaint_loop = rdp_output_start_repaint_loop;
-	output->base.repaint = rdp_output_repaint;
-	output->base.destroy = rdp_output_destroy;
-	output->base.assign_planes = NULL;
-	output->base.set_backlight = NULL;
-	output->base.set_dpms = NULL;
-	output->base.switch_mode = rdp_switch_mode;
 	b->output = output;
 
-	weston_compositor_add_output(b->compositor, &output->base);
 	return 0;
+}
+
+static int
+rdp_output_disable(struct weston_output *base)
+{
+	struct rdp_output *output = to_rdp_output(base);
+	struct rdp_backend *b = to_rdp_backend(base->compositor);
+
+	if (!output->base.enabled)
+		return 0;
 
-out_shadow_surface:
 	pixman_image_unref(output->shadow_surface);
-out_output:
+	pixman_renderer_output_destroy(&output->base);
+
+	wl_event_source_remove(output->finish_frame_timer);
+	b->output = NULL;
+
+	return 0;
+}
+
+static void
+rdp_output_destroy(struct weston_output *base)
+{
+	struct rdp_output *output = to_rdp_output(base);
+
+	rdp_output_disable(&output->base);
 	weston_output_destroy(&output->base);
-out_free_output:
+
 	free(output);
-	return -1;
+}
+
+static int
+rdp_backend_create_output(struct weston_compositor *compositor)
+{
+	struct rdp_output *output;
+
+	output = zalloc(sizeof *output);
+	if (output == NULL)
+		return -1;
+
+	output->base.name =  strdup("rdp");
+	output->base.destroy = rdp_output_destroy;
+	output->base.disable = rdp_output_disable;
+	output->base.enable = rdp_output_enable;
+
+	weston_output_init(&output->base, compositor);
+	weston_compositor_add_pending_output(&output->base, compositor);
+
+	return 0;
 }
 
 static void
@@ -1216,6 +1262,10 @@ rdp_incoming_peer(freerdp_listener *instance, freerdp_peer *client)
 	FREERDP_CB_RETURN(TRUE);
 }
 
+static const struct weston_rdp_output_api api = {
+	rdp_output_set_size,
+};
+
 static struct rdp_backend *
 rdp_backend_create(struct weston_compositor *compositor,
 		   struct weston_rdp_backend_config *config)
@@ -1223,7 +1273,7 @@ rdp_backend_create(struct weston_compositor *compositor,
 	struct rdp_backend *b;
 	char *fd_str;
 	char *fd_tail;
-	int fd;
+	int fd, ret;
 
 	b = zalloc(sizeof *b);
 	if (b == NULL)
@@ -1251,7 +1301,7 @@ rdp_backend_create(struct weston_compositor *compositor,
 	if (pixman_renderer_init(compositor) < 0)
 		goto err_compositor;
 
-	if (rdp_backend_create_output(b, config->width, config->height) < 0)
+	if (rdp_backend_create_output(compositor) < 0)
 		goto err_compositor;
 
 	compositor->capabilities |= WESTON_CAP_ARBITRARY_MODES;
@@ -1282,6 +1332,15 @@ rdp_backend_create(struct weston_compositor *compositor,
 	}
 
 	compositor->backend = &b->base;
+
+	ret = weston_plugin_api_register(compositor, WESTON_RDP_OUTPUT_API_NAME,
+					 &api, sizeof(api));
+
+	if (ret < 0) {
+		weston_log("Failed to register output API.\n");
+		goto err_output;
+	}
+
 	return b;
 
 err_listener:
@@ -1301,8 +1360,6 @@ err_free_strings:
 static void
 config_init_to_defaults(struct weston_rdp_backend_config *config)
 {
-	config->width = 640;
-	config->height = 480;
 	config->bind_address = NULL;
 	config->port = 3389;
 	config->rdp_key = NULL;
diff --git a/libweston/compositor-rdp.h b/libweston/compositor-rdp.h
index dfa1759..bd0a6a9 100644
--- a/libweston/compositor-rdp.h
+++ b/libweston/compositor-rdp.h
@@ -31,13 +31,33 @@ extern "C" {
 #endif
 
 #include "compositor.h"
+#include "plugin-registry.h"
 
-#define WESTON_RDP_BACKEND_CONFIG_VERSION 1
+#define WESTON_RDP_OUTPUT_API_NAME "weston_rdp_output_api_v1"
+
+struct weston_rdp_output_api {
+	/** Initialize a RDP output with specified width and height.
+	 *
+	 * Returns 0 on success, -1 on failure.
+	 */
+	int (*output_set_size)(struct weston_output *output,
+			       int width, int height);
+};
+
+static inline const struct weston_rdp_output_api *
+weston_rdp_output_get_api(struct weston_compositor *compositor)
+{
+	const void *api;
+	api = weston_plugin_api_get(compositor, WESTON_RDP_OUTPUT_API_NAME,
+				    sizeof(struct weston_rdp_output_api));
+
+	return (const struct weston_rdp_output_api *)api;
+}
+
+#define WESTON_RDP_BACKEND_CONFIG_VERSION 2
 
 struct weston_rdp_backend_config {
 	struct weston_backend_config base;
-	int width;
-	int height;
 	char *bind_address;
 	int port;
 	char *rdp_key;
diff --git a/libweston/compositor-st.c b/libweston/compositor-st.c
new file mode 100644
index 0000000..8e71af2
--- /dev/null
+++ b/libweston/compositor-st.c
@@ -0,0 +1,3905 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2016
+ * Authors:  Vincent Abriou <vincent.abriou@st.com> for STMicroelectronics.
+ *           Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include "config.h"
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/input.h>
+#include <linux/vt.h>
+#include <assert.h>
+#include <sys/mman.h>
+#include <dlfcn.h>
+#include <time.h>
+
+#include <xf86drm.h>
+#include <xf86drmMode.h>
+#include <drm_fourcc.h>
+
+#include <gbm.h>
+#include <libudev.h>
+
+#include "compositor.h"
+#include "compositor-drm.h"
+#include "shared/helpers.h"
+#include "shared/timespec-util.h"
+#include "gl-renderer.h"
+#include "weston-egl-ext.h"
+#include "pixman-renderer.h"
+#include "libbacklight.h"
+#include "libinput-seat.h"
+#include "launcher-util.h"
+#include "vaapi-recorder.h"
+#include "presentation-time-server-protocol.h"
+#include "linux-dmabuf.h"
+#include "linux-dmabuf-unstable-v1-server-protocol.h"
+
+#ifdef ENABLE_DISPLAY_CAPTURE
+#include "capture-server-protocol.h"
+#endif
+
+#ifndef DRM_CAP_TIMESTAMP_MONOTONIC
+#define DRM_CAP_TIMESTAMP_MONOTONIC 0x6
+#endif
+
+#ifndef DRM_CAP_CURSOR_WIDTH
+#define DRM_CAP_CURSOR_WIDTH 0x8
+#endif
+
+#ifndef DRM_CAP_CURSOR_HEIGHT
+#define DRM_CAP_CURSOR_HEIGHT 0x9
+#endif
+
+#ifndef GBM_BO_USE_CURSOR
+#define GBM_BO_USE_CURSOR GBM_BO_USE_CURSOR_64X64
+#endif
+
+#define ZORDER_PROP_NAME	"zpos"
+#define ZORDER_MAX		6
+
+struct drm_backend {
+	struct weston_backend base;
+	struct weston_compositor *compositor;
+
+	struct udev *udev;
+	struct wl_event_source *drm_source;
+
+	struct udev_monitor *udev_monitor;
+	struct wl_event_source *udev_drm_source;
+
+	struct {
+		int id;
+		int fd;
+		char *filename;
+	} drm;
+	struct gbm_device *gbm;
+	uint32_t *crtcs;
+	int num_crtcs;
+	uint32_t crtc_allocator;
+	uint32_t connector_allocator;
+	struct wl_listener session_listener;
+	uint32_t gbm_format;
+
+	/* we need these parameters in order to not fail drmModeAddFB2()
+	 * due to out of bounds dimensions, and then mistakenly set
+	 * sprites_are_broken:
+	 */
+	uint32_t min_width, max_width;
+	uint32_t min_height, max_height;
+	int no_addfb2;
+
+	struct wl_list sprite_list;
+	int sprites_are_broken;
+	int sprites_hidden;
+
+	int cursors_are_broken[2]; /* per output */
+
+	int use_pixman;
+
+	uint32_t prev_state;
+
+	struct udev_input input;
+
+	int32_t cursor_width;
+	int32_t cursor_height;
+
+	bool use_current_mode;
+};
+
+struct drm_mode {
+	struct weston_mode base;
+	drmModeModeInfo mode_info;
+};
+
+struct drm_fb {
+	uint32_t fb_id, stride, handle, size, flags;
+	int fd;
+	int is_client_buffer;
+	struct weston_buffer_reference buffer_ref;
+
+	/* Used by gbm fbs */
+	struct gbm_bo *bo;
+
+	/* Used by dumb fbs */
+	void *map;
+};
+
+struct drm_edid {
+	char eisa_id[13];
+	char monitor_name[13];
+	char pnp_id[5];
+	char serial_number[13];
+};
+
+#ifdef ENABLE_DISPLAY_CAPTURE
+struct drm_output_capture {
+	struct drm_backend *backend;
+	struct drm_output *output;
+	struct wl_global *global;
+	struct wl_resource *resource;
+	struct wl_resource *output_resource;
+	struct wl_listener destroy_listener;
+	unsigned int nb_frames;
+	uint32_t start_msecs;
+	bool stopping;
+};
+
+static void
+capture_output_repainted(struct drm_output_capture *doc, struct gbm_bo *bo);
+#endif
+
+struct drm_output {
+	struct weston_output base;
+	drmModeConnector *connector;
+
+	uint32_t crtc_id;
+	int pipe;
+	uint32_t connector_id;
+	drmModeCrtcPtr original_crtc;
+	struct drm_edid edid;
+	drmModePropertyPtr dpms_prop;
+	uint32_t gbm_format;
+
+	enum dpms_enum dpms;
+
+	int vblank_pending;
+	int page_flip_pending;
+	int destroy_pending;
+	int disable_pending;
+
+	struct gbm_surface *gbm_surface;
+	struct gbm_bo *gbm_cursor_bo[2];
+	struct weston_plane cursor_plane;
+	struct weston_plane fb_plane;
+	struct weston_view *cursor_view;
+	int current_cursor;
+	struct drm_fb *current, *next;
+	struct backlight *backlight;
+
+	struct drm_fb *dumb[2];
+	pixman_image_t *image[2];
+	int current_image;
+	pixman_region32_t previous_damage;
+
+	struct vaapi_recorder *recorder;
+	struct wl_listener recorder_frame_listener;
+
+#ifdef ENABLE_DISPLAY_CAPTURE
+	struct drm_output_capture *doc;
+#endif
+};
+
+/*
+ * An output has a primary display plane plus zero or more sprites for
+ * blending display contents.
+ */
+struct drm_sprite {
+	struct wl_list link;
+
+	struct weston_plane plane;
+
+	struct drm_fb *current, *next;
+	struct drm_output *output;
+	struct drm_backend *backend;
+
+	uint32_t possible_crtcs;
+	uint32_t plane_id;
+	uint32_t count_formats;
+	uint32_t zorder;
+	uint32_t zpos_prop_id;
+
+	int32_t src_x, src_y;
+	uint32_t src_w, src_h;
+	uint32_t dest_x, dest_y;
+	uint32_t dest_w, dest_h;
+
+	bool vblank_pending;
+
+	uint32_t formats[];
+};
+
+static struct gl_renderer_interface *gl_renderer;
+
+static const char default_seat[] = "seat0";
+
+static inline struct drm_output *
+to_drm_output(struct weston_output *base)
+{
+	return container_of(base, struct drm_output, base);
+}
+
+static inline struct drm_backend *
+to_drm_backend(struct weston_compositor *base)
+{
+	return container_of(base->backend, struct drm_backend, base);
+}
+
+static void
+drm_output_set_cursor(struct drm_output *output);
+
+static void
+drm_output_update_msc(struct drm_output *output, unsigned int seq);
+
+static int
+drm_sprite_crtc_supported(struct drm_output *output, uint32_t supported)
+{
+	struct weston_compositor *ec = output->base.compositor;
+	struct drm_backend *b = to_drm_backend(ec);
+	int crtc;
+
+	for (crtc = 0; crtc < b->num_crtcs; crtc++) {
+		if (b->crtcs[crtc] != output->crtc_id)
+			continue;
+
+		if (supported & (1 << crtc))
+			return -1;
+	}
+
+	return 0;
+}
+
+static void
+drm_fb_destroy_callback(struct gbm_bo *bo, void *data)
+{
+	struct drm_fb *fb = data;
+	struct gbm_device *gbm = gbm_bo_get_device(bo);
+
+	if (fb->fb_id)
+		drmModeRmFB(gbm_device_get_fd(gbm), fb->fb_id);
+
+	weston_buffer_reference(&fb->buffer_ref, NULL);
+
+	free(data);
+}
+
+static void
+drm_fb_destroy_from_buff(struct drm_fb *fb)
+{
+	if (fb->fb_id)
+		drmModeRmFB(fb->fd, fb->fb_id);
+
+	weston_buffer_reference(&fb->buffer_ref, NULL);
+
+	free(fb);
+}
+
+static struct drm_fb *
+drm_fb_create_dumb(struct drm_backend *b, unsigned width, unsigned height,
+		   uint32_t format)
+{
+	struct drm_fb *fb;
+	int ret;
+	uint32_t bpp, depth;
+
+	struct drm_mode_create_dumb create_arg;
+	struct drm_mode_destroy_dumb destroy_arg;
+	struct drm_mode_map_dumb map_arg;
+
+	fb = zalloc(sizeof *fb);
+	if (!fb)
+		return NULL;
+
+	switch (format) {
+		case GBM_FORMAT_XRGB8888:
+			bpp = 32;
+			depth = 24;
+			break;
+		case GBM_FORMAT_RGB565:
+			bpp = depth = 16;
+			break;
+		default:
+			return NULL;
+	}
+
+	memset(&create_arg, 0, sizeof create_arg);
+	create_arg.bpp = bpp;
+	create_arg.width = width;
+	create_arg.height = height;
+
+	ret = drmIoctl(b->drm.fd, DRM_IOCTL_MODE_CREATE_DUMB, &create_arg);
+	if (ret)
+		goto err_fb;
+
+	fb->handle = create_arg.handle;
+	fb->stride = create_arg.pitch;
+	fb->size = create_arg.size;
+	fb->fd = b->drm.fd;
+
+	ret = -1;
+
+	if (!b->no_addfb2) {
+		uint32_t handles[4] = { 0 }, pitches[4] = { 0 }, offsets[4] = { 0 };
+
+		handles[0] = fb->handle;
+		pitches[0] = fb->stride;
+		offsets[0] = 0;
+
+		ret = drmModeAddFB2(b->drm.fd, width, height,
+				    format, handles, pitches, offsets,
+				    &fb->fb_id, 0);
+		if (ret) {
+			weston_log("addfb2 failed: %m\n");
+			b->no_addfb2 = 1;
+		}
+	}
+
+	if (ret) {
+		ret = drmModeAddFB(b->drm.fd, width, height, depth, bpp,
+				   fb->stride, fb->handle, &fb->fb_id);
+	}
+
+	if (ret)
+		goto err_bo;
+
+	memset(&map_arg, 0, sizeof map_arg);
+	map_arg.handle = fb->handle;
+	ret = drmIoctl(fb->fd, DRM_IOCTL_MODE_MAP_DUMB, &map_arg);
+	if (ret)
+		goto err_add_fb;
+
+	fb->map = mmap(NULL, fb->size, PROT_WRITE,
+		       MAP_SHARED, b->drm.fd, map_arg.offset);
+	if (fb->map == MAP_FAILED)
+		goto err_add_fb;
+
+	return fb;
+
+err_add_fb:
+	drmModeRmFB(b->drm.fd, fb->fb_id);
+err_bo:
+	memset(&destroy_arg, 0, sizeof(destroy_arg));
+	destroy_arg.handle = create_arg.handle;
+	drmIoctl(b->drm.fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destroy_arg);
+err_fb:
+	free(fb);
+	return NULL;
+}
+
+static void
+drm_fb_destroy_dumb(struct drm_fb *fb)
+{
+	struct drm_mode_destroy_dumb destroy_arg;
+
+	if (!fb->map)
+		return;
+
+	if (fb->fb_id)
+		drmModeRmFB(fb->fd, fb->fb_id);
+
+	weston_buffer_reference(&fb->buffer_ref, NULL);
+
+	munmap(fb->map, fb->size);
+
+	memset(&destroy_arg, 0, sizeof(destroy_arg));
+	destroy_arg.handle = fb->handle;
+	drmIoctl(fb->fd, DRM_IOCTL_MODE_DESTROY_DUMB, &destroy_arg);
+
+	free(fb);
+}
+
+static struct drm_fb *
+drm_fb_get_from_bo(struct gbm_bo *bo,
+		   struct drm_backend *backend, uint32_t format)
+{
+	struct drm_fb *fb = gbm_bo_get_user_data(bo);
+	uint32_t width, height;
+	uint32_t handles[4] = { 0 }, pitches[4] = { 0 }, offsets[4] = { 0 };
+	int ret;
+
+	if (fb)
+		return fb;
+
+	fb = zalloc(sizeof *fb);
+	if (fb == NULL)
+		return NULL;
+
+	fb->bo = bo;
+
+	width = gbm_bo_get_width(bo);
+	height = gbm_bo_get_height(bo);
+	fb->stride = gbm_bo_get_stride(bo);
+	fb->handle = gbm_bo_get_handle(bo).u32;
+	fb->size = fb->stride * height;
+	fb->fd = backend->drm.fd;
+
+	if (backend->min_width > width || width > backend->max_width ||
+	    backend->min_height > height ||
+	    height > backend->max_height) {
+		weston_log("bo geometry out of bounds\n");
+		goto err_free;
+	}
+
+	ret = -1;
+
+	if (format && !backend->no_addfb2) {
+		handles[0] = fb->handle;
+		pitches[0] = fb->stride;
+		offsets[0] = 0;
+
+		ret = drmModeAddFB2(backend->drm.fd, width, height,
+				    format, handles, pitches, offsets,
+				    &fb->fb_id, 0);
+		if (ret) {
+			weston_log("addfb2 failed: %m\n");
+		}
+	}
+
+	if (ret)
+		ret = drmModeAddFB(backend->drm.fd, width, height, 24, 32,
+				   fb->stride, fb->handle, &fb->fb_id);
+
+	if (ret) {
+		weston_log("failed to create kms fb: %m\n");
+		goto err_free;
+	}
+
+	gbm_bo_set_user_data(bo, fb, drm_fb_destroy_callback);
+
+	return fb;
+
+err_free:
+	free(fb);
+	return NULL;
+}
+
+struct backend_priv_data {
+	int drm_fd;
+	uint32_t handle;
+};
+
+static void
+drm_destroy_backend_priv_data(struct linux_dmabuf_buffer *dmabuf_buffer)
+{
+	struct backend_priv_data *data;
+	struct drm_gem_close gem_close;
+
+	data = linux_dmabuf_buffer_get_backend_priv_data(dmabuf_buffer);
+
+	memset(&gem_close, 0, sizeof(gem_close));
+	gem_close.handle = data->handle;
+	drmIoctl(data->drm_fd, DRM_IOCTL_GEM_CLOSE, &gem_close);
+	free(data);
+}
+
+static struct drm_fb *
+drm_fb_get_from_dmabuf(struct linux_dmabuf_buffer *dmabuf_buffer,
+		struct drm_backend *backend, uint32_t format)
+{
+	struct drm_fb *fb;
+	struct backend_priv_data *data;
+	uint32_t width, height;
+	uint32_t handles[4], pitches[4], offsets[4];
+	int ret, i;
+
+	fb = zalloc(sizeof *fb);
+	if (fb == NULL)
+		return NULL;
+
+	/* allocate data and fill data structure only the first time */
+	data = linux_dmabuf_buffer_get_backend_priv_data(dmabuf_buffer);
+	if (!data) {
+		data = zalloc(sizeof *data);
+		if (data == NULL)
+			goto err_free;
+
+		ret = drmPrimeFDToHandle(backend->drm.fd,
+					 dmabuf_buffer->attributes.fd[0],
+					 &data->handle);
+		if (ret) {
+			weston_log("drmPrimeFDToHandle failed\n");
+			goto err_free;
+		}
+
+		data->drm_fd = backend->drm.fd;
+		/* set the handle in backend_priv_data structure */
+		linux_dmabuf_buffer_set_backend_priv_data(dmabuf_buffer, data,
+							  drm_destroy_backend_priv_data);
+	}
+
+	/* get the handle from the backend private data */
+	fb->handle = data->handle;
+
+	width = dmabuf_buffer->attributes.width;
+	height = dmabuf_buffer->attributes.height;
+
+	if (backend->min_width > width ||
+			width > backend->max_width ||
+			backend->min_height > height ||
+			height > backend->max_height) {
+		weston_log("geometry out of bounds\n");
+		goto err_free;
+	}
+	fb->stride = dmabuf_buffer->attributes.stride[0];
+	fb->size = fb->stride * height;
+	fb->fd = backend->drm.fd;
+	for (i = 0; i < 4; i++) {
+		handles[i] = fb->handle;
+		pitches[i] = dmabuf_buffer->attributes.stride[i];
+		offsets[i] = dmabuf_buffer->attributes.offset[i];
+	}
+
+	if (dmabuf_buffer->attributes.flags & ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_INTERLACED)
+		fb->flags |= DRM_MODE_FB_INTERLACED;
+
+	if (dmabuf_buffer->attributes.flags & ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_BOTTOM_FIRST)
+		fb->flags |= DRM_MODE_FB_BFF;
+
+	ret = drmModeAddFB2(backend->drm.fd, width, height,
+			format, handles, pitches, offsets,
+			&fb->fb_id, fb->flags);
+	if (ret) {
+		weston_log("addfb2 failed\n");
+		goto err_free;
+	}
+
+	return fb;
+
+	err_free:
+	free(fb);
+	return NULL;
+}
+
+static void
+drm_fb_set_buffer(struct drm_fb *fb, struct weston_buffer *buffer)
+{
+	assert(fb->buffer_ref.buffer == NULL);
+
+	fb->is_client_buffer = 1;
+
+	weston_buffer_reference(&fb->buffer_ref, buffer);
+}
+
+static void
+drm_output_release_fb(struct drm_output *output, struct drm_fb *fb)
+{
+	if (!fb)
+		return;
+
+	if (fb->map &&
+            (fb != output->dumb[0] && fb != output->dumb[1])) {
+		drm_fb_destroy_dumb(fb);
+	} else if (fb->bo) {
+		if (fb->is_client_buffer) {
+			gbm_bo_destroy(fb->bo);
+		} else {
+			gbm_surface_release_buffer(output->gbm_surface,
+						   fb->bo);
+		}
+	} else if (fb->is_client_buffer) {
+		drm_fb_destroy_from_buff(fb);
+	}
+}
+
+static uint32_t
+drm_output_check_scanout_format(struct drm_output *output,
+				struct weston_surface *es, struct gbm_bo *bo)
+{
+	uint32_t format;
+	pixman_region32_t r;
+
+	format = gbm_bo_get_format(bo);
+
+	if (format == GBM_FORMAT_ARGB8888) {
+		/* We can scanout an ARGB buffer if the surface's
+		 * opaque region covers the whole output, but we have
+		 * to use XRGB as the KMS format code. */
+		pixman_region32_init_rect(&r, 0, 0,
+					  output->base.width,
+					  output->base.height);
+		pixman_region32_subtract(&r, &r, &es->opaque);
+
+		if (!pixman_region32_not_empty(&r))
+			format = GBM_FORMAT_XRGB8888;
+
+		pixman_region32_fini(&r);
+	}
+
+	if (output->gbm_format == format)
+		return format;
+
+	return 0;
+}
+
+static struct weston_plane *
+drm_output_prepare_scanout_view(struct drm_output *output,
+				struct weston_view *ev)
+{
+	struct drm_backend *b = to_drm_backend(output->base.compositor);
+	struct weston_buffer *buffer = ev->surface->buffer_ref.buffer;
+	struct weston_buffer_viewport *viewport = &ev->surface->buffer_viewport;
+	struct gbm_bo *bo;
+	uint32_t format;
+
+	if (ev->geometry.x != output->base.x ||
+	    ev->geometry.y != output->base.y ||
+	    buffer == NULL || b->gbm == NULL ||
+	    buffer->width != output->base.current_mode->width ||
+	    buffer->height != output->base.current_mode->height ||
+	    output->base.transform != viewport->buffer.transform ||
+	    ev->transform.enabled)
+		return NULL;
+
+	if (ev->geometry.scissor_enabled)
+		return NULL;
+
+	bo = gbm_bo_import(b->gbm, GBM_BO_IMPORT_WL_BUFFER,
+			   buffer->resource, GBM_BO_USE_SCANOUT);
+
+	/* Unable to use the buffer for scanout */
+	if (!bo)
+		return NULL;
+
+	format = drm_output_check_scanout_format(output, ev->surface, bo);
+	if (format == 0) {
+		gbm_bo_destroy(bo);
+		return NULL;
+	}
+
+	output->next = drm_fb_get_from_bo(bo, b, format);
+	if (!output->next) {
+		gbm_bo_destroy(bo);
+		return NULL;
+	}
+
+	drm_fb_set_buffer(output->next, buffer);
+
+	return &output->fb_plane;
+}
+
+static void
+drm_output_render_gl(struct drm_output *output, pixman_region32_t *damage)
+{
+	struct drm_backend *b = to_drm_backend(output->base.compositor);
+	struct gbm_bo *bo;
+
+	output->base.compositor->renderer->repaint_output(&output->base,
+							  damage);
+
+	bo = gbm_surface_lock_front_buffer(output->gbm_surface);
+	if (!bo) {
+		weston_log("failed to lock front buffer: %m\n");
+		return;
+	}
+
+	output->next = drm_fb_get_from_bo(bo, b, output->gbm_format);
+	if (!output->next) {
+		weston_log("failed to get drm_fb for bo\n");
+		gbm_surface_release_buffer(output->gbm_surface, bo);
+		return;
+	}
+
+#ifdef ENABLE_DISPLAY_CAPTURE
+	if (output->doc)
+		capture_output_repainted(output->doc, bo);
+#endif
+}
+
+static void
+drm_output_render_pixman(struct drm_output *output, pixman_region32_t *damage)
+{
+	struct weston_compositor *ec = output->base.compositor;
+	pixman_region32_t total_damage, previous_damage;
+
+	weston_xlog("%s\n",__func__);
+
+	pixman_region32_init(&total_damage);
+	pixman_region32_init(&previous_damage);
+
+	pixman_region32_copy(&previous_damage, damage);
+
+	pixman_region32_union(&total_damage, damage, &output->previous_damage);
+	pixman_region32_copy(&output->previous_damage, &previous_damage);
+
+	output->current_image ^= 1;
+
+	output->next = output->dumb[output->current_image];
+	pixman_renderer_output_set_buffer(&output->base,
+					  output->image[output->current_image]);
+
+	ec->renderer->repaint_output(&output->base, &total_damage);
+
+	pixman_region32_fini(&total_damage);
+	pixman_region32_fini(&previous_damage);
+}
+
+static void
+drm_output_render(struct drm_output *output, pixman_region32_t *damage)
+{
+	struct weston_compositor *c = output->base.compositor;
+	struct drm_backend *b = to_drm_backend(c);
+
+	if (!pixman_region32_not_empty(damage) && output->current) {
+		if (!output->next)
+			output->next = output->current;
+		weston_xlog("no dammage on primary plane, do not repaint it\n");
+		return;
+	} else if (b->use_pixman)
+		drm_output_render_pixman(output, damage);
+	else
+		drm_output_render_gl(output, damage);
+
+	pixman_region32_subtract(&c->primary_plane.damage,
+				 &c->primary_plane.damage, damage);
+}
+
+static void
+drm_output_set_gamma(struct weston_output *output_base,
+		     uint16_t size, uint16_t *r, uint16_t *g, uint16_t *b)
+{
+	int rc;
+	struct drm_output *output = to_drm_output(output_base);
+	struct drm_backend *backend =
+		to_drm_backend(output->base.compositor);
+
+	/* check */
+	if (output_base->gamma_size != size)
+		return;
+	if (!output->original_crtc)
+		return;
+
+	rc = drmModeCrtcSetGamma(backend->drm.fd,
+				 output->crtc_id,
+				 size, r, g, b);
+	if (rc)
+		weston_log("set gamma failed: %m\n");
+}
+
+/* Determine the type of vblank synchronization to use for the output.
+ *
+ * The pipe parameter indicates which CRTC is in use.  Knowing this, we
+ * can determine which vblank sequence type to use for it.  Traditional
+ * cards had only two CRTCs, with CRTC 0 using no special flags, and
+ * CRTC 1 using DRM_VBLANK_SECONDARY.  The first bit of the pipe
+ * parameter indicates this.
+ *
+ * Bits 1-5 of the pipe parameter are 5 bit wide pipe number between
+ * 0-31.  If this is non-zero it indicates we're dealing with a
+ * multi-gpu situation and we need to calculate the vblank sync
+ * using DRM_BLANK_HIGH_CRTC_MASK.
+ */
+static unsigned int
+drm_waitvblank_pipe(struct drm_output *output)
+{
+	if (output->pipe > 1)
+		return (output->pipe << DRM_VBLANK_HIGH_CRTC_SHIFT) &
+				DRM_VBLANK_HIGH_CRTC_MASK;
+	else if (output->pipe > 0)
+		return DRM_VBLANK_SECONDARY;
+	else
+		return 0;
+}
+
+static int
+drm_output_repaint(struct weston_output *output_base,
+		   pixman_region32_t *damage)
+{
+	struct drm_output *output = to_drm_output(output_base);
+	struct drm_backend *backend =
+		to_drm_backend(output->base.compositor);
+	struct drm_sprite *s;
+	struct drm_mode *mode;
+	int ret = 0;
+
+	weston_xlog("%s: output_base=%p\n", __func__, output_base);
+
+	if (output->disable_pending || output->destroy_pending)
+		return -1;
+
+	if (!output->next)
+		drm_output_render(output, damage);
+	if (!output->next)
+		return -1;
+
+	mode = container_of(output->base.current_mode, struct drm_mode, base);
+	if (!output->current ||
+	    output->current->stride != output->next->stride) {
+		weston_xlog(" drmModeSetCrtc output->crtc_id = %d\n", output->crtc_id);
+		ret = drmModeSetCrtc(backend->drm.fd, output->crtc_id,
+				     output->next->fb_id, 0, 0,
+				     &output->connector_id, 1,
+				     &mode->mode_info);
+		if (ret) {
+			weston_log("set mode failed: %m\n");
+			goto err_pageflip;
+		}
+		output_base->set_dpms(output_base, WESTON_DPMS_ON);
+	}
+
+	drm_output_set_cursor(output);
+
+	/*
+	 * Now, update all the sprite surfaces
+	 */
+	wl_list_for_each(s, &backend->sprite_list, link) {
+		uint32_t flags = 0, fb_id = 0;
+		drmVBlank vbl = {
+			.request.type = DRM_VBLANK_RELATIVE | DRM_VBLANK_EVENT,
+			.request.sequence = 1,
+		};
+
+		/* Don't flip planes from other outputs */
+		if (s->output != output)
+			continue;
+
+		if (s->vblank_pending) {
+			weston_xlog(" do not refresh the sprite=%p (currently in processing)\n", s);
+			continue;
+		}
+
+		if (!s->current && !s->next)
+			continue;
+
+		if (s->next && !backend->sprites_hidden)
+			fb_id = s->next->fb_id;
+
+		weston_xlog(" refresh the sprite=%p crtc_id=%d plane_id=%d possible_crtcs=%d fb_id=%d\n",
+				s, output->crtc_id, s->plane_id, s->possible_crtcs, fb_id);
+
+		drmModeObjectSetProperty (backend->drm.fd, s->plane_id, DRM_MODE_OBJECT_PLANE, s->zpos_prop_id, s->zorder);
+		ret = drmModeSetPlane(backend->drm.fd, s->plane_id,
+				      output->crtc_id, fb_id, flags,
+				      s->dest_x, s->dest_y,
+				      s->dest_w, s->dest_h,
+				      s->src_x, s->src_y,
+				      s->src_w, s->src_h);
+		if (ret) {
+			weston_log(" setplane failed: %d: %s\n",
+				ret, strerror(errno));
+			drm_output_release_fb(output, s->next);
+			s->output = NULL;
+			s->next = NULL;
+			s->vblank_pending = false;
+			continue;
+		} else {
+			s->vblank_pending = true;
+		}
+
+		vbl.request.type |= drm_waitvblank_pipe(output);
+
+		if (fb_id) {
+			/* Wait for 2 Vsync in case of interlaced buffer */
+			if (s->next->flags & DRM_MODE_FB_INTERLACED) {
+				weston_log(" interlaced frame vblank\n");
+				vbl.request.sequence = 2;
+			}
+		}
+
+		/*
+		 * Queue a vblank signal so we know when the surface
+		 * becomes active on the display or has been replaced.
+		 */
+		vbl.request.signal = (unsigned long)s;
+		ret = drmWaitVBlank(backend->drm.fd, &vbl);
+		if (ret) {
+			weston_log(" vblank event request failed: %d: %s\n",
+				ret, strerror(errno));
+			s->output = NULL;
+			s->next = NULL;
+			s->vblank_pending = false;
+			continue;
+		}
+
+		output->vblank_pending++;
+	}
+
+	weston_xlog(" drmModePageFlip output->crtc_id = %d\n", output->crtc_id);
+	if (drmModePageFlip(backend->drm.fd, output->crtc_id,
+			    output->next->fb_id,
+			    DRM_MODE_PAGE_FLIP_EVENT, output) < 0) {
+		weston_log("queueing pageflip failed: %m\n");
+		goto err_pageflip;
+	}
+
+	output->page_flip_pending = 1;
+
+	return 0;
+
+err_pageflip:
+	output->cursor_view = NULL;
+	if (output->next) {
+		drm_output_release_fb(output, output->next);
+		output->next = NULL;
+	}
+
+	return -1;
+}
+
+static void
+drm_output_start_repaint_loop(struct weston_output *output_base)
+{
+	struct drm_output *output = to_drm_output(output_base);
+	struct drm_backend *backend =
+		to_drm_backend(output_base->compositor);
+	uint32_t fb_id;
+	struct timespec ts, tnow;
+	struct timespec vbl2now;
+	int64_t refresh_nsec;
+	int ret;
+	drmVBlank vbl = {
+		.request.type = DRM_VBLANK_RELATIVE,
+		.request.sequence = 0,
+		.request.signal = 0,
+	};
+
+	if (output->disable_pending || output->destroy_pending)
+		return;
+
+	if (!output->current) {
+		/* We can't page flip if there's no mode set */
+		goto finish_frame;
+	}
+
+	/* Try to get current msc and timestamp via instant query */
+	vbl.request.type |= drm_waitvblank_pipe(output);
+	ret = drmWaitVBlank(backend->drm.fd, &vbl);
+
+	/* Error ret or zero timestamp means failure to get valid timestamp */
+	if ((ret == 0) && (vbl.reply.tval_sec > 0 || vbl.reply.tval_usec > 0)) {
+		ts.tv_sec = vbl.reply.tval_sec;
+		ts.tv_nsec = vbl.reply.tval_usec * 1000;
+
+		/* Valid timestamp for most recent vblank - not stale?
+		 * Stale ts could happen on Linux 3.17+, so make sure it
+		 * is not older than 1 refresh duration since now.
+		 */
+		weston_compositor_read_presentation_clock(backend->compositor,
+							  &tnow);
+		timespec_sub(&vbl2now, &tnow, &ts);
+		refresh_nsec =
+			millihz_to_nsec(output->base.current_mode->refresh);
+		if (timespec_to_nsec(&vbl2now) < refresh_nsec) {
+			drm_output_update_msc(output, vbl.reply.sequence);
+			weston_output_finish_frame(output_base, &ts,
+						WP_PRESENTATION_FEEDBACK_INVALID);
+			return;
+		}
+	}
+
+	/* Immediate query didn't provide valid timestamp.
+	 * Use pageflip fallback.
+	 */
+	fb_id = output->current->fb_id;
+
+	if (drmModePageFlip(backend->drm.fd, output->crtc_id, fb_id,
+			    DRM_MODE_PAGE_FLIP_EVENT, output) < 0) {
+		weston_log("queueing pageflip failed: %m\n");
+		goto finish_frame;
+	}
+
+	return;
+
+finish_frame:
+	/* if we cannot page-flip, immediately finish frame */
+	weston_compositor_read_presentation_clock(output_base->compositor, &ts);
+	weston_output_finish_frame(output_base, &ts,
+				   WP_PRESENTATION_FEEDBACK_INVALID);
+}
+
+static void
+drm_output_update_msc(struct drm_output *output, unsigned int seq)
+{
+	uint64_t msc_hi = output->base.msc >> 32;
+
+	if (seq < (output->base.msc & 0xffffffff))
+		msc_hi++;
+
+	output->base.msc = (msc_hi << 32) + seq;
+}
+
+static void
+vblank_handler(int fd, unsigned int frame, unsigned int sec, unsigned int usec,
+	       void *data)
+{
+	struct drm_sprite *s = (struct drm_sprite *)data;
+	struct drm_output *output = s->output;
+	struct timespec ts;
+	uint32_t flags = WP_PRESENTATION_FEEDBACK_KIND_HW_COMPLETION |
+			 WP_PRESENTATION_FEEDBACK_KIND_HW_CLOCK;
+
+	drm_output_update_msc(output, frame);
+	output->vblank_pending--;
+
+	drm_output_release_fb(output, s->current);
+
+	if (!s->next) {
+		/* Sprite is no more used by the output */
+		s->output = NULL;
+	}
+
+	s->current = s->next;
+	s->next = NULL;
+	s->vblank_pending = false;
+
+	if (!output->vblank_pending && !output->page_flip_pending) {
+		ts.tv_sec = sec;
+		ts.tv_nsec = usec * 1000;
+		weston_output_finish_frame(&output->base, &ts, flags);
+	}
+}
+
+static void
+drm_output_destroy(struct weston_output *base);
+
+static void
+page_flip_handler(int fd, unsigned int frame,
+		  unsigned int sec, unsigned int usec, void *data)
+{
+	struct drm_output *output = data;
+	struct timespec ts;
+	uint32_t flags = WP_PRESENTATION_FEEDBACK_KIND_VSYNC |
+			 WP_PRESENTATION_FEEDBACK_KIND_HW_COMPLETION |
+			 WP_PRESENTATION_FEEDBACK_KIND_HW_CLOCK;
+
+	drm_output_update_msc(output, frame);
+
+	weston_xlog("%s: crtc_id=%d (sec=%d usec=%d)\n",
+			__func__, output->crtc_id, sec, usec);
+
+	/* We don't set page_flip_pending on start_repaint_loop, in that case
+	 * we just want to page flip to the current buffer to get an accurate
+	 * timestamp */
+	if (output->page_flip_pending) {
+		if (output->current != output->next)
+			drm_output_release_fb(output, output->current);
+		output->current = output->next;
+		output->next = NULL;
+	}
+
+	output->page_flip_pending = 0;
+
+	if (output->destroy_pending)
+		drm_output_destroy(&output->base);
+	else if (output->disable_pending)
+		weston_output_disable(&output->base);
+	else if (!output->vblank_pending) {
+		ts.tv_sec = sec;
+		ts.tv_nsec = usec * 1000;
+		weston_output_finish_frame(&output->base, &ts, flags);
+
+		/* We can't call this from frame_notify, because the output's
+		 * repaint needed flag is cleared just after that */
+		if (output->recorder)
+			weston_output_schedule_repaint(&output->base);
+	}
+}
+
+static uint32_t
+drm_output_check_sprite_format(struct drm_sprite *s,
+			       struct weston_view *ev, struct gbm_bo *bo)
+{
+	uint32_t i, format;
+
+	format = gbm_bo_get_format(bo);
+
+	if (format == GBM_FORMAT_ARGB8888) {
+		pixman_region32_t r;
+
+		pixman_region32_init_rect(&r, 0, 0,
+					  ev->surface->width,
+					  ev->surface->height);
+		pixman_region32_subtract(&r, &r, &ev->surface->opaque);
+
+		if (!pixman_region32_not_empty(&r))
+			format = GBM_FORMAT_XRGB8888;
+
+		pixman_region32_fini(&r);
+	}
+
+	for (i = 0; i < s->count_formats; i++)
+		if (s->formats[i] == format)
+			return format;
+
+	return 0;
+}
+
+static int
+drm_view_transform_supported(struct weston_view *ev)
+{
+	return !ev->transform.enabled ||
+		(ev->transform.matrix.type < WESTON_MATRIX_TRANSFORM_ROTATE);
+}
+
+static struct weston_plane *
+drm_output_prepare_overlay_view(struct drm_output *output,
+				struct weston_view *ev, int zorder)
+{
+	struct weston_compositor *ec = output->base.compositor;
+	struct drm_backend *b = to_drm_backend(ec);
+	struct weston_buffer_viewport *viewport = &ev->surface->buffer_viewport;
+	struct wl_resource *buffer_resource;
+	struct drm_sprite *s;
+	struct linux_dmabuf_buffer *dmabuf = NULL;
+	int found = 0, format_ok;
+	struct gbm_bo *bo= NULL;
+	pixman_region32_t dest_rect, src_rect;
+	pixman_box32_t *box, tbox;
+	uint32_t format = 0;
+	wl_fixed_t sx1, sy1, sx2, sy2;
+	uint64_t src_x, src_y, src_w, src_h;
+
+	weston_xlog("   %s: output_base->id = %d\n", __func__, output->base.id);
+
+	if ((b->gbm == NULL) && !b->use_pixman)
+		goto no_overlay;
+
+	if (ev->surface->buffer_ref.buffer == NULL)
+		goto no_overlay;
+
+	buffer_resource = ev->surface->buffer_ref.buffer->resource;
+
+	if (wl_shm_buffer_get(buffer_resource)) {
+		weston_xlog("    shm buffer => could not be assigned to a plane\n");
+		goto no_overlay;
+	}
+
+	if ((dmabuf = linux_dmabuf_buffer_get(buffer_resource))) {
+		weston_xlog("    overlay check: surf=%p weston_buff=%p (dmabuf)\n",
+				ev->surface, ev->surface->buffer_ref.buffer);
+	} else if ((bo = gbm_bo_import(b->gbm, GBM_BO_IMPORT_WL_BUFFER, buffer_resource, GBM_BO_USE_SCANOUT))) {
+		weston_xlog("    overlay check: surf=%p weston_buff=%p (gbm_bo)\n",
+				ev->surface, ev->surface->buffer_ref.buffer);
+	} else {
+		weston_xlog("    not a dmabuf nor gbm_bo => could not be assigned to a plane\n");
+		goto no_overlay;
+	}
+
+	if (viewport->buffer.transform != output->base.transform) {
+		weston_xlog("    transform\n");
+		goto no_overlay;
+	}
+
+	if (viewport->buffer.scale != output->base.current_scale) {
+		weston_xlog("    scale\n");
+		goto no_overlay;
+	}
+
+	if (b->sprites_are_broken) {
+		weston_xlog("    sprites are broken\n");
+		goto no_overlay;
+	}
+
+	if (ev->output_mask != (1u << output->base.id)) {
+		weston_xlog("    surface is out of the refresh area\n");
+		goto no_overlay;
+	}
+
+	if (ev->alpha < 0.99f) {
+		weston_xlog("    overlay check: alpha not ~1.0: %f\n", ev->alpha);
+		goto no_overlay;
+	}
+
+	if (!drm_view_transform_supported(ev)) {
+		weston_xlog("    overlay check: transform not supported\n");
+		goto no_overlay;
+	}
+
+	if (dmabuf) {
+		format = dmabuf->attributes.format;
+		if (format == 0) {
+			weston_xlog("    overlay check: dmabuf format not supported\n");
+			goto no_overlay;
+		}
+	}
+
+	wl_list_for_each(s, &b->sprite_list, link) {
+		if (!drm_sprite_crtc_supported(output, s->possible_crtcs))
+			continue;
+
+		if ((s->output != output) && (s->output != NULL))
+			continue;
+
+		/* Compare format with the formats of THIS sprite */
+		uint32_t i;
+		format_ok = 0;
+		if (dmabuf) {
+			for (i = 0; i < s->count_formats; i++)
+				if (s->formats[i] == format)
+					format_ok = 1;
+		} else {
+			format = drm_output_check_sprite_format(s, ev, bo);
+			if (format)
+				format_ok = 1;
+		}
+
+		if (s->vblank_pending && format_ok) {
+			weston_xlog("    sprite is currently being rendered\n");
+			goto no_overlay;
+		}
+
+		if ((!s->next) && format_ok) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (bo && format == 0) {
+		weston_xlog("    overlay check: bo format not supported\n");
+		goto no_overlay;
+	}
+
+	/* No sprites available */
+	if (!found) {
+		weston_xlog("    no sprite available\n");
+		goto no_overlay;
+	}
+
+	if (dmabuf) {
+		s->next = drm_fb_get_from_dmabuf(dmabuf, b, format);
+		if (!s->next) {
+			weston_xlog("    overlay check: to FB failed\n");
+			goto no_overlay;
+		}
+		weston_xlog("    got dmabuf handle %d (s->plane_id= 0x%x)\n",
+				s->next->handle, s->plane_id);
+	} else if (bo) {
+		s->next = drm_fb_get_from_bo(bo, b, format);
+		if (!s->next) {
+			gbm_bo_destroy(bo);
+			weston_xlog("    overlay check: to FB failed\n");
+			goto no_overlay;
+		}
+	}
+
+	drm_fb_set_buffer(s->next, ev->surface->buffer_ref.buffer);
+
+	/* Sprite is associated to an output */
+	s->output = output;
+
+	box = pixman_region32_extents(&ev->transform.boundingbox);
+	s->plane.x = box->x1;
+	s->plane.y = box->y1;
+
+	s->zorder = zorder;
+
+	/*
+	 * Calculate the source & dest rects properly based on actual
+	 * position (note the caller has called weston_view_update_transform()
+	 * for us already).
+	 */
+	pixman_region32_init(&dest_rect);
+	pixman_region32_intersect(&dest_rect, &ev->transform.boundingbox,
+				  &output->base.region);
+	pixman_region32_translate(&dest_rect, -output->base.x, -output->base.y);
+	box = pixman_region32_extents(&dest_rect);
+	tbox = weston_transformed_rect(output->base.width,
+				       output->base.height,
+				       output->base.transform,
+				       output->base.current_scale,
+				       *box);
+	s->dest_x = tbox.x1;
+	s->dest_y = tbox.y1;
+	s->dest_w = tbox.x2 - tbox.x1;
+	s->dest_h = tbox.y2 - tbox.y1;
+	pixman_region32_fini(&dest_rect);
+
+	pixman_region32_init(&src_rect);
+	pixman_region32_intersect(&src_rect, &ev->transform.boundingbox,
+				  &output->base.region);
+	box = pixman_region32_extents(&src_rect);
+
+	weston_view_from_global_fixed(ev,
+				      wl_fixed_from_int(box->x1),
+				      wl_fixed_from_int(box->y1),
+				      &sx1, &sy1);
+	weston_view_from_global_fixed(ev,
+				      wl_fixed_from_int(box->x2),
+				      wl_fixed_from_int(box->y2),
+				      &sx2, &sy2);
+
+	if (sx1 < 0)
+		sx1 = 0;
+	if (sy1 < 0)
+		sy1 = 0;
+	if (sx2 > wl_fixed_from_int(ev->surface->width))
+		sx2 = wl_fixed_from_int(ev->surface->width);
+	if (sy2 > wl_fixed_from_int(ev->surface->height))
+		sy2 = wl_fixed_from_int(ev->surface->height);
+
+	tbox.x1 = sx1;
+	tbox.y1 = sy1;
+	tbox.x2 = sx2;
+	tbox.y2 = sy2;
+
+	tbox = weston_transformed_rect(wl_fixed_from_int(ev->surface->width),
+				       wl_fixed_from_int(ev->surface->height),
+				       viewport->buffer.transform,
+				       viewport->buffer.scale,
+				       tbox);
+
+	src_x = tbox.x1;
+	src_y = tbox.y1;
+	src_w = (tbox.x2 - tbox.x1);
+	src_h = (tbox.y2 - tbox.y1);
+
+	src_x = (src_x * ev->surface->width_from_buffer) / ev->surface->width;
+	src_w = (src_w * ev->surface->width_from_buffer) / ev->surface->width;
+	src_y = (src_y * ev->surface->height_from_buffer) / ev->surface->height;
+	src_h = (src_h * ev->surface->height_from_buffer) / ev->surface->height;
+
+	s->src_x = src_x << 8;
+	s->src_y = src_y << 8;
+	s->src_w = src_w << 8;
+	s->src_h = src_h << 8;
+	pixman_region32_fini(&src_rect);
+
+	return &s->plane;
+
+no_overlay:
+	if (bo)
+		gbm_bo_destroy(bo);
+
+	return NULL;
+}
+
+static struct weston_plane *
+drm_output_prepare_cursor_view(struct drm_output *output,
+			       struct weston_view *ev)
+{
+	struct drm_backend *b = to_drm_backend(output->base.compositor);
+	struct weston_buffer_viewport *viewport = &ev->surface->buffer_viewport;
+	struct wl_shm_buffer *shmbuf;
+
+	weston_xlog("   %s: output_base->id = %d\n", __func__, output->base.id);
+
+	if (ev->transform.enabled &&
+	    (ev->transform.matrix.type > WESTON_MATRIX_TRANSFORM_TRANSLATE)) {
+		weston_xlog("    cursor KO: transform_translate\n");
+		return NULL;
+	}
+	if (b->gbm == NULL) {
+		weston_xlog("    cursor KO: gbm\n");
+		return NULL;
+	}
+	if (output->base.transform != WL_OUTPUT_TRANSFORM_NORMAL) {
+		weston_xlog("    cursor KO: transform\n");
+		return NULL;
+	}
+	if (viewport->buffer.scale != output->base.current_scale) {
+		weston_xlog("    cursor KO: scale\n");
+		return NULL;
+	}
+	if (output->cursor_view) {
+		weston_xlog("    cursor KO: cursor_view\n");
+		return NULL;
+	}
+	if (ev->output_mask != (1u << output->base.id)) {
+		weston_xlog("    cursor KO: mask\n");
+		return NULL;
+	}
+	if (b->cursors_are_broken[output->base.id]) {
+		weston_xlog("    cursor KO: broken\n");
+		return NULL;
+	}
+	if (ev->geometry.scissor_enabled) {
+		weston_xlog("    cursor KO: scissor\n");
+		return NULL;
+	}
+	if (ev->surface->buffer_ref.buffer == NULL) {
+		weston_xlog("    cursor KO: buffer\n");
+		return NULL;
+	}
+	shmbuf = wl_shm_buffer_get(ev->surface->buffer_ref.buffer->resource);
+	if (!shmbuf) {
+		weston_xlog("    cursor KO: shmbuf\n");
+		return NULL;
+	}
+	if (wl_shm_buffer_get_format(shmbuf) != WL_SHM_FORMAT_ARGB8888) {
+		weston_xlog("    cursor KO: format\n");
+		return NULL;
+	}
+	if (ev->surface->width > b->cursor_width ||
+	    ev->surface->height > b->cursor_height) {
+		weston_xlog("    cursor KO: size\n");
+		return NULL;
+	}
+
+	output->cursor_view = ev;
+
+	return &output->cursor_plane;
+}
+
+/**
+ * Update the image for the current cursor surface
+ *
+ * @param b DRM backend structure
+ * @param bo GBM buffer object to write into
+ * @param ev View to use for cursor image
+ */
+static void
+cursor_bo_update(struct drm_backend *b, struct gbm_bo *bo,
+		 struct weston_view *ev)
+{
+	struct weston_buffer *buffer = ev->surface->buffer_ref.buffer;
+	uint32_t buf[b->cursor_width * b->cursor_height];
+	int32_t stride;
+	uint8_t *s;
+	int i;
+
+	assert(buffer && buffer->shm_buffer);
+	assert(buffer->shm_buffer == wl_shm_buffer_get(buffer->resource));
+	assert(ev->surface->width <= b->cursor_width);
+	assert(ev->surface->height <= b->cursor_height);
+
+	memset(buf, 0, sizeof buf);
+	stride = wl_shm_buffer_get_stride(buffer->shm_buffer);
+	s = wl_shm_buffer_get_data(buffer->shm_buffer);
+
+	wl_shm_buffer_begin_access(buffer->shm_buffer);
+	for (i = 0; i < ev->surface->height; i++)
+		memcpy(buf + i * b->cursor_width,
+		       s + i * stride,
+		       ev->surface->width * 4);
+	wl_shm_buffer_end_access(buffer->shm_buffer);
+
+	if (gbm_bo_write(bo, buf, sizeof buf) < 0)
+		weston_log("failed update cursor: %m\n");
+}
+
+static void
+drm_output_set_cursor(struct drm_output *output)
+{
+	struct weston_view *ev = output->cursor_view;
+	struct weston_buffer *buffer;
+	struct drm_backend *b = to_drm_backend(output->base.compositor);
+	EGLint handle;
+	struct gbm_bo *bo;
+	float x, y;
+
+	output->cursor_view = NULL;
+	if (ev == NULL) {
+		drmModeSetCursor(b->drm.fd, output->crtc_id, 0, 0, 0);
+		output->cursor_plane.x = INT32_MIN;
+		output->cursor_plane.y = INT32_MIN;
+		return;
+	}
+
+	buffer = ev->surface->buffer_ref.buffer;
+
+	if (buffer &&
+	    pixman_region32_not_empty(&output->cursor_plane.damage)) {
+		pixman_region32_fini(&output->cursor_plane.damage);
+		pixman_region32_init(&output->cursor_plane.damage);
+		output->current_cursor ^= 1;
+		bo = output->gbm_cursor_bo[output->current_cursor];
+
+		cursor_bo_update(b, bo, ev);
+		handle = gbm_bo_get_handle(bo).s32;
+		if (drmModeSetCursor(b->drm.fd, output->crtc_id, handle,
+				b->cursor_width, b->cursor_height)) {
+			weston_log("failed to set cursor: %m\n");
+			b->cursors_are_broken[output->base.id] = 1;
+		}
+	}
+
+	weston_view_to_global_float(ev, 0, 0, &x, &y);
+
+	/* From global to output space, output transform is guaranteed to be
+	 * NORMAL by drm_output_prepare_cursor_view().
+	 */
+	x = (x - output->base.x) * output->base.current_scale;
+	y = (y - output->base.y) * output->base.current_scale;
+
+	if (output->cursor_plane.x != x || output->cursor_plane.y != y) {
+		if (drmModeMoveCursor(b->drm.fd, output->crtc_id, x, y)) {
+			weston_log("failed to move cursor: %m\n");
+			b->cursors_are_broken[output->base.id] = 1;
+		}
+
+		output->cursor_plane.x = x;
+		output->cursor_plane.y = y;
+	}
+}
+
+static void
+drm_assign_planes(struct weston_output *output_base)
+{
+	struct drm_backend *b = to_drm_backend(output_base->compositor);
+	struct drm_output *output = to_drm_output(output_base);
+	struct weston_view *ev, *next;
+	pixman_region32_t overlap, surface_overlap;
+	struct weston_plane *primary, *next_plane;
+	int i = 0;
+	int zorder = ZORDER_MAX;
+
+	weston_xlog("%s: output=%p\n", __func__, output);
+
+	/*
+	 * Find a surface for each sprite in the output using some heuristics:
+	 * 1) size
+	 * 2) frequency of update
+	 * 3) opacity (though some hw might support alpha blending)
+	 * 4) clipping (this can be fixed with color keys)
+	 *
+	 * The idea is to save on blitting since this should save power.
+	 * If we can get a large video surface on the sprite for example,
+	 * the main display surface may not need to update at all, and
+	 * the client buffer can be used directly for the sprite surface
+	 * as we do for flipping full screen surfaces.
+	 */
+	pixman_region32_init(&overlap);
+	primary = &output_base->compositor->primary_plane;
+
+	wl_list_for_each_safe(ev, next, &output_base->compositor->view_list, link) {
+		struct weston_surface *es = ev->surface;
+		weston_xlog(" assigning surface %d %p (%dx%d)...\n", i, es,
+				ev->surface->width, ev->surface->height);
+		i++;
+
+		/* Ignore the ugly waylandsink 1x1 "area surface" */
+		if (ev->surface->width_from_buffer == 1) {
+			weston_xlog(" ...surface is ignored (1x1)\n");
+			continue;
+		}
+
+		/* Test whether this buffer can ever go into a plane:
+		 * non-shm, or small enough to be a cursor or dmabuf.
+		 *
+		 * Also, keep a reference when using the pixman renderer.
+		 * That makes it possible to do a seamless switch to the GL
+		 * renderer and since the pixman renderer keeps a reference
+		 * to the buffer anyway, there is no side effects.
+		 */
+		if (b->use_pixman ||
+		    (es->buffer_ref.buffer &&
+		    (!wl_shm_buffer_get(es->buffer_ref.buffer->resource) ||
+		     (ev->surface->width <= b->cursor_width &&
+		      ev->surface->height <= b->cursor_height) ||
+		     linux_dmabuf_buffer_get(es->buffer_ref.buffer->resource))))
+			es->keep_buffer = true;
+		else
+			es->keep_buffer = false;
+
+		pixman_region32_init(&surface_overlap);
+		pixman_region32_intersect(&surface_overlap, &overlap,
+					  &ev->transform.boundingbox);
+
+		next_plane = NULL;
+		if (pixman_region32_not_empty(&surface_overlap)) {
+			next_plane = primary;
+			if (next_plane)
+				weston_xlog(" ...assigned to primary (cause=overlap)\n");
+		}
+
+		if (next_plane == NULL) {
+			next_plane = drm_output_prepare_cursor_view(output, ev);
+			if (next_plane)
+				weston_xlog(" ...assigned to cursor\n");
+		}
+
+		if (next_plane == NULL) {
+			next_plane = drm_output_prepare_scanout_view(output, ev);
+			if (next_plane)
+				weston_xlog(" ...assigned to scanout\n");
+		}
+
+		if (next_plane == NULL) {
+			next_plane = drm_output_prepare_overlay_view(output, ev, zorder--);
+			if (next_plane)
+				weston_xlog(" ...assigned to overlay\n");
+		}
+
+		if (next_plane == NULL) {
+			next_plane = primary;
+			weston_xlog(" ...assigned to primary (default)\n");
+		}
+
+		weston_view_move_to_plane(ev, next_plane);
+
+		if (next_plane == primary)
+			pixman_region32_union(&overlap, &overlap,
+					      &ev->transform.boundingbox);
+
+		if (next_plane == primary ||
+		    next_plane == &output->cursor_plane) {
+			/* cursor plane involves a copy */
+			ev->psf_flags = 0;
+		} else {
+			/* All other planes are a direct scanout of a
+			 * single client buffer.
+			 */
+			ev->psf_flags = WP_PRESENTATION_FEEDBACK_KIND_ZERO_COPY;
+		}
+
+		pixman_region32_fini(&surface_overlap);
+	}
+	pixman_region32_fini(&overlap);
+}
+
+static void
+drm_output_fini_pixman(struct drm_output *output);
+
+/**
+ * Find the closest-matching mode for a given target
+ *
+ * Given a target mode, find the most suitable mode amongst the output's
+ * current mode list to use, preferring the current mode if possible, to
+ * avoid an expensive mode switch.
+ *
+ * @param output DRM output
+ * @param target_mode Mode to attempt to match
+ * @returns Pointer to a mode from the output's mode list
+ */
+static struct drm_mode *
+choose_mode (struct drm_output *output, struct weston_mode *target_mode)
+{
+	struct drm_mode *tmp_mode = NULL, *mode;
+
+	if (output->base.current_mode->width == target_mode->width &&
+	    output->base.current_mode->height == target_mode->height &&
+	    (output->base.current_mode->refresh == target_mode->refresh ||
+	     target_mode->refresh == 0))
+		return (struct drm_mode *)output->base.current_mode;
+
+	wl_list_for_each(mode, &output->base.mode_list, base.link) {
+		if (mode->mode_info.hdisplay == target_mode->width &&
+		    mode->mode_info.vdisplay == target_mode->height) {
+			if (mode->base.refresh == target_mode->refresh ||
+			    target_mode->refresh == 0) {
+				return mode;
+			} else if (!tmp_mode)
+				tmp_mode = mode;
+		}
+	}
+
+	return tmp_mode;
+}
+
+static int
+drm_output_init_egl(struct drm_output *output, struct drm_backend *b);
+static int
+drm_output_init_pixman(struct drm_output *output, struct drm_backend *b);
+
+static int
+drm_output_switch_mode(struct weston_output *output_base, struct weston_mode *mode)
+{
+	struct drm_output *output;
+	struct drm_mode *drm_mode;
+	struct drm_backend *b;
+
+	if (output_base == NULL) {
+		weston_log("output is NULL.\n");
+		return -1;
+	}
+
+	if (mode == NULL) {
+		weston_log("mode is NULL.\n");
+		return -1;
+	}
+
+	b = to_drm_backend(output_base->compositor);
+	output = to_drm_output(output_base);
+	drm_mode  = choose_mode (output, mode);
+
+	if (!drm_mode) {
+		weston_log("%s, invalid resolution:%dx%d\n", __func__, mode->width, mode->height);
+		return -1;
+	}
+
+	if (&drm_mode->base == output->base.current_mode)
+		return 0;
+
+	output->base.current_mode->flags = 0;
+
+	output->base.current_mode = &drm_mode->base;
+	output->base.current_mode->flags =
+		WL_OUTPUT_MODE_CURRENT | WL_OUTPUT_MODE_PREFERRED;
+
+	/* reset rendering stuff. */
+	drm_output_release_fb(output, output->current);
+	drm_output_release_fb(output, output->next);
+	output->current = output->next = NULL;
+
+	if (b->use_pixman) {
+		drm_output_fini_pixman(output);
+		if (drm_output_init_pixman(output, b) < 0) {
+			weston_log("failed to init output pixman state with "
+				   "new mode\n");
+			return -1;
+		}
+	} else {
+		gl_renderer->output_destroy(&output->base);
+		gbm_surface_destroy(output->gbm_surface);
+
+		if (drm_output_init_egl(output, b) < 0) {
+			weston_log("failed to init output egl state with "
+				   "new mode");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int
+on_drm_input(int fd, uint32_t mask, void *data)
+{
+	drmEventContext evctx;
+
+	memset(&evctx, 0, sizeof evctx);
+	evctx.version = DRM_EVENT_CONTEXT_VERSION;
+	evctx.page_flip_handler = page_flip_handler;
+	evctx.vblank_handler = vblank_handler;
+	drmHandleEvent(fd, &evctx);
+
+	return 1;
+}
+
+static int
+init_drm(struct drm_backend *b, struct udev_device *device)
+{
+	const char *filename, *sysnum;
+	uint64_t cap;
+	int fd, ret;
+	clockid_t clk_id;
+
+	sysnum = udev_device_get_sysnum(device);
+	if (sysnum)
+		b->drm.id = atoi(sysnum);
+	if (!sysnum || b->drm.id < 0) {
+		weston_log("cannot get device sysnum\n");
+		return -1;
+	}
+
+	filename = udev_device_get_devnode(device);
+	fd = weston_launcher_open(b->compositor->launcher, filename, O_RDWR);
+	if (fd < 0) {
+		/* Probably permissions error */
+		weston_log("couldn't open %s, skipping\n",
+			udev_device_get_devnode(device));
+		return -1;
+	}
+
+	weston_log("using %s\n", filename);
+
+	b->drm.fd = fd;
+	b->drm.filename = strdup(filename);
+
+	ret = drmGetCap(fd, DRM_CAP_TIMESTAMP_MONOTONIC, &cap);
+	if (ret == 0 && cap == 1)
+		clk_id = CLOCK_MONOTONIC;
+	else
+		clk_id = CLOCK_REALTIME;
+
+	if (weston_compositor_set_presentation_clock(b->compositor, clk_id) < 0) {
+		weston_log("Error: failed to set presentation clock %d.\n",
+			   clk_id);
+		return -1;
+	}
+
+	ret = drmGetCap(fd, DRM_CAP_CURSOR_WIDTH, &cap);
+	if (ret == 0)
+		b->cursor_width = cap;
+	else
+		b->cursor_width = 64;
+
+	ret = drmGetCap(fd, DRM_CAP_CURSOR_HEIGHT, &cap);
+	if (ret == 0)
+		b->cursor_height = cap;
+	else
+		b->cursor_height = 64;
+
+	return 0;
+}
+
+static struct gbm_device *
+create_gbm_device(int fd)
+{
+	struct gbm_device *gbm;
+
+	gl_renderer = weston_load_module("gl-renderer.so",
+					 "gl_renderer_interface");
+	if (!gl_renderer)
+		return NULL;
+
+	/* GBM will load a dri driver, but even though they need symbols from
+	 * libglapi, in some version of Mesa they are not linked to it. Since
+	 * only the gl-renderer module links to it, the call above won't make
+	 * these symbols globally available, and loading the DRI driver fails.
+	 * Workaround this by dlopen()'ing libglapi with RTLD_GLOBAL. */
+	dlopen("libglapi.so.0", RTLD_LAZY | RTLD_GLOBAL);
+
+	gbm = gbm_create_device(fd);
+
+	return gbm;
+}
+
+/* When initializing EGL, if the preferred buffer format isn't available
+ * we may be able to substitute an ARGB format for an XRGB one.
+ *
+ * This returns 0 if substitution isn't possible, but 0 might be a
+ * legitimate format for other EGL platforms, so the caller is
+ * responsible for checking for 0 before calling gl_renderer->create().
+ *
+ * This works around https://bugs.freedesktop.org/show_bug.cgi?id=89689
+ * but it's entirely possible we'll see this again on other implementations.
+ */
+static int
+fallback_format_for(uint32_t format)
+{
+	switch (format) {
+	case GBM_FORMAT_XRGB8888:
+		return GBM_FORMAT_ARGB8888;
+	case GBM_FORMAT_XRGB2101010:
+		return GBM_FORMAT_ARGB2101010;
+	default:
+		return 0;
+	}
+}
+
+static int
+drm_backend_create_gl_renderer(struct drm_backend *b)
+{
+	EGLint format[3] = {
+		b->gbm_format,
+		fallback_format_for(b->gbm_format),
+		0,
+	};
+	int n_formats = 2;
+
+	if (format[1])
+		n_formats = 3;
+	if (gl_renderer->create(b->compositor,
+				EGL_PLATFORM_GBM_KHR,
+				(void *)b->gbm,
+				gl_renderer->opaque_attribs,
+				format,
+				n_formats) < 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+init_egl(struct drm_backend *b)
+{
+	b->gbm = create_gbm_device(b->drm.fd);
+
+	if (!b->gbm)
+		return -1;
+
+	if (drm_backend_create_gl_renderer(b) < 0) {
+		gbm_device_destroy(b->gbm);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+init_pixman(struct drm_backend *b)
+{
+	return pixman_renderer_init(b->compositor);
+}
+
+/**
+ * Add a mode to output's mode list
+ *
+ * Copy the supplied DRM mode into a Weston mode structure, and add it to the
+ * output's mode list.
+ *
+ * @param output DRM output to add mode to
+ * @param info DRM mode structure to add
+ * @returns Newly-allocated Weston/DRM mode structure
+ */
+static struct drm_mode *
+drm_output_add_mode(struct drm_output *output, const drmModeModeInfo *info)
+{
+	struct drm_mode *mode;
+	uint64_t refresh;
+
+	mode = malloc(sizeof *mode);
+	if (mode == NULL)
+		return NULL;
+
+	mode->base.flags = 0;
+	mode->base.width = info->hdisplay;
+	mode->base.height = info->vdisplay;
+
+	/* Calculate higher precision (mHz) refresh rate */
+	refresh = (info->clock * 1000000LL / info->htotal +
+		   info->vtotal / 2) / info->vtotal;
+
+	if (info->flags & DRM_MODE_FLAG_INTERLACE)
+		refresh *= 2;
+	if (info->flags & DRM_MODE_FLAG_DBLSCAN)
+		refresh /= 2;
+	if (info->vscan > 1)
+	    refresh /= info->vscan;
+
+	mode->base.refresh = refresh;
+	mode->mode_info = *info;
+
+	if (info->type & DRM_MODE_TYPE_PREFERRED)
+		mode->base.flags |= WL_OUTPUT_MODE_PREFERRED;
+
+	wl_list_insert(output->base.mode_list.prev, &mode->base.link);
+
+	return mode;
+}
+
+static int
+drm_subpixel_to_wayland(int drm_value)
+{
+	switch (drm_value) {
+	default:
+	case DRM_MODE_SUBPIXEL_UNKNOWN:
+		return WL_OUTPUT_SUBPIXEL_UNKNOWN;
+	case DRM_MODE_SUBPIXEL_NONE:
+		return WL_OUTPUT_SUBPIXEL_NONE;
+	case DRM_MODE_SUBPIXEL_HORIZONTAL_RGB:
+		return WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB;
+	case DRM_MODE_SUBPIXEL_HORIZONTAL_BGR:
+		return WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR;
+	case DRM_MODE_SUBPIXEL_VERTICAL_RGB:
+		return WL_OUTPUT_SUBPIXEL_VERTICAL_RGB;
+	case DRM_MODE_SUBPIXEL_VERTICAL_BGR:
+		return WL_OUTPUT_SUBPIXEL_VERTICAL_BGR;
+	}
+}
+
+/* returns a value between 0-255 range, where higher is brighter */
+static uint32_t
+drm_get_backlight(struct drm_output *output)
+{
+	long brightness, max_brightness, norm;
+
+	brightness = backlight_get_brightness(output->backlight);
+	max_brightness = backlight_get_max_brightness(output->backlight);
+
+	/* convert it on a scale of 0 to 255 */
+	norm = (brightness * 255)/(max_brightness);
+
+	return (uint32_t) norm;
+}
+
+/* values accepted are between 0-255 range */
+static void
+drm_set_backlight(struct weston_output *output_base, uint32_t value)
+{
+	struct drm_output *output = to_drm_output(output_base);
+	long max_brightness, new_brightness;
+
+	if (!output->backlight)
+		return;
+
+	if (value > 255)
+		return;
+
+	max_brightness = backlight_get_max_brightness(output->backlight);
+
+	/* get denormalized value */
+	new_brightness = (value * max_brightness) / 255;
+
+	backlight_set_brightness(output->backlight, new_brightness);
+}
+
+static drmModePropertyPtr
+drm_get_prop(int fd, drmModeConnectorPtr connector, const char *name)
+{
+	drmModePropertyPtr props;
+	int i;
+
+	for (i = 0; i < connector->count_props; i++) {
+		props = drmModeGetProperty(fd, connector->props[i]);
+		if (!props)
+			continue;
+
+		if (!strcmp(props->name, name))
+			return props;
+
+		drmModeFreeProperty(props);
+	}
+
+	return NULL;
+}
+
+static void
+drm_set_dpms(struct weston_output *output_base, enum dpms_enum level)
+{
+	struct drm_output *output = to_drm_output(output_base);
+	struct weston_compositor *ec = output_base->compositor;
+	struct drm_backend *b = to_drm_backend(ec);
+	int ret;
+
+	if (!output->dpms_prop)
+		return;
+
+	ret = drmModeConnectorSetProperty(b->drm.fd, output->connector_id,
+				 	  output->dpms_prop->prop_id, level);
+	if (ret) {
+		weston_log("DRM: DPMS: failed property set for %s\n",
+			   output->base.name);
+		return;
+	}
+
+	output->dpms = level;
+}
+
+static const char * const connector_type_names[] = {
+	[DRM_MODE_CONNECTOR_Unknown]     = "Unknown",
+	[DRM_MODE_CONNECTOR_VGA]         = "VGA",
+	[DRM_MODE_CONNECTOR_DVII]        = "DVI-I",
+	[DRM_MODE_CONNECTOR_DVID]        = "DVI-D",
+	[DRM_MODE_CONNECTOR_DVIA]        = "DVI-A",
+	[DRM_MODE_CONNECTOR_Composite]   = "Composite",
+	[DRM_MODE_CONNECTOR_SVIDEO]      = "SVIDEO",
+	[DRM_MODE_CONNECTOR_LVDS]        = "LVDS",
+	[DRM_MODE_CONNECTOR_Component]   = "Component",
+	[DRM_MODE_CONNECTOR_9PinDIN]     = "DIN",
+	[DRM_MODE_CONNECTOR_DisplayPort] = "DP",
+	[DRM_MODE_CONNECTOR_HDMIA]       = "HDMI-A",
+	[DRM_MODE_CONNECTOR_HDMIB]       = "HDMI-B",
+	[DRM_MODE_CONNECTOR_TV]          = "TV",
+	[DRM_MODE_CONNECTOR_eDP]         = "eDP",
+#ifdef DRM_MODE_CONNECTOR_DSI
+	[DRM_MODE_CONNECTOR_VIRTUAL]     = "Virtual",
+	[DRM_MODE_CONNECTOR_DSI]         = "DSI",
+#endif
+};
+
+static char *
+make_connector_name(const drmModeConnector *con)
+{
+	char name[32];
+	const char *type_name = NULL;
+
+	if (con->connector_type < ARRAY_LENGTH(connector_type_names))
+		type_name = connector_type_names[con->connector_type];
+
+	if (!type_name)
+		type_name = "UNNAMED";
+
+	snprintf(name, sizeof name, "%s-%d", type_name, con->connector_type_id);
+
+	return strdup(name);
+}
+
+static int
+find_crtc_for_connector(struct drm_backend *b,
+			drmModeRes *resources, drmModeConnector *connector)
+{
+	drmModeEncoder *encoder;
+	uint32_t possible_crtcs;
+	int i, j;
+
+	for (j = 0; j < connector->count_encoders; j++) {
+		encoder = drmModeGetEncoder(b->drm.fd, connector->encoders[j]);
+		if (encoder == NULL) {
+			weston_log("Failed to get encoder.\n");
+			return -1;
+		}
+		possible_crtcs = encoder->possible_crtcs;
+		drmModeFreeEncoder(encoder);
+
+		for (i = 0; i < resources->count_crtcs; i++) {
+			if (possible_crtcs & (1 << i) &&
+			    !(b->crtc_allocator & (1 << resources->crtcs[i])))
+				return i;
+		}
+	}
+
+	return -1;
+}
+
+/* Init output state that depends on gl or gbm */
+static int
+drm_output_init_egl(struct drm_output *output, struct drm_backend *b)
+{
+	EGLint format[2] = {
+		output->gbm_format,
+		fallback_format_for(output->gbm_format),
+	};
+	int i, flags, n_formats = 1;
+
+	output->gbm_surface = gbm_surface_create(b->gbm,
+					     output->base.current_mode->width,
+					     output->base.current_mode->height,
+					     format[0],
+					     GBM_BO_USE_SCANOUT |
+					     GBM_BO_USE_RENDERING);
+	if (!output->gbm_surface) {
+		weston_log("failed to create gbm surface\n");
+		return -1;
+	}
+
+	if (format[1])
+		n_formats = 2;
+	if (gl_renderer->output_create(&output->base,
+				       (EGLNativeWindowType)output->gbm_surface,
+				       output->gbm_surface,
+				       gl_renderer->opaque_attribs,
+				       format,
+				       n_formats) < 0) {
+		weston_log("failed to create gl renderer output state\n");
+		gbm_surface_destroy(output->gbm_surface);
+		return -1;
+	}
+
+	flags = GBM_BO_USE_CURSOR | GBM_BO_USE_WRITE;
+
+	for (i = 0; i < 2; i++) {
+		if (output->gbm_cursor_bo[i])
+			continue;
+
+		output->gbm_cursor_bo[i] =
+			gbm_bo_create(b->gbm, b->cursor_width, b->cursor_height,
+				GBM_FORMAT_ARGB8888, flags);
+	}
+
+	if (output->gbm_cursor_bo[0] == NULL || output->gbm_cursor_bo[1] == NULL) {
+		weston_log("cursor buffers unavailable, using gl cursors\n");
+		b->cursors_are_broken[0] = 1;
+	}
+
+	return 0;
+}
+
+static int
+drm_output_init_pixman(struct drm_output *output, struct drm_backend *b)
+{
+	int w = output->base.current_mode->width;
+	int h = output->base.current_mode->height;
+	uint32_t format = output->gbm_format;
+	uint32_t pixman_format;
+	unsigned int i;
+
+	switch (format) {
+		case GBM_FORMAT_XRGB8888:
+			pixman_format = PIXMAN_x8r8g8b8;
+			break;
+		case GBM_FORMAT_RGB565:
+			pixman_format = PIXMAN_r5g6b5;
+			break;
+		default:
+			weston_log("Unsupported pixman format 0x%x\n", format);
+			return -1;
+	}
+
+	/* FIXME error checking */
+	for (i = 0; i < ARRAY_LENGTH(output->dumb); i++) {
+		output->dumb[i] = drm_fb_create_dumb(b, w, h, format);
+		if (!output->dumb[i])
+			goto err;
+
+		output->image[i] =
+			pixman_image_create_bits(pixman_format, w, h,
+						 output->dumb[i]->map,
+						 output->dumb[i]->stride);
+		if (!output->image[i])
+			goto err;
+	}
+
+	if (pixman_renderer_output_create(&output->base) < 0)
+		goto err;
+
+	pixman_region32_init_rect(&output->previous_damage,
+				  output->base.x, output->base.y, output->base.width, output->base.height);
+
+	return 0;
+
+err:
+	for (i = 0; i < ARRAY_LENGTH(output->dumb); i++) {
+		if (output->dumb[i])
+			drm_fb_destroy_dumb(output->dumb[i]);
+		if (output->image[i])
+			pixman_image_unref(output->image[i]);
+
+		output->dumb[i] = NULL;
+		output->image[i] = NULL;
+	}
+
+	return -1;
+}
+
+static void
+drm_output_fini_pixman(struct drm_output *output)
+{
+	unsigned int i;
+
+	pixman_renderer_output_destroy(&output->base);
+	pixman_region32_fini(&output->previous_damage);
+
+	for (i = 0; i < ARRAY_LENGTH(output->dumb); i++) {
+		drm_fb_destroy_dumb(output->dumb[i]);
+		pixman_image_unref(output->image[i]);
+		output->dumb[i] = NULL;
+		output->image[i] = NULL;
+	}
+}
+
+static void
+edid_parse_string(const uint8_t *data, char text[])
+{
+	int i;
+	int replaced = 0;
+
+	/* this is always 12 bytes, but we can't guarantee it's null
+	 * terminated or not junk. */
+	strncpy(text, (const char *) data, 12);
+
+	/* guarantee our new string is null-terminated */
+	text[12] = '\0';
+
+	/* remove insane chars */
+	for (i = 0; text[i] != '\0'; i++) {
+		if (text[i] == '\n' ||
+		    text[i] == '\r') {
+			text[i] = '\0';
+			break;
+		}
+	}
+
+	/* ensure string is printable */
+	for (i = 0; text[i] != '\0'; i++) {
+		if (!isprint(text[i])) {
+			text[i] = '-';
+			replaced++;
+		}
+	}
+
+	/* if the string is random junk, ignore the string */
+	if (replaced > 4)
+		text[0] = '\0';
+}
+
+#define EDID_DESCRIPTOR_ALPHANUMERIC_DATA_STRING	0xfe
+#define EDID_DESCRIPTOR_DISPLAY_PRODUCT_NAME		0xfc
+#define EDID_DESCRIPTOR_DISPLAY_PRODUCT_SERIAL_NUMBER	0xff
+#define EDID_OFFSET_DATA_BLOCKS				0x36
+#define EDID_OFFSET_LAST_BLOCK				0x6c
+#define EDID_OFFSET_PNPID				0x08
+#define EDID_OFFSET_SERIAL				0x0c
+
+static int
+edid_parse(struct drm_edid *edid, const uint8_t *data, size_t length)
+{
+	int i;
+	uint32_t serial_number;
+
+	/* check header */
+	if (length < 128)
+		return -1;
+	if (data[0] != 0x00 || data[1] != 0xff)
+		return -1;
+
+	/* decode the PNP ID from three 5 bit words packed into 2 bytes
+	 * /--08--\/--09--\
+	 * 7654321076543210
+	 * |\---/\---/\---/
+	 * R  C1   C2   C3 */
+	edid->pnp_id[0] = 'A' + ((data[EDID_OFFSET_PNPID + 0] & 0x7c) / 4) - 1;
+	edid->pnp_id[1] = 'A' + ((data[EDID_OFFSET_PNPID + 0] & 0x3) * 8) + ((data[EDID_OFFSET_PNPID + 1] & 0xe0) / 32) - 1;
+	edid->pnp_id[2] = 'A' + (data[EDID_OFFSET_PNPID + 1] & 0x1f) - 1;
+	edid->pnp_id[3] = '\0';
+
+	/* maybe there isn't a ASCII serial number descriptor, so use this instead */
+	serial_number = (uint32_t) data[EDID_OFFSET_SERIAL + 0];
+	serial_number += (uint32_t) data[EDID_OFFSET_SERIAL + 1] * 0x100;
+	serial_number += (uint32_t) data[EDID_OFFSET_SERIAL + 2] * 0x10000;
+	serial_number += (uint32_t) data[EDID_OFFSET_SERIAL + 3] * 0x1000000;
+	if (serial_number > 0)
+		sprintf(edid->serial_number, "%lu", (unsigned long) serial_number);
+
+	/* parse EDID data */
+	for (i = EDID_OFFSET_DATA_BLOCKS;
+	     i <= EDID_OFFSET_LAST_BLOCK;
+	     i += 18) {
+		/* ignore pixel clock data */
+		if (data[i] != 0)
+			continue;
+		if (data[i+2] != 0)
+			continue;
+
+		/* any useful blocks? */
+		if (data[i+3] == EDID_DESCRIPTOR_DISPLAY_PRODUCT_NAME) {
+			edid_parse_string(&data[i+5],
+					  edid->monitor_name);
+		} else if (data[i+3] == EDID_DESCRIPTOR_DISPLAY_PRODUCT_SERIAL_NUMBER) {
+			edid_parse_string(&data[i+5],
+					  edid->serial_number);
+		} else if (data[i+3] == EDID_DESCRIPTOR_ALPHANUMERIC_DATA_STRING) {
+			edid_parse_string(&data[i+5],
+					  edid->eisa_id);
+		}
+	}
+	return 0;
+}
+
+static void
+find_and_parse_output_edid(struct drm_backend *b,
+			   struct drm_output *output,
+			   drmModeConnector *connector)
+{
+	drmModePropertyBlobPtr edid_blob = NULL;
+	drmModePropertyPtr property;
+	int i;
+	int rc;
+
+	for (i = 0; i < connector->count_props && !edid_blob; i++) {
+		property = drmModeGetProperty(b->drm.fd, connector->props[i]);
+		if (!property)
+			continue;
+		if ((property->flags & DRM_MODE_PROP_BLOB) &&
+		    !strcmp(property->name, "EDID")) {
+			edid_blob = drmModeGetPropertyBlob(b->drm.fd,
+							   connector->prop_values[i]);
+		}
+		drmModeFreeProperty(property);
+	}
+	if (!edid_blob)
+		return;
+
+	rc = edid_parse(&output->edid,
+			edid_blob->data,
+			edid_blob->length);
+	if (!rc) {
+		weston_log("EDID data '%s', '%s', '%s'\n",
+			   output->edid.pnp_id,
+			   output->edid.monitor_name,
+			   output->edid.serial_number);
+		if (output->edid.pnp_id[0] != '\0')
+			output->base.make = output->edid.pnp_id;
+		if (output->edid.monitor_name[0] != '\0')
+			output->base.model = output->edid.monitor_name;
+		if (output->edid.serial_number[0] != '\0')
+			output->base.serial_number = output->edid.serial_number;
+	}
+	drmModeFreePropertyBlob(edid_blob);
+}
+
+
+
+static int
+parse_modeline(const char *s, drmModeModeInfo *mode)
+{
+	char hsync[16];
+	char vsync[16];
+	float fclock;
+
+	mode->type = DRM_MODE_TYPE_USERDEF;
+	mode->hskew = 0;
+	mode->vscan = 0;
+	mode->vrefresh = 0;
+	mode->flags = 0;
+
+	if (sscanf(s, "%f %hd %hd %hd %hd %hd %hd %hd %hd %15s %15s",
+		   &fclock,
+		   &mode->hdisplay,
+		   &mode->hsync_start,
+		   &mode->hsync_end,
+		   &mode->htotal,
+		   &mode->vdisplay,
+		   &mode->vsync_start,
+		   &mode->vsync_end,
+		   &mode->vtotal, hsync, vsync) != 11)
+		return -1;
+
+	mode->clock = fclock * 1000;
+	if (strcmp(hsync, "+hsync") == 0)
+		mode->flags |= DRM_MODE_FLAG_PHSYNC;
+	else if (strcmp(hsync, "-hsync") == 0)
+		mode->flags |= DRM_MODE_FLAG_NHSYNC;
+	else
+		return -1;
+
+	if (strcmp(vsync, "+vsync") == 0)
+		mode->flags |= DRM_MODE_FLAG_PVSYNC;
+	else if (strcmp(vsync, "-vsync") == 0)
+		mode->flags |= DRM_MODE_FLAG_NVSYNC;
+	else
+		return -1;
+
+	snprintf(mode->name, sizeof mode->name, "%dx%d@%.3f",
+		 mode->hdisplay, mode->vdisplay, fclock);
+
+	return 0;
+}
+
+static void
+setup_output_seat_constraint(struct drm_backend *b,
+			     struct weston_output *output,
+			     const char *s)
+{
+	if (strcmp(s, "") != 0) {
+		struct weston_pointer *pointer;
+		struct udev_seat *seat;
+
+		seat = udev_seat_get_named(&b->input, s);
+		if (!seat)
+			return;
+
+		seat->base.output = output;
+
+		pointer = weston_seat_get_pointer(&seat->base);
+		if (pointer)
+			weston_pointer_clamp(pointer,
+					     &pointer->x,
+					     &pointer->y);
+	}
+}
+
+static int
+parse_gbm_format(const char *s, uint32_t default_value, uint32_t *gbm_format)
+{
+	int ret = 0;
+
+	if (s == NULL)
+		*gbm_format = default_value;
+	else if (strcmp(s, "xrgb8888") == 0)
+		*gbm_format = GBM_FORMAT_XRGB8888;
+	else if (strcmp(s, "rgb565") == 0)
+		*gbm_format = GBM_FORMAT_RGB565;
+	else if (strcmp(s, "xrgb2101010") == 0)
+		*gbm_format = GBM_FORMAT_XRGB2101010;
+	else {
+		weston_log("fatal: unrecognized pixel format: %s\n", s);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+/**
+ * Choose suitable mode for an output
+ *
+ * Find the most suitable mode to use for initial setup (or reconfiguration on
+ * hotplug etc) for a DRM output.
+ *
+ * @param output DRM output to choose mode for
+ * @param kind Strategy and preference to use when choosing mode
+ * @param width Desired width for this output
+ * @param height Desired height for this output
+ * @param current_mode Mode currently being displayed on this output
+ * @param modeline Manually-entered mode (may be NULL)
+ * @returns A mode from the output's mode list, or NULL if none available
+ */
+static struct drm_mode *
+drm_output_choose_initial_mode(struct drm_backend *backend,
+			       struct drm_output *output,
+			       enum weston_drm_backend_output_mode mode,
+			       const char *modeline,
+			       const drmModeModeInfo *current_mode)
+{
+	struct drm_mode *preferred = NULL;
+	struct drm_mode *current = NULL;
+	struct drm_mode *configured = NULL;
+	struct drm_mode *best = NULL;
+	struct drm_mode *drm_mode;
+	drmModeModeInfo drm_modeline;
+	int32_t width = 0;
+	int32_t height = 0;
+
+	if (mode == WESTON_DRM_BACKEND_OUTPUT_PREFERRED && modeline) {
+		if (sscanf(modeline, "%dx%d", &width, &height) != 2) {
+			width = -1;
+
+			if (parse_modeline(modeline, &drm_modeline) == 0) {
+				configured = drm_output_add_mode(output, &drm_modeline);
+				if (!configured)
+					return NULL;
+			} else {
+				weston_log("Invalid modeline \"%s\" for output %s\n",
+					   modeline, output->base.name);
+			}
+		}
+	}
+
+	wl_list_for_each_reverse(drm_mode, &output->base.mode_list, base.link) {
+		if (width == drm_mode->base.width &&
+		    height == drm_mode->base.height)
+			configured = drm_mode;
+
+		if (memcmp(current_mode, &drm_mode->mode_info,
+			   sizeof *current_mode) == 0)
+			current = drm_mode;
+
+		if (drm_mode->base.flags & WL_OUTPUT_MODE_PREFERRED)
+			preferred = drm_mode;
+
+		best = drm_mode;
+	}
+
+	if (current == NULL && current_mode->clock != 0) {
+		current = drm_output_add_mode(output, current_mode);
+		if (!current)
+			return NULL;
+	}
+
+	if (mode == WESTON_DRM_BACKEND_OUTPUT_CURRENT)
+		configured = current;
+
+	if (configured)
+		return configured;
+
+	if (preferred)
+		return preferred;
+
+	if (current)
+		return current;
+
+	if (best)
+		return best;
+
+	weston_log("no available modes for %s\n", output->base.name);
+	return NULL;
+}
+
+static int
+connector_get_current_mode(drmModeConnector *connector, int drm_fd,
+			   drmModeModeInfo *mode)
+{
+	drmModeEncoder *encoder;
+	drmModeCrtc *crtc;
+
+	/* Get the current mode on the crtc that's currently driving
+	 * this connector. */
+	encoder = drmModeGetEncoder(drm_fd, connector->encoder_id);
+	memset(mode, 0, sizeof *mode);
+	if (encoder != NULL) {
+		crtc = drmModeGetCrtc(drm_fd, encoder->crtc_id);
+		drmModeFreeEncoder(encoder);
+		if (crtc == NULL)
+			return -1;
+		if (crtc->mode_valid)
+			*mode = crtc->mode;
+		drmModeFreeCrtc(crtc);
+	}
+
+	return 0;
+}
+
+static int
+drm_output_set_mode(struct weston_output *base,
+		    enum weston_drm_backend_output_mode mode,
+		    const char *modeline)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	struct drm_mode *drm_mode, *next, *current;
+	drmModeModeInfo crtc_mode;
+	int i;
+
+	output->base.make = "unknown";
+	output->base.model = "unknown";
+	output->base.serial_number = "unknown";
+	wl_list_init(&output->base.mode_list);
+
+	output->original_crtc = drmModeGetCrtc(b->drm.fd, output->crtc_id);
+
+	if (connector_get_current_mode(output->connector, b->drm.fd, &crtc_mode) < 0)
+		goto err_free;
+
+	for (i = 0; i < output->connector->count_modes; i++) {
+		drm_mode = drm_output_add_mode(output, &output->connector->modes[i]);
+		if (!drm_mode)
+			goto err_free;
+	}
+
+	current = drm_output_choose_initial_mode(b, output, mode, modeline, &crtc_mode);
+	if (!current)
+		goto err_free;
+
+	output->base.current_mode = &current->base;
+	output->base.current_mode->flags |= WL_OUTPUT_MODE_CURRENT;
+
+	/* Set native_ fields, so weston_output_mode_switch_to_native() works */
+	output->base.native_mode = output->base.current_mode;
+	output->base.native_scale = output->base.current_scale;
+
+	output->base.mm_width = output->connector->mmWidth;
+	output->base.mm_height = output->connector->mmHeight;
+
+	return 0;
+
+err_free:
+	drmModeFreeCrtc(output->original_crtc);
+	output->original_crtc = NULL;
+
+	wl_list_for_each_safe(drm_mode, next, &output->base.mode_list,
+							base.link) {
+		wl_list_remove(&drm_mode->base.link);
+		free(drm_mode);
+	}
+
+	return -1;
+}
+
+static void
+drm_output_set_gbm_format(struct weston_output *base,
+			  const char *gbm_format)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	if (parse_gbm_format(gbm_format, b->gbm_format, &output->gbm_format) == -1)
+		output->gbm_format = b->gbm_format;
+}
+
+static void
+drm_output_set_seat(struct weston_output *base,
+		    const char *seat)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	setup_output_seat_constraint(b, &output->base,
+				     seat ? seat : "");
+}
+
+static int
+drm_output_enable(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+	struct weston_mode *m;
+
+	output->dpms_prop = drm_get_prop(b->drm.fd, output->connector, "DPMS");
+
+	if (b->use_pixman) {
+		if (drm_output_init_pixman(output, b) < 0) {
+			weston_log("Failed to init output pixman state\n");
+			goto err_free;
+		}
+	} else if (drm_output_init_egl(output, b) < 0) {
+		weston_log("Failed to init output gl state\n");
+		goto err_free;
+	}
+
+	if (output->backlight) {
+		weston_log("Initialized backlight, device %s\n",
+			   output->backlight->path);
+		output->base.set_backlight = drm_set_backlight;
+		output->base.backlight_current = drm_get_backlight(output);
+	} else {
+		weston_log("Failed to initialize backlight\n");
+	}
+
+	output->base.start_repaint_loop = drm_output_start_repaint_loop;
+	output->base.repaint = drm_output_repaint;
+	output->base.assign_planes = drm_assign_planes;
+	output->base.set_dpms = drm_set_dpms;
+	output->base.switch_mode = drm_output_switch_mode;
+
+	output->base.gamma_size = output->original_crtc->gamma_size;
+	output->base.set_gamma = drm_output_set_gamma;
+
+	output->base.subpixel = drm_subpixel_to_wayland(output->connector->subpixel);
+
+	find_and_parse_output_edid(b, output, output->connector);
+	if (output->connector->connector_type == DRM_MODE_CONNECTOR_LVDS)
+		output->base.connection_internal = 1;
+
+	weston_plane_init(&output->cursor_plane, b->compositor,
+			  INT32_MIN, INT32_MIN);
+	weston_plane_init(&output->fb_plane, b->compositor, 0, 0);
+
+	weston_compositor_stack_plane(b->compositor, &output->cursor_plane, NULL);
+	weston_compositor_stack_plane(b->compositor, &output->fb_plane,
+				      &b->compositor->primary_plane);
+
+	weston_log("Output %s, (connector %d, crtc %d)\n",
+		   output->base.name, output->connector_id, output->crtc_id);
+	wl_list_for_each(m, &output->base.mode_list, link)
+		weston_log_continue(STAMP_SPACE "mode %dx%d@%.1f%s%s%s\n",
+				    m->width, m->height, m->refresh / 1000.0,
+				    m->flags & WL_OUTPUT_MODE_PREFERRED ?
+				    ", preferred" : "",
+				    m->flags & WL_OUTPUT_MODE_CURRENT ?
+				    ", current" : "",
+				    output->connector->count_modes == 0 ?
+				    ", built-in" : "");
+
+	return 0;
+
+err_free:
+	drmModeFreeProperty(output->dpms_prop);
+
+	return -1;
+}
+
+static void
+drm_output_deinit(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	if (b->use_pixman) {
+		drm_output_fini_pixman(output);
+	} else {
+		gl_renderer->output_destroy(&output->base);
+		gbm_surface_destroy(output->gbm_surface);
+	}
+
+	weston_plane_release(&output->fb_plane);
+	weston_plane_release(&output->cursor_plane);
+
+	drmModeFreeProperty(output->dpms_prop);
+
+	/* Turn off hardware cursor */
+	drmModeSetCursor(b->drm.fd, output->crtc_id, 0, 0, 0);
+}
+
+static void
+drm_output_destroy(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+	drmModeCrtcPtr origcrtc = output->original_crtc;
+
+	if (output->page_flip_pending) {
+		output->destroy_pending = 1;
+		weston_log("destroy output while page flip pending\n");
+		return;
+	}
+
+	if (output->base.enabled)
+		drm_output_deinit(&output->base);
+
+	if (origcrtc) {
+		/* Restore original CRTC state */
+		drmModeSetCrtc(b->drm.fd, origcrtc->crtc_id, origcrtc->buffer_id,
+			       origcrtc->x, origcrtc->y,
+			       &output->connector_id, 1, &origcrtc->mode);
+		drmModeFreeCrtc(origcrtc);
+	}
+
+	weston_output_destroy(&output->base);
+
+	drmModeFreeConnector(output->connector);
+
+	if (output->backlight)
+		backlight_destroy(output->backlight);
+
+	b->crtc_allocator &= ~(1 << output->crtc_id);
+	b->connector_allocator &= ~(1 << output->connector_id);
+
+	free(output);
+}
+
+static int
+drm_output_disable(struct weston_output *base)
+{
+	struct drm_output *output = to_drm_output(base);
+	struct drm_backend *b = to_drm_backend(base->compositor);
+
+	if (output->page_flip_pending) {
+		output->disable_pending = 1;
+		return -1;
+	}
+
+	if (output->base.enabled)
+		drm_output_deinit(&output->base);
+
+	output->disable_pending = 0;
+
+	weston_log("Disabling output %s\n", output->base.name);
+	drmModeSetCrtc(b->drm.fd, output->crtc_id,
+		       0, 0, 0, 0, 0, NULL);
+
+	return 0;
+}
+
+/**
+ * Create a Weston output structure
+ *
+ * Given a DRM connector, create a matching drm_output structure and add it
+ * to Weston's output list. It also takes ownership of the connector, which
+ * is released when output is destroyed.
+ *
+ * @param b Weston backend structure
+ * @param resources DRM resources for this device
+ * @param connector DRM connector to use for this new output
+ * @param drm_device udev device pointer
+ * @returns 0 on success, or -1 on failure
+ */
+static int
+create_output_for_connector(struct drm_backend *b,
+			    drmModeRes *resources,
+			    drmModeConnector *connector,
+			    struct udev_device *drm_device)
+{
+	struct drm_output *output;
+	int i;
+
+	i = find_crtc_for_connector(b, resources, connector);
+	if (i < 0) {
+		weston_log("No usable crtc/encoder pair for connector.\n");
+		return -1;
+	}
+
+	output = zalloc(sizeof *output);
+	if (output == NULL)
+		return -1;
+
+	output->connector = connector;
+	output->crtc_id = resources->crtcs[i];
+	output->pipe = i;
+	output->connector_id = connector->connector_id;
+
+	output->backlight = backlight_init(drm_device,
+					   connector->connector_type);
+
+	output->base.enable = drm_output_enable;
+	output->base.destroy = drm_output_destroy;
+	output->base.disable = drm_output_disable;
+	output->base.name = make_connector_name(connector);
+
+	output->destroy_pending = 0;
+	output->disable_pending = 0;
+	output->original_crtc = NULL;
+
+	b->crtc_allocator |= (1 << output->crtc_id);
+	b->connector_allocator |= (1 << output->connector_id);
+
+	weston_output_init(&output->base, b->compositor);
+	weston_compositor_add_pending_output(&output->base, b->compositor);
+
+	return 0;
+}
+
+static void
+create_sprites(struct drm_backend *b)
+{
+	struct drm_sprite *sprite;
+	drmModePlaneRes *plane_res;
+	drmModePlane *plane;
+	drmModeObjectPropertiesPtr properties = NULL;
+	drmModePropertyPtr property = NULL;
+	uint32_t i, j;
+
+	plane_res = drmModeGetPlaneResources(b->drm.fd);
+	if (!plane_res) {
+		weston_log("failed to get plane resources: %s\n",
+			strerror(errno));
+		return;
+	}
+
+	for (i = 0; i < plane_res->count_planes; i++) {
+		plane = drmModeGetPlane(b->drm.fd, plane_res->planes[i]);
+		if (!plane)
+			continue;
+
+		sprite = zalloc(sizeof(*sprite) + ((sizeof(uint32_t)) *
+						   plane->count_formats));
+		if (!sprite) {
+			weston_log("%s: out of memory\n",
+				__func__);
+			drmModeFreePlane(plane);
+			continue;
+		}
+
+		sprite->possible_crtcs = plane->possible_crtcs;
+		sprite->plane_id = plane->plane_id;
+		sprite->current = NULL;
+		sprite->next = NULL;
+		sprite->vblank_pending = false;
+		sprite->backend = b;
+		sprite->count_formats = plane->count_formats;
+		memcpy(sprite->formats, plane->formats,
+		       plane->count_formats * sizeof(plane->formats[0]));
+		drmModeFreePlane(plane);
+		weston_plane_init(&sprite->plane, b->compositor, 0, 0);
+		weston_compositor_stack_plane(b->compositor, &sprite->plane,
+					      &b->compositor->primary_plane);
+
+		properties = drmModeObjectGetProperties (b->drm.fd, sprite->plane_id, DRM_MODE_OBJECT_PLANE);
+
+		if (properties) {
+			for (j = 0; j < properties->count_props; ++j) {
+				property = drmModeGetProperty (b->drm.fd, properties->props[j]);
+				if (!property)
+					continue;
+				if (strcmp (property->name, ZORDER_PROP_NAME) == 0)
+					break;
+				drmModeFreeProperty (property);
+			}
+
+			if (j < properties->count_props) {
+				sprite->zpos_prop_id = property->prop_id;
+				drmModeFreeProperty (property);
+			} else {
+				weston_log("ERROR : failed to get zorder property id\n");
+			}
+			drmModeFreeObjectProperties (properties);
+		} else {
+			weston_log("ERROR : failed to get zorder property id\n");
+		}
+
+		wl_list_insert(&b->sprite_list, &sprite->link);
+	}
+
+	drmModeFreePlaneResources(plane_res);
+}
+
+static void
+destroy_sprites(struct drm_backend *backend)
+{
+	struct drm_sprite *sprite, *next;
+	struct drm_output *output;
+
+	output = container_of(backend->compositor->output_list.next,
+			      struct drm_output, base.link);
+
+	wl_list_for_each_safe(sprite, next, &backend->sprite_list, link) {
+		drmModeSetPlane(backend->drm.fd,
+				sprite->plane_id,
+				output->crtc_id, 0, 0,
+				0, 0, 0, 0, 0, 0, 0, 0);
+		drm_output_release_fb(output, sprite->current);
+		drm_output_release_fb(output, sprite->next);
+		weston_plane_release(&sprite->plane);
+		free(sprite);
+	}
+}
+
+static int
+create_outputs(struct drm_backend *b, uint32_t option_connector,
+	       struct udev_device *drm_device)
+{
+	drmModeConnector *connector;
+	drmModeRes *resources;
+	int i;
+
+	resources = drmModeGetResources(b->drm.fd);
+	if (!resources) {
+		weston_log("drmModeGetResources failed\n");
+		return -1;
+	}
+
+	b->crtcs = calloc(resources->count_crtcs, sizeof(uint32_t));
+	if (!b->crtcs) {
+		drmModeFreeResources(resources);
+		return -1;
+	}
+
+	b->min_width  = resources->min_width;
+	b->max_width  = resources->max_width;
+	b->min_height = resources->min_height;
+	b->max_height = resources->max_height;
+
+	b->num_crtcs = resources->count_crtcs;
+	memcpy(b->crtcs, resources->crtcs, sizeof(uint32_t) * b->num_crtcs);
+
+	for (i = 0; i < resources->count_connectors; i++) {
+		connector = drmModeGetConnector(b->drm.fd,
+						resources->connectors[i]);
+		if (connector == NULL)
+			continue;
+
+		if (connector->connection == DRM_MODE_CONNECTED &&
+		    (option_connector == 0 ||
+		     connector->connector_id == option_connector)) {
+			if (create_output_for_connector(b, resources,
+							connector, drm_device) < 0) {
+				drmModeFreeConnector(connector);
+				continue;
+			}
+		} else {
+			drmModeFreeConnector(connector);
+		}
+	}
+
+	if (wl_list_empty(&b->compositor->output_list) &&
+	    wl_list_empty(&b->compositor->pending_output_list))
+		weston_log("No currently active connector found.\n");
+
+	drmModeFreeResources(resources);
+
+	return 0;
+}
+
+static void
+update_outputs(struct drm_backend *b, struct udev_device *drm_device)
+{
+	drmModeConnector *connector;
+	drmModeRes *resources;
+	struct drm_output *output, *next;
+	uint32_t connected = 0, disconnects = 0;
+	int i;
+
+	resources = drmModeGetResources(b->drm.fd);
+	if (!resources) {
+		weston_log("drmModeGetResources failed\n");
+		return;
+	}
+
+	/* collect new connects */
+	for (i = 0; i < resources->count_connectors; i++) {
+		int connector_id = resources->connectors[i];
+
+		connector = drmModeGetConnector(b->drm.fd, connector_id);
+		if (connector == NULL)
+			continue;
+
+		if (connector->connection != DRM_MODE_CONNECTED) {
+			drmModeFreeConnector(connector);
+			continue;
+		}
+
+		connected |= (1 << connector_id);
+
+		if (!(b->connector_allocator & (1 << connector_id))) {
+			create_output_for_connector(b, resources,
+						    connector, drm_device);
+			weston_log("connector %d connected\n", connector_id);
+
+		} else {
+			drmModeFreeConnector(connector);
+		}
+	}
+	drmModeFreeResources(resources);
+
+	disconnects = b->connector_allocator & ~connected;
+	if (disconnects) {
+		wl_list_for_each_safe(output, next, &b->compositor->output_list,
+				      base.link) {
+			if (disconnects & (1 << output->connector_id)) {
+				disconnects &= ~(1 << output->connector_id);
+				weston_log("connector %d disconnected\n",
+				       output->connector_id);
+				drm_output_destroy(&output->base);
+			}
+		}
+
+		wl_list_for_each_safe(output, next, &b->compositor->pending_output_list,
+				      base.link) {
+			if (disconnects & (1 << output->connector_id)) {
+				disconnects &= ~(1 << output->connector_id);
+				weston_log("connector %d disconnected\n",
+				       output->connector_id);
+				drm_output_destroy(&output->base);
+			}
+		}
+	}
+}
+
+static int
+udev_event_is_hotplug(struct drm_backend *b, struct udev_device *device)
+{
+	const char *sysnum;
+	const char *val;
+
+	sysnum = udev_device_get_sysnum(device);
+	if (!sysnum || atoi(sysnum) != b->drm.id)
+		return 0;
+
+	val = udev_device_get_property_value(device, "HOTPLUG");
+	if (!val)
+		return 0;
+
+	return strcmp(val, "1") == 0;
+}
+
+static int
+udev_drm_event(int fd, uint32_t mask, void *data)
+{
+	struct drm_backend *b = data;
+	struct udev_device *event;
+
+	event = udev_monitor_receive_device(b->udev_monitor);
+
+	if (udev_event_is_hotplug(b, event))
+		update_outputs(b, event);
+
+	udev_device_unref(event);
+
+	return 1;
+}
+
+static void
+drm_restore(struct weston_compositor *ec)
+{
+	weston_launcher_restore(ec->launcher);
+}
+
+static void
+drm_destroy(struct weston_compositor *ec)
+{
+	struct drm_backend *b = to_drm_backend(ec);
+
+	udev_input_destroy(&b->input);
+
+	wl_event_source_remove(b->udev_drm_source);
+	wl_event_source_remove(b->drm_source);
+
+	destroy_sprites(b);
+
+	weston_compositor_shutdown(ec);
+
+	if (b->gbm)
+		gbm_device_destroy(b->gbm);
+
+	weston_launcher_destroy(ec->launcher);
+
+	close(b->drm.fd);
+	free(b);
+}
+
+static void
+drm_backend_set_modes(struct drm_backend *backend)
+{
+	struct drm_output *output;
+	struct drm_mode *drm_mode;
+	int ret;
+
+	wl_list_for_each(output, &backend->compositor->output_list, base.link) {
+		if (!output->current) {
+			/* If something that would cause the output to
+			 * switch mode happened while in another vt, we
+			 * might not have a current drm_fb. In that case,
+			 * schedule a repaint and let drm_output_repaint
+			 * handle setting the mode. */
+			weston_output_schedule_repaint(&output->base);
+			continue;
+		}
+
+		drm_mode = (struct drm_mode *) output->base.current_mode;
+		ret = drmModeSetCrtc(backend->drm.fd, output->crtc_id,
+				     output->current->fb_id, 0, 0,
+				     &output->connector_id, 1,
+				     &drm_mode->mode_info);
+		if (ret < 0) {
+			weston_log(
+				"failed to set mode %dx%d for output at %d,%d: %m\n",
+				drm_mode->base.width, drm_mode->base.height,
+				output->base.x, output->base.y);
+		}
+	}
+}
+
+static void
+session_notify(struct wl_listener *listener, void *data)
+{
+	struct weston_compositor *compositor = data;
+	struct drm_backend *b = to_drm_backend(compositor);
+	struct drm_sprite *sprite;
+	struct drm_output *output;
+
+	if (compositor->session_active) {
+		weston_log("activating session\n");
+		compositor->state = b->prev_state;
+		drm_backend_set_modes(b);
+		weston_compositor_damage_all(compositor);
+		udev_input_enable(&b->input);
+	} else {
+		weston_log("deactivating session\n");
+		udev_input_disable(&b->input);
+
+		b->prev_state = compositor->state;
+		weston_compositor_offscreen(compositor);
+
+		/* If we have a repaint scheduled (either from a
+		 * pending pageflip or the idle handler), make sure we
+		 * cancel that so we don't try to pageflip when we're
+		 * vt switched away.  The OFFSCREEN state will prevent
+		 * further attemps at repainting.  When we switch
+		 * back, we schedule a repaint, which will process
+		 * pending frame callbacks. */
+
+		wl_list_for_each(output, &compositor->output_list, base.link) {
+			output->base.repaint_needed = 0;
+			drmModeSetCursor(b->drm.fd, output->crtc_id, 0, 0, 0);
+		}
+
+		output = container_of(compositor->output_list.next,
+				      struct drm_output, base.link);
+
+		wl_list_for_each(sprite, &b->sprite_list, link)
+			drmModeSetPlane(b->drm.fd,
+					sprite->plane_id,
+					output->crtc_id, 0, 0,
+					0, 0, 0, 0, 0, 0, 0, 0);
+	};
+}
+
+/*
+ * Find primary GPU
+ * Some systems may have multiple DRM devices attached to a single seat. This
+ * function loops over all devices and tries to find a PCI device with the
+ * boot_vga sysfs attribute set to 1.
+ * If no such device is found, the first DRM device reported by udev is used.
+ */
+static struct udev_device*
+find_primary_gpu(struct drm_backend *b, const char *seat)
+{
+	struct udev_enumerate *e;
+	struct udev_list_entry *entry;
+	const char *path, *device_seat, *id;
+	struct udev_device *device, *drm_device, *pci;
+
+	e = udev_enumerate_new(b->udev);
+	udev_enumerate_add_match_subsystem(e, "drm");
+	udev_enumerate_add_match_sysname(e, "card[0-9]*");
+
+	udev_enumerate_scan_devices(e);
+	drm_device = NULL;
+	udev_list_entry_foreach(entry, udev_enumerate_get_list_entry(e)) {
+		path = udev_list_entry_get_name(entry);
+		device = udev_device_new_from_syspath(b->udev, path);
+		if (!device)
+			continue;
+		device_seat = udev_device_get_property_value(device, "ID_SEAT");
+		if (!device_seat)
+			device_seat = default_seat;
+		if (strcmp(device_seat, seat)) {
+			udev_device_unref(device);
+			continue;
+		}
+
+		pci = udev_device_get_parent_with_subsystem_devtype(device,
+								"pci", NULL);
+		if (pci) {
+			id = udev_device_get_sysattr_value(pci, "boot_vga");
+			if (id && !strcmp(id, "1")) {
+				if (drm_device)
+					udev_device_unref(drm_device);
+				drm_device = device;
+				break;
+			}
+		}
+
+		if (!drm_device)
+			drm_device = device;
+		else
+			udev_device_unref(device);
+	}
+
+	udev_enumerate_unref(e);
+	return drm_device;
+}
+
+static void
+planes_binding(struct weston_keyboard *keyboard, uint32_t time, uint32_t key,
+	       void *data)
+{
+	struct drm_backend *b = data;
+
+	switch (key) {
+	case KEY_C:
+		b->cursors_are_broken[0] ^= 1;
+		b->cursors_are_broken[1] = b->cursors_are_broken[0];
+		if (b->cursors_are_broken[0])
+			weston_log("Software cursor.\n");
+		else
+			weston_log("Hardware cursor (if available).\n");
+		break;
+	case KEY_V:
+		b->sprites_are_broken ^= 1;
+		if (b->sprites_are_broken)
+			weston_log("Sprites are disabled.\n");
+		else
+			weston_log("Sprites are enabled.\n");
+		break;
+	case KEY_O:
+		b->sprites_hidden ^= 1;
+		break;
+	default:
+		break;
+	}
+}
+
+#ifdef BUILD_VAAPI_RECORDER
+static void
+recorder_destroy(struct drm_output *output)
+{
+	vaapi_recorder_destroy(output->recorder);
+	output->recorder = NULL;
+
+	output->base.disable_planes--;
+
+	wl_list_remove(&output->recorder_frame_listener.link);
+	weston_log("[libva recorder] done\n");
+}
+
+static void
+recorder_frame_notify(struct wl_listener *listener, void *data)
+{
+	struct drm_output *output;
+	struct drm_backend *b;
+	int fd, ret;
+
+	output = container_of(listener, struct drm_output,
+			      recorder_frame_listener);
+	b = to_drm_backend(output->base.compositor);
+
+	if (!output->recorder)
+		return;
+
+	ret = drmPrimeHandleToFD(b->drm.fd, output->current->handle,
+				 DRM_CLOEXEC, &fd);
+	if (ret) {
+		weston_log("[libva recorder] "
+			   "failed to create prime fd for front buffer\n");
+		return;
+	}
+
+	ret = vaapi_recorder_frame(output->recorder, fd,
+				   output->current->stride);
+	if (ret < 0) {
+		weston_log("[libva recorder] aborted: %m\n");
+		recorder_destroy(output);
+	}
+}
+
+static void *
+create_recorder(struct drm_backend *b, int width, int height,
+		const char *filename)
+{
+	int fd;
+	drm_magic_t magic;
+
+	fd = open(b->drm.filename, O_RDWR | O_CLOEXEC);
+	if (fd < 0)
+		return NULL;
+
+	drmGetMagic(fd, &magic);
+	drmAuthMagic(b->drm.fd, magic);
+
+	return vaapi_recorder_create(fd, width, height, filename);
+}
+
+static void
+recorder_binding(struct weston_keyboard *keyboard, uint32_t time, uint32_t key,
+		 void *data)
+{
+	struct drm_backend *b = data;
+	struct drm_output *output;
+	int width, height;
+
+	output = container_of(b->compositor->output_list.next,
+			      struct drm_output, base.link);
+
+	if (!output->recorder) {
+		if (output->gbm_format != GBM_FORMAT_XRGB8888) {
+			weston_log("failed to start vaapi recorder: "
+				   "output format not supported\n");
+			return;
+		}
+
+		width = output->base.current_mode->width;
+		height = output->base.current_mode->height;
+
+		output->recorder =
+			create_recorder(b, width, height, "capture.h264");
+		if (!output->recorder) {
+			weston_log("failed to create vaapi recorder\n");
+			return;
+		}
+
+		output->base.disable_planes++;
+
+		output->recorder_frame_listener.notify = recorder_frame_notify;
+		wl_signal_add(&output->base.frame_signal,
+			      &output->recorder_frame_listener);
+
+		weston_output_schedule_repaint(&output->base);
+
+		weston_log("[libva recorder] initialized\n");
+	} else {
+		recorder_destroy(output);
+	}
+}
+#else
+static void
+recorder_binding(struct weston_keyboard *keyboard, uint32_t time, uint32_t key,
+		 void *data)
+{
+	weston_log("Compiled without libva support\n");
+}
+#endif
+
+#ifdef ENABLE_DISPLAY_CAPTURE
+static void
+capture_finish(struct drm_output_capture *doc)
+{
+	/* Restore plane composition */
+	doc->output->base.disable_planes = 0;
+
+	doc->output->doc = NULL;
+	doc->resource = NULL;
+	doc->output_resource = NULL;
+	doc->stopping = false;
+	doc->nb_frames = 0;
+	doc->start_msecs = 0;
+	doc->output = NULL;
+}
+
+static void
+capture_output_repainted(struct drm_output_capture *doc, struct gbm_bo *bo)
+{
+	if (doc->stopping) {
+		weston_log("Captured %d frames\n", doc->nb_frames);
+		capture_finish(doc);
+		return;
+	}
+
+	if (!bo) {
+		weston_log("Error: no bo\n");
+		return;
+	}
+
+	weston_xlog("%s bo fd=%d  msecs=%d\n", __func__, gbm_bo_get_fd(bo),
+			doc->output->base.frame_time);
+
+	if (!doc->start_msecs)
+		doc->start_msecs = doc->output->base.frame_time;
+
+	if (doc->resource && doc->output_resource) {
+		wl_capture_send_update(doc->resource, doc->output_resource,
+				gbm_bo_get_fd(bo),
+				gbm_bo_get_width(bo), gbm_bo_get_height(bo),
+				gbm_bo_get_stride(bo),
+				gbm_bo_get_format(bo),
+				doc->output->base.frame_time - doc->start_msecs);
+
+		doc->nb_frames++;
+	} else {
+		weston_log("Error: capture resources are not defined\n");
+	}
+}
+
+static void
+capture_start(struct wl_client *client,
+		struct wl_resource *resource, struct wl_resource *output_resource)
+{
+	struct drm_output *output = wl_resource_get_user_data(output_resource);
+	struct drm_output *compo_output;
+	struct drm_output_capture *doc = wl_resource_get_user_data(resource);
+
+	weston_log("Starting capture\n");
+
+	/* Check for output validity */
+	wl_list_for_each(compo_output, &doc->backend->compositor->output_list, base.link)
+		if (output == compo_output) {
+			if (output->doc) {
+				weston_log("Capture already started\n");
+				return;
+			}
+			doc->output = output;
+		}
+
+	if (!doc->output) {
+		weston_log("Capture failed: invalid output\n");
+		wl_resource_post_error(resource, WL_CAPTURE_ERROR_BAD_OUTPUT,
+				       "capture failed: invalid output");
+		return;
+	}
+
+	/* Check for GL support */
+	if (!doc->backend->gbm) {
+		weston_log("Capture error: GL not set up\n");
+		wl_resource_post_error(resource, WL_CAPTURE_ERROR_NO_GL,
+				       "Capture error: GL not set up");
+		return;
+	}
+
+	doc->resource = resource;
+	doc->output_resource = output_resource;
+
+	/* Force "one plane" composition, and redraw */
+	output->doc = doc;
+	doc->output->base.disable_planes = 1;
+	weston_output_damage(&doc->output->base);
+}
+
+static void
+capture_stop(struct wl_client *client,
+		struct wl_resource *resource, struct wl_resource *output_resource)
+{
+	struct drm_output *output = wl_resource_get_user_data(output_resource);
+	struct drm_output_capture *doc = wl_resource_get_user_data(resource);
+
+	weston_log("Stopping capture\n");
+
+	/* Check for output validity */
+	if (output != doc->output) {
+		weston_log("Capture failed: invalid output\n");
+		wl_resource_post_error(resource, WL_CAPTURE_ERROR_BAD_OUTPUT,
+				       "capture failed: invalid output");
+		return;
+	}
+
+	if (!output->doc) {
+		weston_log("Capture already stopped\n");
+		return;
+	}
+
+	/* Capture will stop at next frame */
+	doc->stopping = true;
+	weston_output_schedule_repaint(&doc->output->base);
+}
+
+struct wl_capture_interface capture_interface = {
+	capture_start,
+	capture_stop
+};
+
+static void
+capture_unbind(struct wl_resource *resource)
+{
+	struct drm_output_capture *doc = wl_resource_get_user_data(resource);
+
+	if (doc->output && !doc->stopping)  {
+		/* The client did not ask for capture_stop before quitting */
+		weston_log("Stopping capture (client unbind)\n");
+		capture_finish(doc);
+	}
+}
+
+static void
+capture_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id)
+{
+	struct wl_resource *resource;
+
+	resource = wl_resource_create(client, &wl_capture_interface, 1, id);
+	if (!resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+
+	wl_resource_set_implementation(resource, &capture_interface, data,
+				       capture_unbind);
+}
+
+static void
+capture_destroy(struct wl_listener *listener, void *data)
+{
+	struct drm_output_capture *doc =
+		container_of(listener, struct drm_output_capture, destroy_listener);
+
+	wl_global_destroy(doc->global);
+	free(doc);
+}
+
+static int
+capture_create(struct drm_backend *backend)
+{
+	struct drm_output_capture *doc;
+
+	doc = zalloc(sizeof *doc);
+	if (!doc)
+		return -1;
+
+	doc->backend = backend;
+	doc->global = wl_global_create(backend->compositor->wl_display,
+			&wl_capture_interface, 1, doc, capture_bind);
+	doc->destroy_listener.notify = capture_destroy;
+	wl_signal_add(&backend->compositor->destroy_signal, &doc->destroy_listener);
+
+	weston_log("display capture ST: initialized\n");
+
+	return 0;
+}
+#else
+static void
+capture_create(struct drm_backend *backend)
+{
+	weston_log("Compiled without capture support\n");
+}
+#endif
+
+static void
+switch_to_gl_renderer(struct drm_backend *b)
+{
+	struct drm_output *output;
+	bool dmabuf_support_inited;
+
+	if (!b->use_pixman)
+		return;
+
+	dmabuf_support_inited = !!b->compositor->renderer->import_dmabuf;
+
+	weston_log("Switching to GL renderer\n");
+
+	b->gbm = create_gbm_device(b->drm.fd);
+	if (!b->gbm) {
+		weston_log("Failed to create gbm device. "
+			   "Aborting renderer switch\n");
+		return;
+	}
+
+	wl_list_for_each(output, &b->compositor->output_list, base.link)
+		pixman_renderer_output_destroy(&output->base);
+
+	b->compositor->renderer->destroy(b->compositor);
+
+	if (drm_backend_create_gl_renderer(b) < 0) {
+		gbm_device_destroy(b->gbm);
+		weston_log("Failed to create GL renderer. Quitting.\n");
+		/* FIXME: we need a function to shutdown cleanly */
+		assert(0);
+	}
+
+	wl_list_for_each(output, &b->compositor->output_list, base.link)
+		drm_output_init_egl(output, b);
+
+	b->use_pixman = 0;
+
+	if (!dmabuf_support_inited && b->compositor->renderer->import_dmabuf) {
+		if (linux_dmabuf_setup(b->compositor) < 0)
+			weston_log("Error: initializing dmabuf "
+				   "support failed.\n");
+	}
+}
+
+static void
+renderer_switch_binding(struct weston_keyboard *keyboard, uint32_t time,
+			uint32_t key, void *data)
+{
+	struct drm_backend *b =
+		to_drm_backend(keyboard->seat->compositor);
+
+	switch_to_gl_renderer(b);
+}
+
+static const struct weston_drm_output_api api = {
+	drm_output_set_mode,
+	drm_output_set_gbm_format,
+	drm_output_set_seat,
+};
+
+static struct drm_backend *
+drm_backend_create(struct weston_compositor *compositor,
+		   struct weston_drm_backend_config *config)
+{
+	struct drm_backend *b;
+	struct udev_device *drm_device;
+	struct wl_event_loop *loop;
+	const char *path;
+	const char *seat_id = default_seat;
+	int ret;
+
+	weston_log("initializing st backend\n");
+
+	b = zalloc(sizeof *b);
+	if (b == NULL)
+		return NULL;
+
+	/*
+	 * KMS support for hardware planes cannot properly synchronize
+	 * without nuclear page flip. Without nuclear/atomic, hw plane
+	 * and cursor plane updates would either tear or cause extra
+	 * waits for vblanks which means dropping the compositor framerate
+	 * to a fraction. For cursors, it's not so bad, so they are
+	 * enabled.
+	 *
+	 * These can be enabled again when nuclear/atomic support lands.
+	 */
+	b->compositor = compositor;
+	b->use_pixman = config->use_pixman;
+	b->use_current_mode = config->use_current_mode;
+
+	if (parse_gbm_format(config->gbm_format, GBM_FORMAT_XRGB8888, &b->gbm_format) < 0)
+		goto err_compositor;
+
+	if (config->seat_id)
+		seat_id = config->seat_id;
+
+	/* Check if we run drm-backend using weston-launch */
+	compositor->launcher = weston_launcher_connect(compositor, config->tty,
+						       seat_id, true);
+	if (compositor->launcher == NULL) {
+		weston_log("fatal: drm backend should be run "
+			   "using weston-launch binary or as root\n");
+		goto err_compositor;
+	}
+
+	b->udev = udev_new();
+	if (b->udev == NULL) {
+		weston_log("failed to initialize udev context\n");
+		goto err_launcher;
+	}
+
+	b->session_listener.notify = session_notify;
+	wl_signal_add(&compositor->session_signal, &b->session_listener);
+
+	drm_device = find_primary_gpu(b, seat_id);
+	if (drm_device == NULL) {
+		weston_log("no drm device found\n");
+		goto err_udev;
+	}
+	path = udev_device_get_syspath(drm_device);
+
+	if (init_drm(b, drm_device) < 0) {
+		weston_log("failed to initialize kms\n");
+		goto err_udev_dev;
+	}
+
+	if (b->use_pixman) {
+		if (init_pixman(b) < 0) {
+			weston_log("failed to initialize pixman renderer\n");
+			goto err_udev_dev;
+		}
+	} else {
+		if (init_egl(b) < 0) {
+			weston_log("failed to initialize egl\n");
+			goto err_udev_dev;
+		}
+	}
+
+	b->base.destroy = drm_destroy;
+	b->base.restore = drm_restore;
+
+	b->prev_state = WESTON_COMPOSITOR_ACTIVE;
+
+	weston_setup_vt_switch_bindings(compositor);
+
+	wl_list_init(&b->sprite_list);
+	create_sprites(b);
+
+	if (udev_input_init(&b->input,
+			    compositor, b->udev, seat_id,
+			    config->configure_device) < 0) {
+		weston_log("failed to create input devices\n");
+		goto err_sprite;
+	}
+
+	if (create_outputs(b, config->connector, drm_device) < 0) {
+		weston_log("failed to create output for %s\n", path);
+		goto err_udev_input;
+	}
+
+	/* A this point we have some idea of whether or not we have a working
+	 * cursor plane. */
+	if (!b->cursors_are_broken[0] || !b->cursors_are_broken[1])
+		compositor->capabilities |= WESTON_CAP_CURSOR_PLANE;
+
+	path = NULL;
+
+	loop = wl_display_get_event_loop(compositor->wl_display);
+	b->drm_source =
+		wl_event_loop_add_fd(loop, b->drm.fd,
+				     WL_EVENT_READABLE, on_drm_input, b);
+
+	b->udev_monitor = udev_monitor_new_from_netlink(b->udev, "udev");
+	if (b->udev_monitor == NULL) {
+		weston_log("failed to intialize udev monitor\n");
+		goto err_drm_source;
+	}
+	udev_monitor_filter_add_match_subsystem_devtype(b->udev_monitor,
+							"drm", NULL);
+	b->udev_drm_source =
+		wl_event_loop_add_fd(loop,
+				     udev_monitor_get_fd(b->udev_monitor),
+				     WL_EVENT_READABLE, udev_drm_event, b);
+
+	if (udev_monitor_enable_receiving(b->udev_monitor) < 0) {
+		weston_log("failed to enable udev-monitor receiving\n");
+		goto err_udev_monitor;
+	}
+
+	udev_device_unref(drm_device);
+
+	capture_create(b);
+
+	weston_compositor_add_debug_binding(compositor, KEY_O,
+					    planes_binding, b);
+	weston_compositor_add_debug_binding(compositor, KEY_C,
+					    planes_binding, b);
+	weston_compositor_add_debug_binding(compositor, KEY_V,
+					    planes_binding, b);
+	weston_compositor_add_debug_binding(compositor, KEY_Q,
+					    recorder_binding, b);
+	weston_compositor_add_debug_binding(compositor, KEY_W,
+					    renderer_switch_binding, b);
+
+	if (compositor->renderer->import_dmabuf) {
+		if (linux_dmabuf_setup(compositor) < 0)
+			weston_log("Error: initializing dmabuf "
+				   "support failed.\n");
+	}
+
+	compositor->backend = &b->base;
+
+	ret = weston_plugin_api_register(compositor, WESTON_DRM_OUTPUT_API_NAME,
+					 &api, sizeof(api));
+
+	if (ret < 0) {
+		weston_log("Failed to register output API.\n");
+		goto err_udev_monitor;
+	}
+
+	return b;
+
+err_udev_monitor:
+	wl_event_source_remove(b->udev_drm_source);
+	udev_monitor_unref(b->udev_monitor);
+err_drm_source:
+	wl_event_source_remove(b->drm_source);
+err_udev_input:
+	udev_input_destroy(&b->input);
+err_sprite:
+	if (b->gbm)
+		gbm_device_destroy(b->gbm);
+	destroy_sprites(b);
+err_udev_dev:
+	udev_device_unref(drm_device);
+err_launcher:
+	weston_launcher_destroy(compositor->launcher);
+err_udev:
+	udev_unref(b->udev);
+err_compositor:
+	weston_compositor_shutdown(compositor);
+	free(b);
+	return NULL;
+}
+
+static void
+config_init_to_defaults(struct weston_drm_backend_config *config)
+{
+}
+
+WL_EXPORT int
+backend_init(struct weston_compositor *compositor,
+	     struct weston_backend_config *config_base)
+{
+	struct drm_backend *b;
+	struct weston_drm_backend_config config = {{ 0, }};
+
+	if (config_base == NULL ||
+	    config_base->struct_version != WESTON_DRM_BACKEND_CONFIG_VERSION ||
+	    config_base->struct_size > sizeof(struct weston_drm_backend_config)) {
+		weston_log("drm backend config structure is invalid\n");
+		return -1;
+	}
+
+	config_init_to_defaults(&config);
+	memcpy(&config, config_base, config_base->struct_size);
+
+	b = drm_backend_create(compositor, &config);
+	if (b == NULL)
+		return -1;
+
+	return 0;
+}
diff --git a/libweston/compositor-wayland.c b/libweston/compositor-wayland.c
index c223baa..46fdde1 100644
--- a/libweston/compositor-wayland.c
+++ b/libweston/compositor-wayland.c
@@ -26,6 +26,7 @@
 
 #include "config.h"
 
+#include <assert.h>
 #include <stddef.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -43,6 +44,7 @@
 #include "compositor.h"
 #include "compositor-wayland.h"
 #include "gl-renderer.h"
+#include "weston-egl-ext.h"
 #include "pixman-renderer.h"
 #include "shared/helpers.h"
 #include "shared/image-loader.h"
@@ -51,6 +53,7 @@
 #include "fullscreen-shell-unstable-v1-client-protocol.h"
 #include "presentation-time-server-protocol.h"
 #include "linux-dmabuf.h"
+#include "windowed-output-api.h"
 
 #define WINDOW_TITLE "Weston Compositor"
 
@@ -74,6 +77,7 @@ struct wayland_backend {
 
 	int use_pixman;
 	int sprawl_across_outputs;
+	int fullscreen;
 
 	struct theme *theme;
 	cairo_device_t *frame_device;
@@ -617,22 +621,34 @@ wayland_output_repaint_pixman(struct weston_output *output_base,
 }
 
 static void
-wayland_output_destroy(struct weston_output *output_base)
+wayland_backend_destroy_output_surface(struct wayland_output *output)
 {
-	struct wayland_output *output = to_wayland_output(output_base);
-	struct wayland_backend *b =
-		to_wayland_backend(output->base.compositor);
+	if (output->parent.shell_surface)
+		wl_shell_surface_destroy(output->parent.shell_surface);
+
+	wl_surface_destroy(output->parent.surface);
+}
+
+static int
+wayland_output_disable(struct weston_output *base)
+{
+	struct wayland_output *output = to_wayland_output(base);
+	struct wayland_backend *b = to_wayland_backend(base->compositor);
+
+	if (!output->base.enabled)
+		return 0;
 
 	if (b->use_pixman) {
-		pixman_renderer_output_destroy(output_base);
+		pixman_renderer_output_destroy(&output->base);
 	} else {
-		gl_renderer->output_destroy(output_base);
+		gl_renderer->output_destroy(&output->base);
 		wl_egl_window_destroy(output->gl.egl_window);
 	}
 
-	wl_surface_destroy(output->parent.surface);
-	if (output->parent.shell_surface)
-		wl_shell_surface_destroy(output->parent.shell_surface);
+	/* Done on output->enable when not fullscreen, otherwise
+	 * done in output_create, to get the proper mode */
+	if (!b->fullscreen)
+		wayland_backend_destroy_output_surface(output);
 
 	if (output->frame)
 		frame_destroy(output->frame);
@@ -642,10 +658,23 @@ wayland_output_destroy(struct weston_output *output_base)
 	cairo_surface_destroy(output->gl.border.right);
 	cairo_surface_destroy(output->gl.border.bottom);
 
+	return 0;
+}
+
+static void
+wayland_output_destroy(struct weston_output *base)
+{
+	struct wayland_output *output = to_wayland_output(base);
+	struct wayland_backend *b = to_wayland_backend(base->compositor);
+
+	wayland_output_disable(&output->base);
+
+	if (b->fullscreen)
+		wayland_backend_destroy_output_surface(output);
+
 	weston_output_destroy(&output->base);
-	free(output);
 
-	return;
+	free(output);
 }
 
 static const struct wl_shell_surface_listener shell_surface_listener;
@@ -1002,32 +1031,16 @@ err_output:
 	return -1;
 }
 
-static struct wayland_output *
-wayland_output_create(struct wayland_backend *b, int x, int y,
-		      int width, int height, const char *name, int fullscreen,
-		      uint32_t transform, int32_t scale)
+static int
+wayland_backend_create_output_surface(struct wayland_output *output)
 {
-	struct wayland_output *output;
-	int output_width, output_height;
-
-	weston_log("Creating %dx%d wayland output at (%d, %d)\n",
-		   width, height, x, y);
-
-	output = zalloc(sizeof *output);
-	if (output == NULL)
-		return NULL;
-
-	output->name = name ? strdup(name) : NULL;
-	output->base.make = "wayland";
-	output->base.model = "none";
-
-	output_width = width * scale;
-	output_height = height * scale;
+	struct wayland_backend *b = to_wayland_backend(output->base.compositor);
 
 	output->parent.surface =
 		wl_compositor_create_surface(b->parent.compositor);
 	if (!output->parent.surface)
-		goto err_name;
+		return -1;
+
 	wl_surface_set_user_data(output->parent.surface, output);
 
 	output->parent.draw_initial_frame = 1;
@@ -1036,94 +1049,187 @@ wayland_output_create(struct wayland_backend *b, int x, int y,
 		output->parent.shell_surface =
 			wl_shell_get_shell_surface(b->parent.shell,
 						   output->parent.surface);
-		if (!output->parent.shell_surface)
-			goto err_surface;
+		if (!output->parent.shell_surface) {
+			wl_surface_destroy(output->parent.surface);
+			return -1;
+		}
+
 		wl_shell_surface_add_listener(output->parent.shell_surface,
 					      &shell_surface_listener, output);
 	}
 
-	if (fullscreen && b->parent.shell) {
-		wl_shell_surface_set_fullscreen(output->parent.shell_surface,
-						0, 0, NULL);
-		wl_display_roundtrip(b->parent.wl_display);
-		if (!width)
-			output_width = output->parent.configure_width;
-		if (!height)
-			output_height = output->parent.configure_height;
-	}
+	return 0;
+}
+
+static int
+wayland_output_enable(struct weston_output *base)
+{
+	struct wayland_output *output = to_wayland_output(base);
+	struct wayland_backend *b = to_wayland_backend(base->compositor);
+	int ret = 0;
 
-	output->mode.flags =
-		WL_OUTPUT_MODE_CURRENT | WL_OUTPUT_MODE_PREFERRED;
-	output->mode.width = output_width;
-	output->mode.height = output_height;
-	output->mode.refresh = 60000;
-	output->scale = scale;
-	wl_list_init(&output->base.mode_list);
-	wl_list_insert(&output->base.mode_list, &output->mode.link);
-	output->base.current_mode = &output->mode;
+
+	weston_log("Creating %dx%d wayland output at (%d, %d)\n",
+		   output->base.current_mode->width,
+		   output->base.current_mode->height,
+		   output->base.x, output->base.y);
+
+	/* If fullscreen was specified, this needs to be done before
+	 * enable to get the proper mode */
+	if (!b->fullscreen)
+		ret = wayland_backend_create_output_surface(output);
+
+	if (ret < 0)
+		return -1;
 
 	wl_list_init(&output->shm.buffers);
 	wl_list_init(&output->shm.free_buffers);
 
-	weston_output_init(&output->base, b->compositor, x, y, width, height,
-			   transform, scale);
-
 	if (b->use_pixman) {
 		if (wayland_output_init_pixman_renderer(output) < 0)
 			goto err_output;
-		output->base.repaint = wayland_output_repaint_pixman;
 	} else {
 		if (wayland_output_init_gl_renderer(output) < 0)
 			goto err_output;
-		output->base.repaint = wayland_output_repaint_gl;
 	}
 
-	output->base.start_repaint_loop = wayland_output_start_repaint_loop;
-	output->base.destroy = wayland_output_destroy;
-	output->base.assign_planes = NULL;
-	output->base.set_backlight = NULL;
-	output->base.set_dpms = NULL;
-	output->base.switch_mode = wayland_output_switch_mode;
-
-	weston_compositor_add_output(b->compositor, &output->base);
+	if (b->sprawl_across_outputs) {
+		wayland_output_set_fullscreen(output,
+					      WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER,
+					      output->mode.refresh, output->parent.output);
+
+		if (output->parent.shell_surface) {
+			wl_shell_surface_set_fullscreen(output->parent.shell_surface,
+							WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER,
+							output->mode.refresh, output->parent.output);
+		} else if (b->parent.fshell) {
+			zwp_fullscreen_shell_v1_present_surface(b->parent.fshell,
+								output->parent.surface,
+								ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_CENTER,
+								output->parent.output);
+			zwp_fullscreen_shell_mode_feedback_v1_destroy(
+				zwp_fullscreen_shell_v1_present_surface_for_mode(b->parent.fshell,
+										 output->parent.surface,
+										 output->parent.output,
+										 output->mode.refresh));
+		}
+	} else if (b->fullscreen) {
+		wayland_output_set_fullscreen(output, 0, 0, NULL);
+	} else {
+		wayland_output_set_windowed(output);
+	}
 
-	return output;
+	return 0;
 
 err_output:
-	weston_output_destroy(&output->base);
-	if (output->parent.shell_surface)
-		wl_shell_surface_destroy(output->parent.shell_surface);
-err_surface:
-	wl_surface_destroy(output->parent.surface);
-err_name:
-	free(output->name);
-
-	/* FIXME: cleanup weston_output */
-	free(output);
+	if (!b->fullscreen)
+		wayland_backend_destroy_output_surface(output);
 
-	return NULL;
+	return -1;
 }
 
 static struct wayland_output *
-wayland_output_create_for_config(struct wayland_backend *b,
-				 struct weston_wayland_backend_output_config *oc,
-				 int fullscreen, int32_t x, int32_t y)
+wayland_output_create_common(void)
 {
 	struct wayland_output *output;
 
-	output = wayland_output_create(b, x, y, oc->width, oc->height, oc->name,
-				       fullscreen, oc->transform, oc->scale);
+	output = zalloc(sizeof *output);
+	if (output == NULL) {
+		perror("zalloc");
+		return NULL;
+	}
+
+	output->base.destroy = wayland_output_destroy;
+	output->base.disable = wayland_output_disable;
+	output->base.enable = wayland_output_enable;
 
 	return output;
 }
 
-static struct wayland_output *
+static int
+wayland_output_create(struct weston_compositor *compositor, const char *name)
+{
+	struct wayland_output *output = wayland_output_create_common();
+
+	/* name can't be NULL. */
+	assert(name);
+
+	output->base.name = strdup(name);
+
+	weston_output_init(&output->base, compositor);
+	weston_compositor_add_pending_output(&output->base, compositor);
+
+	return 0;
+}
+
+static int
+wayland_output_set_size(struct weston_output *base, int width, int height)
+{
+	struct wayland_output *output = to_wayland_output(base);
+	struct wayland_backend *b = to_wayland_backend(base->compositor);
+	int output_width, output_height;
+
+	/* We can only be called once. */
+	assert(!output->base.current_mode);
+
+	/* Make sure we have scale set. */
+	assert(output->base.scale);
+
+	if (width < 1) {
+		weston_log("Invalid width \"%d\" for output %s\n",
+			   width, output->base.name);
+		return -1;
+	}
+
+	if (height < 1) {
+		weston_log("Invalid height \"%d\" for output %s\n",
+			   height, output->base.name);
+		return -1;
+	}
+
+	output_width = width * output->base.scale;
+	output_height = height * output->base.scale;
+
+	output->mode.flags =
+		WL_OUTPUT_MODE_CURRENT | WL_OUTPUT_MODE_PREFERRED;
+
+	output->mode.width = output_width;
+	output->mode.height = output_height;
+	output->mode.refresh = 60000;
+	output->scale = output->base.scale;
+	wl_list_init(&output->base.mode_list);
+	wl_list_insert(&output->base.mode_list, &output->mode.link);
+
+	output->base.current_mode = &output->mode;
+	output->base.make = "wayland";
+	output->base.model = "none";
+
+	/* XXX: Calculate proper size. */
+	output->base.mm_width = width;
+	output->base.mm_height = height;
+
+	if (b->use_pixman)
+		output->base.repaint = wayland_output_repaint_pixman;
+	else
+		output->base.repaint = wayland_output_repaint_gl;
+
+	output->base.start_repaint_loop = wayland_output_start_repaint_loop;
+	output->base.assign_planes = NULL;
+	output->base.set_backlight = NULL;
+	output->base.set_dpms = NULL;
+	output->base.switch_mode = wayland_output_switch_mode;
+
+	return 0;
+}
+
+static int
 wayland_output_create_for_parent_output(struct wayland_backend *b,
 					struct wayland_parent_output *poutput)
 {
-	struct wayland_output *output;
+	struct wayland_output *output = wayland_output_create_common();
 	struct weston_mode *mode;
-	int32_t x;
+
+	output->base.name = strdup("wlparent");
 
 	if (poutput->current_mode) {
 		mode = poutput->current_mode;
@@ -1133,53 +1239,80 @@ wayland_output_create_for_parent_output(struct wayland_backend *b,
 		mode = container_of(poutput->mode_list.next,
 				    struct weston_mode, link);
 	} else {
-		weston_log("No valid modes found.  Skipping output\n");
-		return NULL;
+		weston_log("No valid modes found. Skipping output.\n");
+		goto out;
 	}
 
-	if (!wl_list_empty(&b->compositor->output_list)) {
-		output = container_of(b->compositor->output_list.prev,
-				      struct wayland_output, base.link);
-		x = output->base.x + output->base.current_mode->width;
-	} else {
-		x = 0;
-	}
+	weston_output_init(&output->base, b->compositor);
 
-	output = wayland_output_create(b, x, 0, mode->width, mode->height,
-				       NULL, 0,
-				       WL_OUTPUT_TRANSFORM_NORMAL, 1);
-	if (!output)
-		return NULL;
+	output->base.scale = 1;
+	output->base.transform = WL_OUTPUT_TRANSFORM_NORMAL;
+
+	if (wayland_output_set_size(&output->base, mode->width, mode->height) < 0)
+		goto out;
 
+	output->mode = *mode;
 	output->parent.output = poutput->global;
 
 	output->base.make = poutput->physical.make;
 	output->base.model = poutput->physical.model;
+
+	/* XXX: Clear previously added values */
 	wl_list_init(&output->base.mode_list);
 	wl_list_insert_list(&output->base.mode_list, &poutput->mode_list);
 	wl_list_init(&poutput->mode_list);
 
-	wayland_output_set_fullscreen(output,
-				      WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER,
-				      mode->refresh, poutput->global);
+	weston_compositor_add_pending_output(&output->base, b->compositor);
 
-	if (output->parent.shell_surface) {
+	return 0;
+
+out:
+	free(output->name);
+	free(output);
+
+	return -1;
+}
+
+static int
+wayland_output_create_fullscreen(struct wayland_backend *b)
+{
+	struct wayland_output *output = wayland_output_create_common();
+	int width = 0, height = 0;
+
+	output->base.name = strdup("wayland-fullscreen");
+
+	weston_output_init(&output->base, b->compositor);
+
+	output->base.scale = 1;
+	output->base.transform = WL_OUTPUT_TRANSFORM_NORMAL;
+
+	if (wayland_backend_create_output_surface(output) < 0)
+		goto err_surface;
+
+	/* What should size be set if conditional is false? */
+	if (b->parent.shell) {
 		wl_shell_surface_set_fullscreen(output->parent.shell_surface,
-						WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER,
-						mode->refresh, poutput->global);
-	} else if (b->parent.fshell) {
-		zwp_fullscreen_shell_v1_present_surface(b->parent.fshell,
-							output->parent.surface,
-							ZWP_FULLSCREEN_SHELL_V1_PRESENT_METHOD_CENTER,
-							poutput->global);
-		zwp_fullscreen_shell_mode_feedback_v1_destroy(
-			zwp_fullscreen_shell_v1_present_surface_for_mode(b->parent.fshell,
-									 output->parent.surface,
-									 poutput->global,
-									 mode->refresh));
+						0, 0, NULL);
+		wl_display_roundtrip(b->parent.wl_display);
+
+		width = output->parent.configure_width;
+		height = output->parent.configure_height;
 	}
 
-	return output;
+	if (wayland_output_set_size(&output->base, width, height) < 0)
+		goto err_set_size;
+
+	weston_compositor_add_pending_output(&output->base, b->compositor);
+
+	return 0;
+
+err_set_size:
+	wayland_backend_destroy_output_surface(output);
+err_surface:
+	free(output->name);
+	free(output);
+
+	return -1;
 }
 
 static void
@@ -1363,22 +1496,17 @@ input_handle_motion(void *data, struct wl_pointer *pointer,
 static void
 input_handle_button(void *data, struct wl_pointer *pointer,
 		    uint32_t serial, uint32_t time, uint32_t button,
-		    uint32_t state_w)
+		    enum wl_pointer_button_state state)
 {
 	struct wayland_input *input = data;
-	enum wl_pointer_button_state state = state_w;
-	enum frame_button_state fstate;
 	enum theme_location location;
 
 	if (!input->output)
 		return;
 
 	if (input->output->frame) {
-		fstate = state == WL_POINTER_BUTTON_STATE_PRESSED ?
-			FRAME_BUTTON_PRESSED : FRAME_BUTTON_RELEASED;
-
 		location = frame_pointer_button(input->output->frame, input,
-						button, fstate);
+						button, state);
 
 		if (frame_status(input->output->frame) & FRAME_STATUS_MOVE) {
 
@@ -2211,6 +2339,7 @@ wayland_backend_create(struct weston_compositor *compositor,
 	create_cursor(b, new_config);
 
 	b->use_pixman = new_config->use_pixman;
+	b->fullscreen = new_config->fullscreen;
 
 	if (!b->use_pixman) {
 		gl_renderer = weston_load_module("gl-renderer.so",
@@ -2284,6 +2413,11 @@ wayland_backend_destroy(struct wayland_backend *b)
 	free(b);
 }
 
+static const struct weston_windowed_output_api windowed_api = {
+	wayland_output_set_size,
+	wayland_output_create,
+};
+
 static void
 config_init_to_defaults(struct weston_wayland_backend_config *config)
 {
@@ -2294,10 +2428,9 @@ backend_init(struct weston_compositor *compositor,
 	     struct weston_backend_config *config_base)
 {
 	struct wayland_backend *b;
-	struct wayland_output *output;
 	struct wayland_parent_output *poutput;
 	struct weston_wayland_backend_config new_config;
-	int x, count;
+	int ret;
 
 	if (config_base == NULL ||
 	    config_base->struct_version != WESTON_WAYLAND_BACKEND_CONFIG_VERSION ||
@@ -2325,29 +2458,21 @@ backend_init(struct weston_compositor *compositor,
 	}
 
 	if (new_config.fullscreen) {
-		if (new_config.num_outputs != 1 || !new_config.outputs)
-			goto err_outputs;
-
-		output = wayland_output_create_for_config(b,
-							  &new_config.outputs[0],
-							  1, 0, 0);
-		if (!output)
+		if (wayland_output_create_fullscreen(b) < 0) {
+			weston_log("Unable to create a fullscreen output.\n");
 			goto err_outputs;
+		}
 
-		wayland_output_set_fullscreen(output, 0, 0, NULL);
 		return 0;
 	}
 
-	x = 0;
-	for (count = 0; count < new_config.num_outputs; ++count) {
-		output = wayland_output_create_for_config(b, &new_config.outputs[count],
-							  0, x, 0);
-		if (!output)
-			goto err_outputs;
-		if (wayland_output_set_windowed(output))
-			goto err_outputs;
+	ret = weston_plugin_api_register(compositor, WESTON_WINDOWED_OUTPUT_API_NAME,
+					 &windowed_api, sizeof(windowed_api));
 
-		x += output->base.width;
+	if (ret < 0) {
+		weston_log("Failed to register output API.\n");
+		wayland_backend_destroy(b);
+		return -1;
 	}
 
 	weston_compositor_add_key_binding(compositor, KEY_F,
diff --git a/libweston/compositor-wayland.h b/libweston/compositor-wayland.h
index b705dee..58e0fb1 100644
--- a/libweston/compositor-wayland.h
+++ b/libweston/compositor-wayland.h
@@ -34,15 +34,7 @@ extern "C" {
 
 #include <stdint.h>
 
-#define WESTON_WAYLAND_BACKEND_CONFIG_VERSION 1
-
-struct weston_wayland_backend_output_config {
-	int width;
-	int height;
-	char *name;
-	uint32_t transform;
-	int32_t scale;
-};
+#define WESTON_WAYLAND_BACKEND_CONFIG_VERSION 2
 
 struct weston_wayland_backend_config {
 	struct weston_backend_config base;
@@ -52,8 +44,6 @@ struct weston_wayland_backend_config {
 	int fullscreen;
 	char *cursor_theme;
 	int cursor_size;
-	int num_outputs;
-	struct weston_wayland_backend_output_config *outputs;
 };
 
 #ifdef  __cplusplus
diff --git a/libweston/compositor-x11.c b/libweston/compositor-x11.c
index 3e0d20f..1c6de08 100644
--- a/libweston/compositor-x11.c
+++ b/libweston/compositor-x11.c
@@ -56,9 +56,11 @@
 #include "shared/helpers.h"
 #include "shared/image-loader.h"
 #include "gl-renderer.h"
+#include "weston-egl-ext.h"
 #include "pixman-renderer.h"
 #include "presentation-time-server-protocol.h"
 #include "linux-dmabuf.h"
+#include "windowed-output-api.h"
 
 #define DEFAULT_AXIS_STEP_DISTANCE 10
 
@@ -75,6 +77,8 @@ struct x11_backend {
 	struct xkb_keymap	*xkb_keymap;
 	unsigned int		 has_xkb;
 	uint8_t			 xkb_event_base;
+	int			 fullscreen;
+	int			 no_input;
 	int			 use_pixman;
 
 	int			 has_net_wm_state_fullscreen;
@@ -516,30 +520,6 @@ x11_output_deinit_shm(struct x11_backend *b, struct x11_output *output)
 }
 
 static void
-x11_output_destroy(struct weston_output *output_base)
-{
-	struct x11_output *output = to_x11_output(output_base);
-	struct x11_backend *backend =
-		to_x11_backend(output->base.compositor);
-
-	wl_event_source_remove(output->finish_frame_timer);
-
-	if (backend->use_pixman) {
-		pixman_renderer_output_destroy(output_base);
-		x11_output_deinit_shm(backend, output);
-	} else
-		gl_renderer->output_destroy(output_base);
-
-	xcb_destroy_window(backend->conn, output->window);
-
-	xcb_flush(backend->conn);
-
-	weston_output_destroy(&output->base);
-
-	free(output);
-}
-
-static void
 x11_output_set_wm_protocols(struct x11_backend *b,
 			    struct x11_output *output)
 {
@@ -789,20 +769,54 @@ x11_output_init_shm(struct x11_backend *b, struct x11_output *output,
 	return 0;
 }
 
-static struct x11_output *
-x11_backend_create_output(struct x11_backend *b, int x, int y,
-			     int width, int height, int fullscreen,
-			     int no_input, char *configured_name,
-			     uint32_t transform, int32_t scale)
+static int
+x11_output_disable(struct weston_output *base)
+{
+	struct x11_output *output = to_x11_output(base);
+	struct x11_backend *backend = to_x11_backend(base->compositor);
+
+	if (!output->base.enabled)
+		return 0;
+
+	wl_event_source_remove(output->finish_frame_timer);
+
+	if (backend->use_pixman) {
+		pixman_renderer_output_destroy(&output->base);
+		x11_output_deinit_shm(backend, output);
+	} else {
+		gl_renderer->output_destroy(&output->base);
+	}
+
+	xcb_destroy_window(backend->conn, output->window);
+	xcb_flush(backend->conn);
+
+	return 0;
+}
+
+static void
+x11_output_destroy(struct weston_output *base)
+{
+	struct x11_output *output = to_x11_output(base);
+
+	x11_output_disable(&output->base);
+	weston_output_destroy(&output->base);
+
+	free(output);
+}
+
+static int
+x11_output_enable(struct weston_output *base)
 {
+	struct x11_output *output = to_x11_output(base);
+	struct x11_backend *b = to_x11_backend(base->compositor);
+
 	static const char name[] = "Weston Compositor";
 	static const char class[] = "weston-1\0Weston Compositor";
 	char *title = NULL;
-	struct x11_output *output;
 	xcb_screen_t *screen;
 	struct wm_normal_hints normal_hints;
 	struct wl_event_loop *loop;
-	int output_width, output_height, width_mm, height_mm;
+
 	int ret;
 	uint32_t mask = XCB_CW_EVENT_MASK | XCB_CW_CURSOR;
 	xcb_atom_t atom_list[1];
@@ -812,10 +826,7 @@ x11_backend_create_output(struct x11_backend *b, int x, int y,
 		0
 	};
 
-	output_width = width * scale;
-	output_height = height * scale;
-
-	if (!no_input)
+	if (!b->no_input)
 		values[0] |=
 			XCB_EVENT_MASK_KEY_PRESS |
 			XCB_EVENT_MASK_KEY_RELEASE |
@@ -827,22 +838,6 @@ x11_backend_create_output(struct x11_backend *b, int x, int y,
 			XCB_EVENT_MASK_KEYMAP_STATE |
 			XCB_EVENT_MASK_FOCUS_CHANGE;
 
-	output = zalloc(sizeof *output);
-	if (output == NULL) {
-		perror("zalloc");
-		return NULL;
-	}
-
-	output->mode.flags =
-		WL_OUTPUT_MODE_CURRENT | WL_OUTPUT_MODE_PREFERRED;
-
-	output->mode.width = output_width;
-	output->mode.height = output_height;
-	output->mode.refresh = 60000;
-	output->scale = scale;
-	wl_list_init(&output->base.mode_list);
-	wl_list_insert(&output->base.mode_list, &output->mode.link);
-
 	values[1] = b->null_cursor;
 	output->window = xcb_generate_id(b->conn);
 	screen = x11_compositor_get_default_screen(b);
@@ -851,13 +846,14 @@ x11_backend_create_output(struct x11_backend *b, int x, int y,
 			  output->window,
 			  screen->root,
 			  0, 0,
-			  output_width, output_height,
+			  output->base.current_mode->width,
+			  output->base.current_mode->height,
 			  0,
 			  XCB_WINDOW_CLASS_INPUT_OUTPUT,
 			  screen->root_visual,
 			  mask, values);
 
-	if (fullscreen) {
+	if (b->fullscreen) {
 		atom_list[0] = b->atom.net_wm_state_fullscreen;
 		xcb_change_property(b->conn, XCB_PROP_MODE_REPLACE,
 				    output->window,
@@ -869,10 +865,10 @@ x11_backend_create_output(struct x11_backend *b, int x, int y,
 		memset(&normal_hints, 0, sizeof normal_hints);
 		normal_hints.flags =
 			WM_NORMAL_HINTS_MAX_SIZE | WM_NORMAL_HINTS_MIN_SIZE;
-		normal_hints.min_width = output_width;
-		normal_hints.min_height = output_height;
-		normal_hints.max_width = output_width;
-		normal_hints.max_height = output_height;
+		normal_hints.min_width = output->base.current_mode->width;
+		normal_hints.min_height = output->base.current_mode->height;
+		normal_hints.max_width = output->base.current_mode->width;
+		normal_hints.max_height = output->base.current_mode->height;
 		xcb_change_property(b->conn, XCB_PROP_MODE_REPLACE, output->window,
 				    b->atom.wm_normal_hints,
 				    b->atom.wm_size_hints, 32,
@@ -881,8 +877,8 @@ x11_backend_create_output(struct x11_backend *b, int x, int y,
 	}
 
 	/* Set window name.  Don't bother with non-EWMH WMs. */
-	if (configured_name) {
-		if (asprintf(&title, "%s - %s", name, configured_name) < 0)
+	if (output->base.name) {
+		if (asprintf(&title, "%s - %s", name, output->base.name) < 0)
 			title = NULL;
 	} else {
 		title = strdup(name);
@@ -894,9 +890,7 @@ x11_backend_create_output(struct x11_backend *b, int x, int y,
 				    strlen(title), title);
 		free(title);
 	} else {
-		xcb_destroy_window(b->conn, output->window);
-		free(output);
-		return NULL;
+		goto err;
 	}
 
 	xcb_change_property(b->conn, XCB_PROP_MODE_REPLACE, output->window,
@@ -909,44 +903,20 @@ x11_backend_create_output(struct x11_backend *b, int x, int y,
 
 	xcb_map_window(b->conn, output->window);
 
-	if (fullscreen)
+	if (b->fullscreen)
 		x11_output_wait_for_map(b, output);
 
-	output->base.start_repaint_loop = x11_output_start_repaint_loop;
-	if (b->use_pixman)
-		output->base.repaint = x11_output_repaint_shm;
-	else
-		output->base.repaint = x11_output_repaint_gl;
-	output->base.destroy = x11_output_destroy;
-	output->base.assign_planes = NULL;
-	output->base.set_backlight = NULL;
-	output->base.set_dpms = NULL;
-	output->base.switch_mode = NULL;
-	output->base.current_mode = &output->mode;
-	output->base.make = "weston-X11";
-	output->base.model = "none";
-
-	if (configured_name)
-		output->base.name = strdup(configured_name);
-
-	width_mm = width * b->screen->width_in_millimeters /
-		b->screen->width_in_pixels;
-	height_mm = height * b->screen->height_in_millimeters /
-		b->screen->height_in_pixels;
-	weston_output_init(&output->base, b->compositor,
-			   x, y, width_mm, height_mm, transform, scale);
-
 	if (b->use_pixman) {
 		if (x11_output_init_shm(b, output,
-					output->mode.width,
-					output->mode.height) < 0) {
+					output->base.current_mode->width,
+					output->base.current_mode->height) < 0) {
 			weston_log("Failed to initialize SHM for the X11 output\n");
-			return NULL;
+			goto err;
 		}
 		if (pixman_renderer_output_create(&output->base) < 0) {
 			weston_log("Failed to create pixman renderer for output\n");
 			x11_output_deinit_shm(b, output);
-			return NULL;
+			goto err;
 		}
 	} else {
 		/* eglCreatePlatformWindowSurfaceEXT takes a Window*
@@ -960,19 +930,112 @@ x11_backend_create_output(struct x11_backend *b, int x, int y,
 						 NULL,
 						 0);
 		if (ret < 0)
-			return NULL;
+			goto err;
 	}
 
 	loop = wl_display_get_event_loop(b->compositor->wl_display);
 	output->finish_frame_timer =
 		wl_event_loop_add_timer(loop, finish_frame_handler, output);
 
-	weston_compositor_add_output(b->compositor, &output->base);
-
 	weston_log("x11 output %dx%d, window id %d\n",
-		   width, height, output->window);
+		   output->base.current_mode->width,
+		   output->base.current_mode->height,
+		   output->window);
+
+	return 0;
 
-	return output;
+err:
+	xcb_destroy_window(b->conn, output->window);
+	xcb_flush(b->conn);
+
+	return -1;
+}
+
+static int
+x11_output_set_size(struct weston_output *base, int width, int height)
+{
+	struct x11_output *output = to_x11_output(base);
+	struct x11_backend *b = to_x11_backend(base->compositor);
+	int output_width, output_height;
+
+	/* We can only be called once. */
+	assert(!output->base.current_mode);
+
+	/* Make sure we have scale set. */
+	assert(output->base.scale);
+
+	if (width < 1) {
+		weston_log("Invalid width \"%d\" for output %s\n",
+			   width, output->base.name);
+		return -1;
+	}
+
+	if (height < 1) {
+		weston_log("Invalid height \"%d\" for output %s\n",
+			   height, output->base.name);
+		return -1;
+	}
+
+	output_width = width * output->base.scale;
+	output_height = height * output->base.scale;
+
+	output->mode.flags =
+		WL_OUTPUT_MODE_CURRENT | WL_OUTPUT_MODE_PREFERRED;
+
+	output->mode.width = output_width;
+	output->mode.height = output_height;
+	output->mode.refresh = 60000;
+	output->scale = output->base.scale;
+	wl_list_init(&output->base.mode_list);
+	wl_list_insert(&output->base.mode_list, &output->mode.link);
+
+	output->base.current_mode = &output->mode;
+	output->base.make = "weston-X11";
+	output->base.model = "none";
+
+	output->base.mm_width = width * b->screen->width_in_millimeters /
+		b->screen->width_in_pixels;
+	output->base.mm_height = height * b->screen->height_in_millimeters /
+		b->screen->height_in_pixels;
+
+	if (b->use_pixman)
+		output->base.repaint = x11_output_repaint_shm;
+	else
+		output->base.repaint = x11_output_repaint_gl;
+
+	output->base.start_repaint_loop = x11_output_start_repaint_loop;
+	output->base.assign_planes = NULL;
+	output->base.set_backlight = NULL;
+	output->base.set_dpms = NULL;
+	output->base.switch_mode = NULL;
+
+	return 0;
+}
+
+static int
+x11_output_create(struct weston_compositor *compositor,
+		  const char *name)
+{
+	struct x11_output *output;
+
+	/* name can't be NULL. */
+	assert(name);
+
+	output = zalloc(sizeof *output);
+	if (output == NULL) {
+		perror("zalloc");
+		return -1;
+	}
+
+	output->base.name = strdup(name);
+	output->base.destroy = x11_output_destroy;
+	output->base.disable = x11_output_disable;
+	output->base.enable = x11_output_enable;
+
+	weston_output_init(&output->base, compositor);
+	weston_compositor_add_pending_output(&output->base, compositor);
+
+	return 0;
 }
 
 static struct x11_output *
@@ -1588,21 +1651,27 @@ init_gl_renderer(struct x11_backend *b)
 	return ret;
 }
 
+static const struct weston_windowed_output_api api = {
+	x11_output_set_size,
+	x11_output_create,
+};
+
 static struct x11_backend *
 x11_backend_create(struct weston_compositor *compositor,
 		   struct weston_x11_backend_config *config)
 {
 	struct x11_backend *b;
-	struct x11_output *output;
 	struct wl_event_loop *loop;
-	int x = 0;
-	unsigned i;
+	int ret;
 
 	b = zalloc(sizeof *b);
 	if (b == NULL)
 		return NULL;
 
 	b->compositor = compositor;
+	b->fullscreen = config->fullscreen;
+	b->no_input = config->no_input;
+
 	if (weston_compositor_set_presentation_clock_software(compositor) < 0)
 		goto err_free;
 
@@ -1648,44 +1717,6 @@ x11_backend_create(struct weston_compositor *compositor,
 		goto err_renderer;
 	}
 
-	for (i = 0; i < config->num_outputs; ++i) {
-		struct weston_x11_backend_output_config *output_iterator =
-			&config->outputs[i];
-
-		if (output_iterator->name == NULL) {
-			continue;
-		}
-
-		if (output_iterator->width < 1) {
-			weston_log("Invalid width \"%d\" for output %s\n",
-				   output_iterator->width, output_iterator->name);
-			goto err_x11_input;
-		}
-
-		if (output_iterator->height < 1) {
-			weston_log("Invalid height \"%d\" for output %s\n",
-				   output_iterator->height, output_iterator->name);
-			goto err_x11_input;
-		}
-
-		output = x11_backend_create_output(b,
-						   x,
-						   0,
-						   output_iterator->width,
-						   output_iterator->height,
-						   config->fullscreen,
-						   config->no_input,
-						   output_iterator->name,
-						   output_iterator->transform,
-						   output_iterator->scale);
-		if (output == NULL) {
-			weston_log("Failed to create configured x11 output\n");
-			goto err_x11_input;
-		}
-
-		x = pixman_region32_extents(&output->base.region)->x2;
-	}
-
 	loop = wl_display_get_event_loop(compositor->wl_display);
 	b->xcb_source =
 		wl_event_loop_add_fd(loop,
@@ -1702,6 +1733,14 @@ x11_backend_create(struct weston_compositor *compositor,
 
 	compositor->backend = &b->base;
 
+	ret = weston_plugin_api_register(compositor, WESTON_WINDOWED_OUTPUT_API_NAME,
+					 &api, sizeof(api));
+
+	if (ret < 0) {
+		weston_log("Failed to register output API.\n");
+		goto err_x11_input;
+	}
+
 	return b;
 
 err_x11_input:
diff --git a/libweston/compositor-x11.h b/libweston/compositor-x11.h
index 6a17f96..8989fc2 100644
--- a/libweston/compositor-x11.h
+++ b/libweston/compositor-x11.h
@@ -34,15 +34,7 @@ extern "C" {
 
 #include "compositor.h"
 
-#define WESTON_X11_BACKEND_CONFIG_VERSION 1
-
-struct weston_x11_backend_output_config {
-	int width;
-	int height;
-	char *name;
-	uint32_t transform;
-	int32_t scale;
-};
+#define WESTON_X11_BACKEND_CONFIG_VERSION 2
 
 struct weston_x11_backend_config {
 	struct weston_backend_config base;
@@ -52,9 +44,6 @@ struct weston_x11_backend_config {
 
 	/** Whether to use the pixman renderer instead of the OpenGL ES renderer. */
 	bool use_pixman;
-
-	uint32_t num_outputs;
-	struct weston_x11_backend_output_config *outputs;
 };
 
 #ifdef  __cplusplus
diff --git a/libweston/compositor.c b/libweston/compositor.c
index 47907bb..9e7c34e 100644
--- a/libweston/compositor.c
+++ b/libweston/compositor.c
@@ -64,7 +64,9 @@
 #include "version.h"
 #include "plugin-registry.h"
 
-#define DEFAULT_REPAINT_WINDOW 7 /* milliseconds */
+/* Force repaint scheduling algorithm to repaint immediatly on receiving the
+ * pageflip completion event */
+#define DEFAULT_REPAINT_WINDOW 100 /* milliseconds */
 
 static void
 weston_output_transform_scale_init(struct weston_output *output,
@@ -1192,6 +1194,15 @@ weston_view_update_transform_enable(struct weston_view *view)
 		return -1;
 	}
 
+	if (view->alpha == 1.0 &&
+	    matrix->type == WESTON_MATRIX_TRANSFORM_TRANSLATE) {
+		pixman_region32_copy(&view->transform.opaque,
+				     &view->surface->opaque);
+		pixman_region32_translate(&view->transform.opaque,
+					  matrix->d[12],
+					  matrix->d[13]);
+	}
+
 	pixman_region32_init_rect(&surfregion, 0, 0,
 				  view->surface->width, view->surface->height);
 	if (view->geometry.scissor_enabled)
@@ -2499,6 +2510,8 @@ surface_attach(struct wl_client *client,
 		}
 	}
 
+	weston_xlog("surface_attach surf=%p  wl_buf=%p\n", surface, buffer);
+
 	/* Attach, attach, without commit in between does not send
 	 * wl_buffer.release. */
 	weston_surface_state_set_buffer(&surface->pending, buffer);
@@ -4144,41 +4157,6 @@ weston_compositor_reflow_outputs(struct weston_compositor *compositor,
 }
 
 WL_EXPORT void
-weston_output_destroy(struct weston_output *output)
-{
-	struct wl_resource *resource;
-	struct weston_view *view;
-
-	output->destroying = 1;
-
-	wl_list_for_each(view, &output->compositor->view_list, link) {
-		if (view->output_mask & (1u << output->id))
-			weston_view_assign_output(view);
-	}
-
-	wl_event_source_remove(output->repaint_timer);
-
-	weston_presentation_feedback_discard_list(&output->feedback_list);
-
-	weston_compositor_reflow_outputs(output->compositor, output, output->width);
-	wl_list_remove(&output->link);
-
-	wl_signal_emit(&output->compositor->output_destroyed_signal, output);
-	wl_signal_emit(&output->destroy_signal, output);
-
-	free(output->name);
-	pixman_region32_fini(&output->region);
-	pixman_region32_fini(&output->previous_damage);
-	output->compositor->output_id_pool &= ~(1u << output->id);
-
-	wl_resource_for_each(resource, &output->resource_list) {
-		wl_resource_set_destructor(resource, NULL);
-	}
-
-	wl_global_destroy(output->global);
-}
-
-WL_EXPORT void
 weston_output_update_matrix(struct weston_output *output)
 {
 	float magnification;
@@ -4298,50 +4276,266 @@ weston_output_move(struct weston_output *output, int x, int y)
 	}
 }
 
-/** Initialize a weston_output object's parameters
+/** Adds an output to the compositor's output list and
+ *  send the compositor's output_created signal.
+ *
+ * \param compositor The compositor instance.
+ * \param output The output to be added.
+ */
+WL_EXPORT void
+weston_compositor_add_output(struct weston_compositor *compositor,
+                             struct weston_output *output)
+{
+	struct weston_view *view, *next;
+
+	wl_list_insert(compositor->output_list.prev, &output->link);
+	wl_signal_emit(&compositor->output_created_signal, output);
+
+	wl_list_for_each_safe(view, next, &compositor->view_list, link)
+		weston_view_geometry_dirty(view);
+}
+
+WL_EXPORT void
+weston_output_transform_coordinate(struct weston_output *output,
+				   double device_x, double device_y,
+				   double *x, double *y)
+{
+	struct weston_vector p = { {
+		device_x,
+		device_y,
+		0.0,
+		1.0 } };
+
+	weston_matrix_transform(&output->inverse_matrix, &p);
+
+	*x = p.f[0] / p.f[3];
+	*y = p.f[1] / p.f[3];
+}
+
+/** Undoes changes to an output done by weston_output_enable()
+ *
+ * \param output The weston_output object that needs the changes undone.
+ *
+ * Removes the repaint timer.
+ * Destroys the Wayland global assigned to the output.
+ * Destroys pixman regions allocated to the output.
+ * Deallocates output's ID and updates compositor's output_id_pool.
+ */
+static void
+weston_output_enable_undo(struct weston_output *output)
+{
+	wl_event_source_remove(output->repaint_timer);
+
+	wl_global_destroy(output->global);
+
+	pixman_region32_fini(&output->region);
+	pixman_region32_fini(&output->previous_damage);
+	output->compositor->output_id_pool &= ~(1u << output->id);
+
+	output->enabled = false;
+}
+
+/** Removes output from compositor's output list
+ *
+ * \param output The weston_output object that is being removed.
+ *
+ * Presentation feedback is discarded.
+ * Compositor is notified that outputs were changed and
+ * applies the necessary changes.
+ * All views assigned to the weston_output object are
+ * moved to a new output.
+ * Signal is emited to notify all users of the weston_output
+ * object that the output is being destroyed.
+ * wl_output protocol objects referencing this weston_output
+ * are made inert.
+ */
+static void
+weston_compositor_remove_output(struct weston_output *output)
+{
+	struct wl_resource *resource;
+	struct weston_view *view;
+
+	assert(output->destroying);
+
+	wl_list_for_each(view, &output->compositor->view_list, link) {
+		if (view->output_mask & (1u << output->id))
+			weston_view_assign_output(view);
+	}
+
+	weston_presentation_feedback_discard_list(&output->feedback_list);
+
+	weston_compositor_reflow_outputs(output->compositor, output, output->width);
+	wl_list_remove(&output->link);
+
+	wl_signal_emit(&output->compositor->output_destroyed_signal, output);
+	wl_signal_emit(&output->destroy_signal, output);
+
+	wl_resource_for_each(resource, &output->resource_list) {
+		wl_resource_set_destructor(resource, NULL);
+	}
+}
+
+/** Sets the output scale for a given output.
+ *
+ * \param output The weston_output object that the scale is set for.
+ * \param scale  Scale factor for the given output.
+ *
+ * It only supports setting scale for an output that
+ * is not enabled and it can only be ran once.
+ */
+WL_EXPORT void
+weston_output_set_scale(struct weston_output *output,
+			int32_t scale)
+{
+	/* We can only set scale on a disabled output */
+	assert(!output->enabled);
+
+	/* We only want to set scale once */
+	assert(!output->scale);
+
+	output->scale = scale;
+}
+
+/** Sets the output transform for a given output.
+ *
+ * \param output    The weston_output object that the transform is set for.
+ * \param transform Transform value for the given output.
+ *
+ * It only supports setting transform for an output that is
+ * not enabled and it can only be ran once.
+ *
+ * Refer to wl_output::transform section located at
+ * https://wayland.freedesktop.org/docs/html/apa.html#protocol-spec-wl_output
+ * for list of values that can be passed to this function.
+ */
+WL_EXPORT void
+weston_output_set_transform(struct weston_output *output,
+			    uint32_t transform)
+{
+	/* We can only set transform on a disabled output */
+	assert(!output->enabled);
+
+	/* We only want to set transform once */
+	assert(output->transform == UINT32_MAX);
+
+	output->transform = transform;
+}
+
+/** Initializes a weston_output object with enough data so
+ ** an output can be configured.
  *
  * \param output     The weston_output object to initialize
- * \param c          The output's compositor
- * \param x          x coordinate for the output in global coordinate space
- * \param y          y coordinate for the output in global coordinate space
- * \param mm_width   Physical width of the output as reported by the backend
- * \param mm_height  Physical height of the output as reported by the backend
- * \param transform  Rotation of the output
- * \param scale      Native scaling factor for the output
+ * \param compositor The compositor instance.
+ *
+ * Sets initial values for fields that are expected to be
+ * configured either by compositors or backends.
+ */
+WL_EXPORT void
+weston_output_init(struct weston_output *output,
+		   struct weston_compositor *compositor)
+{
+	output->compositor = compositor;
+	output->destroying = 0;
+
+	/* Backends must set output->name */
+	assert(output->name);
+
+	wl_list_init(&output->link);
+
+	output->enabled = false;
+
+	/* Add some (in)sane defaults which can be used
+	 * for checking if an output was properly configured
+	 */
+	output->mm_width = 0;
+	output->mm_height = 0;
+	output->scale = 0;
+	/* Can't use -1 on uint32_t and 0 is valid enum value */
+	output->transform = UINT32_MAX;
+}
+
+/** Adds weston_output object to pending output list.
+ *
+ * \param output     The weston_output object to add
+ * \param compositor The compositor instance.
+ *
+ * Also notifies the compositor that an output is pending for
+ * configuration.
+ */
+WL_EXPORT void
+weston_compositor_add_pending_output(struct weston_output *output,
+				     struct weston_compositor *compositor)
+{
+	wl_list_insert(compositor->pending_output_list.prev, &output->link);
+	wl_signal_emit(&compositor->output_pending_signal, output);
+}
+
+/** Constructs a weston_output object that can be used by the compositor.
+ *
+ * \param output The weston_output object that needs to be enabled.
+ *
+ * Output coordinates are calculated and each new output is by default
+ * assigned to the right of previous one.
  *
  * Sets up the transformation, zoom, and geometry of the output using
- * the input properties.
+ * the properties that need to be configured by the compositor.
  *
  * Establishes a repaint timer for the output with the relevant display
- * object's event loop.  See output_repaint_timer_handler().
+ * object's event loop. See output_repaint_timer_handler().
  *
- * The output is assigned an ID.  Weston can support up to 32 distinct
+ * The output is assigned an ID. Weston can support up to 32 distinct
  * outputs, with IDs numbered from 0-31; the compositor's output_id_pool
  * is referred to and used to find the first available ID number, and
  * then this ID is marked as used in output_id_pool.
  *
  * The output is also assigned a Wayland global with the wl_output
  * external interface.
+ *
+ * Backend specific function is called to set up the output output.
+ *
+ * Output is added to the compositor's output list
+ *
+ * If the backend specific function fails, the weston_output object
+ * is returned to a state it was before calling this function and
+ * is added to the compositor's pending_output_list in case it needs
+ * to be reconfigured or just so it can be destroyed at shutdown.
+ *
+ * 0 is returned on success, -1 on failure.
  */
-WL_EXPORT void
-weston_output_init(struct weston_output *output, struct weston_compositor *c,
-		   int x, int y, int mm_width, int mm_height, uint32_t transform,
-		   int32_t scale)
+WL_EXPORT int
+weston_output_enable(struct weston_output *output)
 {
+	struct weston_compositor *c = output->compositor;
+	struct weston_output *iterator;
 	struct wl_event_loop *loop;
+	int x = 0, y = 0;
+
+	assert(output->enable);
+
+	iterator = container_of(c->output_list.prev,
+				struct weston_output, link);
+
+	if (!wl_list_empty(&c->output_list))
+		x = iterator->x + iterator->width;
+
+	/* Make sure the scale is set up */
+	assert(output->scale);
+
+	/* Make sure we have a transform set */
+	assert(output->transform != UINT32_MAX);
+
+	/* Remove it from pending/disabled output list */
+	wl_list_remove(&output->link);
 
 	/* Verify we haven't reached the limit of 32 available output IDs */
 	assert(ffs(~c->output_id_pool) > 0);
 
-	output->compositor = c;
 	output->x = x;
 	output->y = y;
-	output->mm_width = mm_width;
-	output->mm_height = mm_height;
 	output->dirty = 1;
-	output->original_scale = scale;
+	output->original_scale = output->scale;
 
-	weston_output_transform_scale_init(output, transform, scale);
+	weston_output_transform_scale_init(output, output->transform, output->scale);
 	weston_output_init_zoom(output);
 
 	weston_output_init_geometry(output, x, y);
@@ -4368,42 +4562,102 @@ weston_output_init(struct weston_output *output, struct weston_compositor *c,
 	output->global =
 		wl_global_create(c->wl_display, &wl_output_interface, 3,
 				 output, bind_output);
+
+	output->enabled = true;
+
+	/* Enable the output (set up the crtc or create a
+	 * window representing the output, set up the
+	 * renderer, etc)
+	 */
+	if (output->enable(output) < 0) {
+		weston_log("Enabling output \"%s\" failed.\n", output->name);
+
+		weston_output_enable_undo(output);
+		wl_list_insert(output->compositor->pending_output_list.prev,
+			       &output->link);
+		return -1;
+	}
+
+	weston_compositor_add_output(output->compositor, output);
+
+	return 0;
 }
 
-/** Adds an output to the compositor's output list and
- *  send the compositor's output_created signal.
+/** Converts a weston_output object to a pending output state, so it
+ ** can be configured again or destroyed.
  *
- * \param compositor The compositor instance.
- * \param output The output to be added.
+ * \param output The weston_output object that needs to be disabled.
+ *
+ * See weston_output_init() for more information on the
+ * state output is returned to.
+ *
+ * Calls a backend specific function to disable an output, in case
+ * such function exists.
+ *
+ * If the output is being used by the compositor, it is first removed
+ * from weston's output_list (see weston_compositor_remove_output())
+ * and is returned to a state it was before weston_output_enable()
+ * was ran (see weston_output_enable_undo()).
+ *
+ * Output is added to pending_output_list so it will get destroyed
+ * if the output does not get configured again when the compositor
+ * shuts down. If an output is to be used immediately, it needs to
+ * be manually removed from the list (the compositor specific functions
+ * for handling pending outputs will take care of that).
+ *
+ * If backend specific disable function returns negative value,
+ * this function will return too. It can be used as an indicator
+ * that output cannot be disabled at the present time. In that case
+ * backend needs to make sure the output is disabled when it is
+ * possible.
  */
 WL_EXPORT void
-weston_compositor_add_output(struct weston_compositor *compositor,
-                             struct weston_output *output)
+weston_output_disable(struct weston_output *output)
 {
-	struct weston_view *view, *next;
+	assert(output->disable);
 
-	wl_list_insert(compositor->output_list.prev, &output->link);
-	wl_signal_emit(&compositor->output_created_signal, output);
+	/* Should we rename this? */
+	output->destroying = 1;
 
-	wl_list_for_each_safe(view, next, &compositor->view_list, link)
-		weston_view_geometry_dirty(view);
+	if (output->disable(output) < 0)
+		return;
+
+	if (output->enabled) {
+		weston_compositor_remove_output(output);
+		weston_output_enable_undo(output);
+
+		/* We need to preserve it somewhere so it can be destroyed on shutdown
+		   if nobody wants to configure it again */
+		wl_list_insert(output->compositor->pending_output_list.prev, &output->link);
+	}
+
+	output->destroying = 0;
 }
 
+/** Emits a signal to indicate that there are outputs waiting to be configured.
+ *
+ * \param compositor The compositor instance
+ */
 WL_EXPORT void
-weston_output_transform_coordinate(struct weston_output *output,
-				   double device_x, double device_y,
-				   double *x, double *y)
+weston_pending_output_coldplug(struct weston_compositor *compositor)
 {
-	struct weston_vector p = { {
-		device_x,
-		device_y,
-		0.0,
-		1.0 } };
+	struct weston_output *output, *next;
 
-	weston_matrix_transform(&output->inverse_matrix, &p);
+	wl_list_for_each_safe(output, next, &compositor->pending_output_list, link)
+		wl_signal_emit(&compositor->output_pending_signal, output);
+}
 
-	*x = p.f[0] / p.f[3];
-	*y = p.f[1] / p.f[3];
+WL_EXPORT void
+weston_output_destroy(struct weston_output *output)
+{
+	output->destroying = 1;
+
+	if (output->enabled) {
+		weston_compositor_remove_output(output);
+		weston_output_enable_undo(output);
+	}
+
+	free(output->name);
 }
 
 static void
@@ -4743,6 +4997,7 @@ weston_compositor_create(struct wl_display *display, void *user_data)
 	wl_signal_init(&ec->hide_input_panel_signal);
 	wl_signal_init(&ec->update_input_panel_signal);
 	wl_signal_init(&ec->seat_created_signal);
+	wl_signal_init(&ec->output_pending_signal);
 	wl_signal_init(&ec->output_created_signal);
 	wl_signal_init(&ec->output_destroyed_signal);
 	wl_signal_init(&ec->output_moved_signal);
@@ -4778,6 +5033,7 @@ weston_compositor_create(struct wl_display *display, void *user_data)
 	wl_list_init(&ec->plane_list);
 	wl_list_init(&ec->layer_list);
 	wl_list_init(&ec->seat_list);
+	wl_list_init(&ec->pending_output_list);
 	wl_list_init(&ec->output_list);
 	wl_list_init(&ec->key_binding_list);
 	wl_list_init(&ec->modifier_binding_list);
@@ -4822,6 +5078,10 @@ weston_compositor_shutdown(struct weston_compositor *ec)
 	wl_list_for_each_safe(output, next, &ec->output_list, link)
 		output->destroy(output);
 
+	/* Destroy all pending outputs associated with this compositor */
+	wl_list_for_each_safe(output, next, &ec->pending_output_list, link)
+		output->destroy(output);
+
 	if (ec->renderer)
 		ec->renderer->destroy(ec);
 
@@ -5066,6 +5326,7 @@ weston_compositor_get_user_data(struct weston_compositor *compositor)
 
 static const char * const backend_map[] = {
 	[WESTON_BACKEND_DRM] =		"drm-backend.so",
+	[WESTON_BACKEND_ST] =		"st-backend.so",
 	[WESTON_BACKEND_FBDEV] =	"fbdev-backend.so",
 	[WESTON_BACKEND_HEADLESS] =	"headless-backend.so",
 	[WESTON_BACKEND_RDP] =		"rdp-backend.so",
diff --git a/libweston/compositor.h b/libweston/compositor.h
index 5345a3e..c7f5abf 100644
--- a/libweston/compositor.h
+++ b/libweston/compositor.h
@@ -46,6 +46,15 @@ extern "C" {
 #include "zalloc.h"
 #include "timeline-object.h"
 
+#include "linux-dmabuf.h"
+
+//#define DEBUG_VERBOSE
+#ifdef DEBUG_VERBOSE
+#define weston_xlog(...) weston_log(__VA_ARGS__)
+#else
+#define weston_xlog(...) ((void)0)
+#endif
+
 struct weston_geometry {
 	int32_t x, y;
 	int32_t width, height;
@@ -218,6 +227,12 @@ struct weston_output {
 			  uint16_t *b);
 
 	struct weston_timeline_object timeline;
+
+	bool enabled;
+	int scale;
+
+	int (*enable)(struct weston_output *output);
+	int (*disable)(struct weston_output *output);
 };
 
 enum weston_pointer_motion_mask {
@@ -688,20 +703,6 @@ enum weston_capability {
 	WESTON_CAP_VIEW_CLIP_MASK		= 0x0010,
 };
 
-/* Configuration struct for an output.
- *
- * This struct is used to pass the configuration for an output
- * to the compositor backend when creating a new output.
- * The backend can subclass this struct to handle backend
- * specific data.
- */
-struct weston_backend_output_config {
-	uint32_t transform;
-	uint32_t width;
-	uint32_t height;
-	uint32_t scale;
-};
-
 /* Configuration struct for a backend.
  *
  * This struct carries the configuration for a backend, and it's
@@ -767,6 +768,7 @@ struct weston_compositor {
 	struct wl_signal update_input_panel_signal;
 
 	struct wl_signal seat_created_signal;
+	struct wl_signal output_pending_signal;
 	struct wl_signal output_created_signal;
 	struct wl_signal output_destroyed_signal;
 	struct wl_signal output_moved_signal;
@@ -778,6 +780,7 @@ struct weston_compositor {
 	struct weston_layer fade_layer;
 	struct weston_layer cursor_layer;
 
+	struct wl_list pending_output_list;
 	struct wl_list output_list;
 	struct wl_list seat_list;
 	struct wl_list layer_list;
@@ -1560,6 +1563,7 @@ weston_compositor_create(struct wl_display *display, void *user_data);
 
 enum weston_compositor_backend {
 	WESTON_BACKEND_DRM,
+	WESTON_BACKEND_ST,
 	WESTON_BACKEND_FBDEV,
 	WESTON_BACKEND_HEADLESS,
 	WESTON_BACKEND_RDP,
@@ -1606,9 +1610,7 @@ void
 weston_output_update_matrix(struct weston_output *output);
 void
 weston_output_move(struct weston_output *output, int x, int y);
-void
-weston_output_init(struct weston_output *output, struct weston_compositor *c,
-		   int x, int y, int width, int height, uint32_t transform, int32_t scale);
+
 void
 weston_compositor_add_output(struct weston_compositor *compositor,
                              struct weston_output *output);
@@ -1816,6 +1818,31 @@ weston_seat_set_keyboard_focus(struct weston_seat *seat,
 int
 weston_compositor_load_xwayland(struct weston_compositor *compositor);
 
+void
+weston_output_set_scale(struct weston_output *output,
+			int32_t scale);
+
+void
+weston_output_set_transform(struct weston_output *output,
+			    uint32_t transform);
+
+void
+weston_output_init(struct weston_output *output,
+		   struct weston_compositor *compositor);
+
+void
+weston_compositor_add_pending_output(struct weston_output *output,
+				     struct weston_compositor *compositor);
+
+int
+weston_output_enable(struct weston_output *output);
+
+void
+weston_output_disable(struct weston_output *output);
+
+void
+weston_pending_output_coldplug(struct weston_compositor *compositor);
+
 #ifdef  __cplusplus
 }
 #endif
diff --git a/libweston/gl-renderer.c b/libweston/gl-renderer.c
index 031576b..9025c0a 100644
--- a/libweston/gl-renderer.c
+++ b/libweston/gl-renderer.c
@@ -58,7 +58,7 @@ struct gl_shader {
 	const char *vertex_source, *fragment_source;
 };
 
-#define BUFFER_DAMAGE_COUNT 2
+#define BUFFER_DAMAGE_COUNT 3
 
 enum gl_border_status {
 	BORDER_STATUS_CLEAN = 0,
@@ -147,7 +147,7 @@ struct gl_surface_state {
 	/* These are only used by SHM surfaces to detect when we need
 	 * to do a full upload to specify a new internal texture
 	 * format */
-	GLenum gl_format;
+	GLenum gl_format[3];
 	GLenum gl_pixel_type;
 
 	struct egl_image* images[3];
@@ -160,6 +160,11 @@ struct gl_surface_state {
 	int height; /* in pixels */
 	int y_inverted;
 
+	/* Extension needed for SHM YUV texture */
+	int offset[3]; /* offset per plane */
+	int hsub[3];  /* horizontal subsampling per plane */
+	int vsub[3];  /* vertical subsampling per plane */
+
 	struct weston_surface *surface;
 
 	struct wl_listener surface_destroy_listener;
@@ -187,6 +192,7 @@ struct gl_renderer {
 	PFNEGLDESTROYIMAGEKHRPROC destroy_image;
 	PFNEGLSWAPBUFFERSWITHDAMAGEEXTPROC swap_buffers_with_damage;
 	PFNEGLCREATEPLATFORMWINDOWSURFACEEXTPROC create_platform_window;
+	PFNEGLSETDAMAGEREGIONKHRPROC set_damage_region;
 
 	int has_unpack_subimage;
 
@@ -206,6 +212,8 @@ struct gl_renderer {
 	int has_dmabuf_import;
 	struct wl_list dmabuf_images;
 
+	int has_gl_texture_rg;
+
 	struct gl_shader texture_shader_rgba;
 	struct gl_shader texture_shader_rgbx;
 	struct gl_shader texture_shader_egl_external;
@@ -1020,7 +1028,7 @@ output_get_damage(struct weston_output *output,
 
 	if (gr->has_egl_buffer_age) {
 		ret = eglQuerySurface(gr->egl_display, go->egl_surface,
-				      EGL_BUFFER_AGE_EXT, &buffer_age);
+				      gr->has_egl_buffer_age, &buffer_age);
 		if (ret == EGL_FALSE) {
 			weston_log("buffer age query failed.\n");
 			gl_renderer_print_egl_error_state();
@@ -1042,8 +1050,8 @@ output_get_damage(struct weston_output *output,
 		} else {
 			for (i = 0; i < buffer_age - 1; i++)
 				pixman_region32_union(buffer_damage,
-						      buffer_damage,
-						      &go->buffer_damage[(go->buffer_damage_index + i) % BUFFER_DAMAGE_COUNT]);
+									  buffer_damage,
+									  &go->buffer_damage[(go->buffer_damage_index + i) % BUFFER_DAMAGE_COUNT]);
 		}
 	}
 }
@@ -1066,6 +1074,138 @@ output_rotate_damage(struct weston_output *output,
 	go->border_damage[go->buffer_damage_index] = border_status;
 }
 
+#define EXPAND_32_PIX 32
+static void
+output_set_damage(struct weston_output *output, pixman_region32_t *total_damage)
+ {
+	struct gl_renderer *gr = get_renderer(output->compositor);
+
+	if (gr->set_damage_region) {
+		struct gl_output_state *go = get_output_state(output);
+		pixman_region32_t buffer_damage;
+		int i, nrects, buffer_height;
+		EGLint *egl_damage, *d;
+		pixman_box32_t *rects;
+		int offsetx, offsety;
+
+		pixman_region32_init(&buffer_damage);
+		weston_transformed_region(output->width, output->height,
+				output->transform,
+				output->current_scale,
+				total_damage, &buffer_damage);
+
+		if (output_has_borders(output)) {
+			pixman_region32_translate(&buffer_damage,
+					go->borders[GL_RENDERER_BORDER_LEFT].width,
+					go->borders[GL_RENDERER_BORDER_TOP].height);
+			output_get_border_damage(output, go->border_status,
+					&buffer_damage);
+		}
+
+		rects = pixman_region32_rectangles(&buffer_damage, &nrects);
+		/* If buffer_damage is null, we should specify 1 rects with empty
+		 * parameters */
+		if (nrects == 0)
+			nrects = 1;
+
+		egl_damage = malloc(nrects * 4 * sizeof(EGLint));
+
+		buffer_height = go->borders[GL_RENDERER_BORDER_TOP].height +
+			output->current_mode->height +
+			go->borders[GL_RENDERER_BORDER_BOTTOM].height;
+
+		switch (output->transform) {
+		default:
+		case WL_OUTPUT_TRANSFORM_NORMAL:
+			offsetx = output->x;
+			offsety = 0;
+			break;
+		case WL_OUTPUT_TRANSFORM_90:
+			offsetx = 0;
+			offsety = -output->x;
+			break;
+		case WL_OUTPUT_TRANSFORM_180:
+			offsetx = -output->x;
+			offsety = 0;
+			break;
+		case WL_OUTPUT_TRANSFORM_270:
+			offsetx = 0;
+			offsety = output->x;
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED:
+			offsetx = -output->x;
+			offsety = 0;
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED_90:
+			offsetx = 0;
+			offsety = output->x;
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED_180:
+			offsetx = output->x;
+			offsety = 0;
+			break;
+		case WL_OUTPUT_TRANSFORM_FLIPPED_270:
+			offsetx = 0;
+			offsety = -output->x;
+			break;
+		}
+
+		d = egl_damage;
+		if (pixman_region32_not_empty(&buffer_damage)) {
+			for (i = 0; i < nrects; ++i) {
+				*d++ = rects[i].x1 - offsetx;
+				*d++ = buffer_height - rects[i].y2 - offsety;
+				*d++ = rects[i].x2 - rects[i].x1;
+				*d++ = rects[i].y2 - rects[i].y1;
+			}
+		} else {
+			*d++ = 0;
+			*d++ = 0;
+			*d++ = 0;
+			*d++ = 0;
+		}
+
+		/* Inform GPU of the damage region */
+		if (!gr->set_damage_region(gr->egl_display, go->egl_surface, egl_damage, nrects))
+				weston_log("Failed in eglSetDamageRegionKHR.\n");
+
+		free(egl_damage);
+
+		/* Expand the total_dammage region to allow GPU to readback coherent
+		 * data at border of the region defined by eglSetDamageRegionKHR.
+		 * Else border region have undefined value. */
+		pixman_region32_init(&buffer_damage);
+		pixman_region32_copy(&buffer_damage, total_damage);
+
+		if (pixman_region32_not_empty(&buffer_damage)) {
+			rects = pixman_region32_rectangles(&buffer_damage, &nrects);
+
+			for (i = 0; i < nrects; ++i) {
+				rects[i].x1 = rects[i].x1 - EXPAND_32_PIX;
+				rects[i].x2 = rects[i].x2 + EXPAND_32_PIX;
+				rects[i].y1 = rects[i].y1 - EXPAND_32_PIX;
+				rects[i].y2 = rects[i].y2 + EXPAND_32_PIX;
+
+				/* clip to output window size */
+				rects[i].x1 = min(rects[i].x1, output->x + output->width);
+				rects[i].x2 = min(rects[i].x2, output->x + output->width);
+				rects[i].y1 = min(rects[i].y1, output->y + output->height);
+				rects[i].y2 = min(rects[i].y2, output->y + output->height);
+
+				rects[i].x1 = max(rects[i].x1, output->x);
+				rects[i].x2 = max(rects[i].x2, output->x);
+				rects[i].y1 = max(rects[i].y1, output->y);
+				rects[i].y2 = max(rects[i].y2, output->y);
+			}
+
+			pixman_region32_clear(total_damage);
+			pixman_region32_init_rects(total_damage, rects, nrects);
+		}
+
+		pixman_region32_fini(&buffer_damage);
+	}
+}
+
 /* NOTE: We now allow falling back to ARGB gl visuals when XRGB is
  * unavailable, so we're assuming the background has no transparency
  * and that everything with a blend, like drop shadows, will have something
@@ -1130,6 +1270,8 @@ gl_renderer_repaint_output(struct weston_output *output,
 	pixman_region32_union(&total_damage, &buffer_damage, output_damage);
 	border_damage |= go->border_status;
 
+	output_set_damage(output, &total_damage);
+
 	repaint_views(output, &total_damage);
 
 	pixman_region32_fini(&total_damage);
@@ -1230,7 +1372,7 @@ gl_renderer_flush_damage(struct weston_surface *surface)
 	bool texture_used;
 	pixman_box32_t *rectangles;
 	void *data;
-	int i, n;
+	int i, j, n;
 
 	pixman_region32_union(&gs->texture_damage,
 			      &gs->texture_damage, &surface->damage);
@@ -1257,29 +1399,43 @@ gl_renderer_flush_damage(struct weston_surface *surface)
 	    !gs->needs_full_upload)
 		goto done;
 
-	glBindTexture(GL_TEXTURE_2D, gs->textures[0]);
+	data = wl_shm_buffer_get_data(buffer->shm_buffer);
 
 	if (!gr->has_unpack_subimage) {
 		wl_shm_buffer_begin_access(buffer->shm_buffer);
-		glTexImage2D(GL_TEXTURE_2D, 0, gs->gl_format,
-			     gs->pitch, buffer->height, 0,
-			     gs->gl_format, gs->gl_pixel_type,
-			     wl_shm_buffer_get_data(buffer->shm_buffer));
+		for (j = 0; j < gs->num_textures; j++) {
+			glBindTexture(GL_TEXTURE_2D, gs->textures[j]);
+			glTexImage2D(GL_TEXTURE_2D, 0,
+				     gs->gl_format[j],
+				     gs->pitch / gs->hsub[j],
+				     buffer->height / gs->vsub[j],
+				     0,
+				     gs->gl_format[j],
+				     gs->gl_pixel_type,
+				     data + gs->offset[j]);
+		}
 		wl_shm_buffer_end_access(buffer->shm_buffer);
 
 		goto done;
 	}
 
 	glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, gs->pitch);
-	data = wl_shm_buffer_get_data(buffer->shm_buffer);
 
 	if (gs->needs_full_upload) {
 		glPixelStorei(GL_UNPACK_SKIP_PIXELS_EXT, 0);
 		glPixelStorei(GL_UNPACK_SKIP_ROWS_EXT, 0);
 		wl_shm_buffer_begin_access(buffer->shm_buffer);
-		glTexImage2D(GL_TEXTURE_2D, 0, gs->gl_format,
-			     gs->pitch, buffer->height, 0,
-			     gs->gl_format, gs->gl_pixel_type, data);
+		for (j = 0; j < gs->num_textures; j++) {
+			glBindTexture(GL_TEXTURE_2D, gs->textures[j]);
+			glTexImage2D(GL_TEXTURE_2D, 0,
+				     gs->gl_format[j],
+				     gs->pitch / gs->hsub[j],
+				     buffer->height / gs->vsub[j],
+				     0,
+				     gs->gl_format[j],
+				     gs->gl_pixel_type,
+				     data + gs->offset[j]);
+		}
 		wl_shm_buffer_end_access(buffer->shm_buffer);
 		goto done;
 	}
@@ -1293,9 +1449,17 @@ gl_renderer_flush_damage(struct weston_surface *surface)
 
 		glPixelStorei(GL_UNPACK_SKIP_PIXELS_EXT, r.x1);
 		glPixelStorei(GL_UNPACK_SKIP_ROWS_EXT, r.y1);
-		glTexSubImage2D(GL_TEXTURE_2D, 0, r.x1, r.y1,
-				r.x2 - r.x1, r.y2 - r.y1,
-				gs->gl_format, gs->gl_pixel_type, data);
+		for (j = 0; j < gs->num_textures; j++) {
+			glBindTexture(GL_TEXTURE_2D, gs->textures[j]);
+			glTexSubImage2D(GL_TEXTURE_2D, 0,
+					r.x1 / gs->hsub[j],
+					r.y1 / gs->vsub[j],
+					(r.x2 - r.x1) / gs->hsub[j],
+					(r.y2 - r.y1) / gs->vsub[j],
+					gs->gl_format[j],
+					gs->gl_pixel_type,
+					data + gs->offset[j]);
+		}
 	}
 	wl_shm_buffer_end_access(buffer->shm_buffer);
 
@@ -1334,32 +1498,92 @@ gl_renderer_attach_shm(struct weston_surface *es, struct weston_buffer *buffer,
 	struct weston_compositor *ec = es->compositor;
 	struct gl_renderer *gr = get_renderer(ec);
 	struct gl_surface_state *gs = get_surface_state(es);
-	GLenum gl_format, gl_pixel_type;
+	GLenum gl_format[3] = {0, 0, 0};
+	GLenum gl_pixel_type;
 	int pitch;
+	int num_planes;
 
 	buffer->shm_buffer = shm_buffer;
 	buffer->width = wl_shm_buffer_get_width(shm_buffer);
 	buffer->height = wl_shm_buffer_get_height(shm_buffer);
 
+	num_planes = 1;
+	gs->offset[0] = 0;
+	gs->hsub[0] = 1;
+	gs->vsub[0] = 1;
+
 	switch (wl_shm_buffer_get_format(shm_buffer)) {
 	case WL_SHM_FORMAT_XRGB8888:
 		gs->shader = &gr->texture_shader_rgbx;
 		pitch = wl_shm_buffer_get_stride(shm_buffer) / 4;
-		gl_format = GL_BGRA_EXT;
+		gl_format[0] = GL_BGRA_EXT;
 		gl_pixel_type = GL_UNSIGNED_BYTE;
 		break;
 	case WL_SHM_FORMAT_ARGB8888:
 		gs->shader = &gr->texture_shader_rgba;
 		pitch = wl_shm_buffer_get_stride(shm_buffer) / 4;
-		gl_format = GL_BGRA_EXT;
+		gl_format[0] = GL_BGRA_EXT;
 		gl_pixel_type = GL_UNSIGNED_BYTE;
 		break;
 	case WL_SHM_FORMAT_RGB565:
 		gs->shader = &gr->texture_shader_rgbx;
 		pitch = wl_shm_buffer_get_stride(shm_buffer) / 2;
-		gl_format = GL_RGB;
+		gl_format[0] = GL_RGB;
 		gl_pixel_type = GL_UNSIGNED_SHORT_5_6_5;
 		break;
+	case WL_SHM_FORMAT_YUV420:
+		gs->shader = &gr->texture_shader_y_u_v;
+		pitch = wl_shm_buffer_get_stride(shm_buffer);
+		gl_pixel_type = GL_UNSIGNED_BYTE;
+		num_planes = 3;
+		gs->offset[1] = gs->offset[0] + (pitch / gs->hsub[0]) *
+				(buffer->height / gs->vsub[0]);
+		gs->hsub[1] = 2;
+		gs->vsub[1] = 2;
+		gs->offset[2] = gs->offset[1] + (pitch / gs->hsub[1]) *
+				(buffer->height / gs->vsub[1]);
+		gs->hsub[2] = 2;
+		gs->vsub[2] = 2;
+		if (gr->has_gl_texture_rg) {
+			gl_format[0] = GL_R8_EXT;
+			gl_format[1] = GL_R8_EXT;
+			gl_format[2] = GL_R8_EXT;
+		} else {
+			gl_format[0] = GL_LUMINANCE;
+			gl_format[1] = GL_LUMINANCE;
+			gl_format[2] = GL_LUMINANCE;
+		}
+		break;
+	case WL_SHM_FORMAT_NV12:
+		gs->shader = &gr->texture_shader_y_xuxv;
+		pitch = wl_shm_buffer_get_stride(shm_buffer);
+		gl_pixel_type = GL_UNSIGNED_BYTE;
+		num_planes = 2;
+		gs->offset[1] = gs->offset[0] + (pitch / gs->hsub[0]) *
+				(buffer->height / gs->vsub[0]);
+		gs->hsub[1] = 2;
+		gs->vsub[1] = 2;
+		if (gr->has_gl_texture_rg) {
+			gl_format[0] = GL_R8_EXT;
+			gl_format[1] = GL_RG8_EXT;
+		} else {
+			gl_format[0] = GL_LUMINANCE;
+			gl_format[1] = GL_LUMINANCE_ALPHA;
+		}
+		break;
+	case WL_SHM_FORMAT_YUYV:
+		gs->shader = &gr->texture_shader_y_xuxv;
+		pitch = wl_shm_buffer_get_stride(shm_buffer) / 2;
+		gl_pixel_type = GL_UNSIGNED_BYTE;
+		num_planes = 2;
+		gs->hsub[1] = 2;
+		gs->vsub[1] = 1;
+		if (gr->has_gl_texture_rg)
+			gl_format[0] = GL_RG8_EXT;
+		else
+			gl_format[0] = GL_LUMINANCE_ALPHA;
+		gl_format[1] = GL_BGRA_EXT;
+		break;
 	default:
 		weston_log("warning: unknown shm buffer format: %08x\n",
 			   wl_shm_buffer_get_format(shm_buffer));
@@ -1371,13 +1595,17 @@ gl_renderer_attach_shm(struct weston_surface *es, struct weston_buffer *buffer,
 	 * happening, we need to allocate a new texture buffer. */
 	if (pitch != gs->pitch ||
 	    buffer->height != gs->height ||
-	    gl_format != gs->gl_format ||
+	    gl_format[0] != gs->gl_format[0] ||
+	    gl_format[1] != gs->gl_format[1] ||
+	    gl_format[2] != gs->gl_format[2] ||
 	    gl_pixel_type != gs->gl_pixel_type ||
 	    gs->buffer_type != BUFFER_TYPE_SHM) {
 		gs->pitch = pitch;
 		gs->height = buffer->height;
 		gs->target = GL_TEXTURE_2D;
-		gs->gl_format = gl_format;
+		gs->gl_format[0] = gl_format[0];
+		gs->gl_format[1] = gl_format[1];
+		gs->gl_format[2] = gl_format[2];
 		gs->gl_pixel_type = gl_pixel_type;
 		gs->buffer_type = BUFFER_TYPE_SHM;
 		gs->needs_full_upload = true;
@@ -1385,7 +1613,7 @@ gl_renderer_attach_shm(struct weston_surface *es, struct weston_buffer *buffer,
 
 		gs->surface = es;
 
-		ensure_textures(gs, 1);
+		ensure_textures(gs, num_planes);
 	}
 }
 
@@ -1525,6 +1753,14 @@ import_simple_dmabuf(struct gl_renderer *gr,
 		attribs[atti++] = attributes->stride[2];
 	}
 
+	if (attributes->format == DRM_FORMAT_NV12) {
+		/* default color space and range is BT709 full range */
+		attribs[atti++] = EGL_YUV_COLOR_SPACE_HINT_EXT;
+		attribs[atti++] = EGL_ITU_REC709_EXT;
+		attribs[atti++] = EGL_SAMPLE_RANGE_HINT_EXT;
+		attribs[atti++] = EGL_YUV_FULL_RANGE_EXT;
+	}
+
 	attribs[atti++] = EGL_NONE;
 
 	image = egl_image_create(gr, EGL_LINUX_DMA_BUF_EXT, NULL,
@@ -1599,6 +1835,27 @@ struct yuv_format_descriptor yuv_formats[] = {
 			.format = DRM_FORMAT_R8,
 			.plane_index = 2
 		}}
+	}, {
+		.format = DRM_FORMAT_YUV444,
+		.input_planes = 3,
+		.output_planes = 3,
+		.texture_type = EGL_TEXTURE_Y_U_V_WL,
+		{{
+			.width_divisor = 1,
+			.height_divisor = 1,
+			.format = DRM_FORMAT_R8,
+			.plane_index = 0
+		}, {
+			.width_divisor = 1,
+			.height_divisor = 1,
+			.format = DRM_FORMAT_R8,
+			.plane_index = 1
+		}, {
+			.width_divisor = 1,
+			.height_divisor = 1,
+			.format = DRM_FORMAT_R8,
+			.plane_index = 2
+		}}
 	}
 };
 
@@ -1766,10 +2023,6 @@ gl_renderer_import_dmabuf(struct weston_compositor *ec,
 			return false;
 	}
 
-	/* reject all flags we do not recognize or handle */
-	if (dmabuf->attributes.flags & ~ZWP_LINUX_BUFFER_PARAMS_V1_FLAGS_Y_INVERT)
-		return false;
-
 	image = import_dmabuf(gr, dmabuf);
 	if (!image)
 		return false;
@@ -1909,7 +2162,8 @@ gl_renderer_attach(struct weston_surface *es, struct weston_buffer *buffer)
 
 	if (shm_buffer)
 		gl_renderer_attach_shm(es, buffer, shm_buffer);
-	else if (gr->query_buffer(gr->egl_display, (void *) buffer->resource,
+	else if (gr->query_buffer &&
+		 gr->query_buffer(gr->egl_display, (void *)buffer->resource,
 				  EGL_TEXTURE_FORMAT, &format))
 		gl_renderer_attach_egl(es, buffer, format);
 	else if ((dmabuf = linux_dmabuf_buffer_get(buffer->resource)))
@@ -2714,11 +2968,20 @@ gl_renderer_setup_egl_extensions(struct weston_compositor *ec)
 	}
 
 	if (weston_check_egl_extension(extensions, "EGL_EXT_buffer_age"))
-		gr->has_egl_buffer_age = 1;
+		gr->has_egl_buffer_age = EGL_BUFFER_AGE_EXT;
 	else
 		weston_log("warning: EGL_EXT_buffer_age not supported. "
 			   "Performance could be affected.\n");
 
+	if (weston_check_egl_extension(extensions, "EGL_KHR_partial_update")) {
+		gr->set_damage_region =
+			(void *) eglGetProcAddress("eglSetDamageRegionKHR");
+		gr->has_egl_buffer_age = EGL_BUFFER_AGE_KHR;
+	} else {
+		weston_log("warning: EGL_KHR_partial_update not supported."
+				   "Performance could be affected.\n");
+	}
+
 	if (weston_check_egl_extension(extensions, "EGL_EXT_swap_buffers_with_damage"))
 		gr->swap_buffers_with_damage =
 			(void *) eglGetProcAddress("eglSwapBuffersWithDamageEXT");
@@ -2735,6 +2998,9 @@ gl_renderer_setup_egl_extensions(struct weston_compositor *ec)
 	if (weston_check_egl_extension(extensions, "EGL_EXT_image_dma_buf_import"))
 		gr->has_dmabuf_import = 1;
 
+	if (weston_check_egl_extension(extensions, "GL_EXT_texture_rg"))
+		gr->has_gl_texture_rg = 1;
+
 	renderer_setup_egl_client_extensions(gr);
 
 	return 0;
@@ -2985,6 +3251,9 @@ gl_renderer_create(struct weston_compositor *ec, EGLenum platform,
 	}
 
 	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_RGB565);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_YUV420);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_NV12);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_YUYV);
 
 	wl_signal_init(&gr->destroy_signal);
 
diff --git a/libweston/linux-dmabuf.c b/libweston/linux-dmabuf.c
index 7b29f08..2af77c4 100644
--- a/libweston/linux-dmabuf.c
+++ b/libweston/linux-dmabuf.c
@@ -23,6 +23,7 @@
 #include "config.h"
 
 #include <assert.h>
+#include <drm_fourcc.h>
 #include <stdint.h>
 #include <unistd.h>
 #include <sys/types.h>
@@ -30,6 +31,17 @@
 #include "compositor.h"
 #include "linux-dmabuf.h"
 #include "linux-dmabuf-unstable-v1-server-protocol.h"
+#include "shared/helpers.h"
+
+uint32_t dmabuf_formats[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_YUYV,
+	DRM_FORMAT_NV12,
+	DRM_FORMAT_YUV420,
+	DRM_FORMAT_YUV444,
+};
 
 static void
 linux_dmabuf_buffer_destroy(struct linux_dmabuf_buffer *buffer)
@@ -136,6 +148,9 @@ destroy_linux_dmabuf_wl_buffer(struct wl_resource *resource)
 	if (buffer->user_data_destroy_func)
 		buffer->user_data_destroy_func(buffer);
 
+	if (buffer->backend_priv_data_destroy_func)
+		buffer->backend_priv_data_destroy_func(buffer);
+
 	linux_dmabuf_buffer_destroy(buffer);
 }
 
@@ -412,6 +427,45 @@ linux_dmabuf_buffer_get_user_data(struct linux_dmabuf_buffer *buffer)
 	return buffer->user_data;
 }
 
+
+/** Set backend-private data
+ *
+ * Set the backend private data for the linux_dmabuf_buffer.
+ *
+ * The backend-private data is usually set from the compositor backend while
+ * dmabuf is imported into a sprite.
+ *
+ * \param buffer The linux_dmabuf_buffer object to set for.
+ * \param data The new backend-private data pointer.
+ * \param func Destructor function to be called for the backend-private
+ *             data when the linux_dmabuf_buffer gets destroyed.
+ *
+ * \sa drm_fb_create_dmabuf
+ */
+WL_EXPORT void
+linux_dmabuf_buffer_set_backend_priv_data(struct linux_dmabuf_buffer *buffer,
+				  void *data,
+				  dmabuf_priv_data_destroy_func func)
+{
+	buffer->backend_priv_data = data;
+	buffer->backend_priv_data_destroy_func = func;
+}
+
+/** Get backend-private data
+ *
+ * Get the backend private data from the linux_dmabuf_buffer.
+ *
+ * \param buffer The linux_dmabuf_buffer to query.
+ * \return Backend-private data pointer.
+ *
+ * \sa linux_dmabuf_buffer_set_backend_priv_data
+ */
+WL_EXPORT void *
+linux_dmabuf_buffer_get_backend_priv_data(struct linux_dmabuf_buffer *buffer)
+{
+	return buffer->backend_priv_data;
+}
+
 static const struct zwp_linux_dmabuf_v1_interface linux_dmabuf_implementation = {
 	linux_dmabuf_destroy,
 	linux_dmabuf_create_params
@@ -423,6 +477,7 @@ bind_linux_dmabuf(struct wl_client *client,
 {
 	struct weston_compositor *compositor = data;
 	struct wl_resource *resource;
+	unsigned int i;
 
 	resource = wl_resource_create(client, &zwp_linux_dmabuf_v1_interface,
 				      version, id);
@@ -434,9 +489,8 @@ bind_linux_dmabuf(struct wl_client *client,
 	wl_resource_set_implementation(resource, &linux_dmabuf_implementation,
 				       compositor, NULL);
 
-	/* EGL_EXT_image_dma_buf_import does not provide a way to query the
-	 * supported pixel formats. */
-	/* XXX: send formats */
+	for (i = 0; i < ARRAY_LENGTH(dmabuf_formats); i++)
+		zwp_linux_dmabuf_v1_send_format(resource, dmabuf_formats[i]);
 }
 
 /** Advertise linux_dmabuf support
diff --git a/libweston/linux-dmabuf.h b/libweston/linux-dmabuf.h
index cd30f91..c7a674e 100644
--- a/libweston/linux-dmabuf.h
+++ b/libweston/linux-dmabuf.h
@@ -30,6 +30,8 @@
 struct linux_dmabuf_buffer;
 typedef void (*dmabuf_user_data_destroy_func)(
 			struct linux_dmabuf_buffer *buffer);
+typedef void (*dmabuf_priv_data_destroy_func)(
+			struct linux_dmabuf_buffer *buffer);
 
 struct dmabuf_attributes {
 	int32_t width;
@@ -52,20 +54,8 @@ struct linux_dmabuf_buffer {
 	void *user_data;
 	dmabuf_user_data_destroy_func user_data_destroy_func;
 
-	/* XXX:
-	 *
-	 * Add backend private data. This would be for the backend
-	 * to do all additional imports it might ever use in advance.
-	 * The basic principle, even if not implemented in drivers today,
-	 * is that dmabufs are first attached, but the actual allocation
-	 * is deferred to first use. This would allow the exporter and all
-	 * attachers to agree on how to allocate.
-	 *
-	 * The DRM backend would use this to create drmFBs for each
-	 * dmabuf_buffer, just in case at some point it would become
-	 * feasible to scan it out directly. This would improve the
-	 * possibilities to successfully scan out, avoiding compositing.
-	 */
+	void *backend_priv_data;
+	dmabuf_priv_data_destroy_func backend_priv_data_destroy_func;
 };
 
 int
@@ -82,6 +72,13 @@ void *
 linux_dmabuf_buffer_get_user_data(struct linux_dmabuf_buffer *buffer);
 
 void
+linux_dmabuf_buffer_set_backend_priv_data(struct linux_dmabuf_buffer *buffer,
+					  void *data,
+					  dmabuf_user_data_destroy_func func);
+void *
+linux_dmabuf_buffer_get_backend_priv_data(struct linux_dmabuf_buffer *buffer);
+
+void
 linux_dmabuf_buffer_send_server_error(struct linux_dmabuf_buffer *buffer,
 				      const char *msg);
 
diff --git a/libweston/weston-egl-ext.h b/libweston/weston-egl-ext.h
index 6e36996..95738e7 100644
--- a/libweston/weston-egl-ext.h
+++ b/libweston/weston-egl-ext.h
@@ -28,6 +28,8 @@
 #ifndef WESTON_EGL_EXT_H
 #define WESTON_EGL_EXT_H
 
+#ifdef ENABLE_EGL
+
 #ifndef EGL_WL_bind_wayland_display
 #define EGL_WL_bind_wayland_display 1
 
@@ -152,5 +154,23 @@ typedef EGLSurface (EGLAPIENTRYP PFNEGLCREATEPLATFORMPIXMAPSURFACEEXTPROC) (EGLD
 #define EGL_PLATFORM_X11_KHR 0x31D5
 #endif
 
+#ifndef EGL_KHR_partial_update
+#define EGL_KHR_partial_update 1
+#define EGL_BUFFER_AGE_KHR              0x313D
+
+#ifdef EGL_EGLEXT_PROTOTYPES
+EGLAPI EGLBoolean EGLAPIENTRY eglSetDamageRegionKHR (EGLDisplay dpy, EGLSurface surface, EGLint *rects, EGLint n_rects);
+#endif
+typedef EGLBoolean (EGLAPIENTRYP PFNEGLSETDAMAGEREGIONKHRPROC) (EGLDisplay dpy, EGLSurface surface, EGLint *rects, EGLint n_rects);
+#endif
+
+#else /* ENABLE_EGL */
+
+/* EGL platform definition are keept to allow compositor-xx.c to build */
+#define EGL_PLATFORM_GBM_KHR     0x31D7
+#define EGL_PLATFORM_WAYLAND_KHR 0x31D8
+#define EGL_PLATFORM_X11_KHR     0x31D5
+
+#endif /* ENABLE_EGL */
 
 #endif
-- 
2.7.4

