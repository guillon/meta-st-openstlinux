From bf06497b3545a167295a50dcd245c62bbea10699 Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@st.com>
Date: Fri, 3 Feb 2017 13:21:32 +0100
Subject: [PATCH 2/4] ST libweston adaptation

---
 libweston-desktop/wl-shell.c     |   5 +-
 libweston-desktop/xdg-shell-v5.c |   4 +-
 libweston-desktop/xdg-shell-v6.c |   4 +-
 libweston/libinput-seat.c        |   2 +-
 libweston/pixman-renderer.c      | 227 ++++++++++++++++++++++++++++++++++-----
 libweston/windowed-output-api.h  |  92 ++++++++++++++++
 protocol/capture.xml             |  43 ++++++++
 7 files changed, 345 insertions(+), 32 deletions(-)
 create mode 100644 libweston/windowed-output-api.h
 create mode 100644 protocol/capture.xml

diff --git a/libweston-desktop/wl-shell.c b/libweston-desktop/wl-shell.c
index ded69f7..695b4a3 100644
--- a/libweston-desktop/wl-shell.c
+++ b/libweston-desktop/wl-shell.c
@@ -69,6 +69,7 @@ weston_desktop_wl_shell_surface_set_size(struct weston_desktop_surface *dsurface
 
 	if ((wsurface->width == width && wsurface->height == height) ||
 	    (width == 0 && height == 0))
+		return;
 
 	wl_shell_surface_send_configure(surface->resource,
 					WL_SHELL_SURFACE_RESIZE_NONE,
@@ -231,8 +232,10 @@ weston_desktop_wl_shell_surface_protocol_resize(struct wl_client *wl_client,
 	struct weston_seat *seat = wl_resource_get_user_data(seat_resource);
 	struct weston_desktop_wl_shell_surface *surface =
 		weston_desktop_surface_get_implementation_data(dsurface);
+	enum weston_desktop_surface_edge surf_edges =
+		(enum weston_desktop_surface_edge) edges;
 
-	weston_desktop_api_resize(surface->desktop, dsurface, seat, serial, edges);
+	weston_desktop_api_resize(surface->desktop, dsurface, seat, serial, surf_edges);
 }
 
 static void
diff --git a/libweston-desktop/xdg-shell-v5.c b/libweston-desktop/xdg-shell-v5.c
index 14216b0..9fd3a87 100644
--- a/libweston-desktop/xdg-shell-v5.c
+++ b/libweston-desktop/xdg-shell-v5.c
@@ -395,9 +395,11 @@ weston_desktop_xdg_surface_protocol_resize(struct wl_client *wl_client,
 		wl_resource_get_user_data(seat_resource);
 	struct weston_desktop_xdg_surface *surface =
 		weston_desktop_surface_get_implementation_data(dsurface);
+	enum weston_desktop_surface_edge surf_edges =
+		(enum weston_desktop_surface_edge) edges;
 
 	weston_desktop_xdg_surface_ensure_added(surface);
-	weston_desktop_api_resize(surface->desktop, dsurface, seat, serial, edges);
+	weston_desktop_api_resize(surface->desktop, dsurface, seat, serial, surf_edges);
 }
 
 static void
diff --git a/libweston-desktop/xdg-shell-v6.c b/libweston-desktop/xdg-shell-v6.c
index 2afce81..552b330 100644
--- a/libweston-desktop/xdg-shell-v6.c
+++ b/libweston-desktop/xdg-shell-v6.c
@@ -396,6 +396,8 @@ weston_desktop_xdg_toplevel_protocol_resize(struct wl_client *wl_client,
 		wl_resource_get_user_data(seat_resource);
 	struct weston_desktop_xdg_toplevel *toplevel =
 		weston_desktop_surface_get_implementation_data(dsurface);
+	enum weston_desktop_surface_edge surf_edges =
+		(enum weston_desktop_surface_edge) edges;
 
 	if (!toplevel->base.configured) {
 		wl_resource_post_error(toplevel->resource,
@@ -405,7 +407,7 @@ weston_desktop_xdg_toplevel_protocol_resize(struct wl_client *wl_client,
 	}
 
 	weston_desktop_api_resize(toplevel->base.desktop,
-				  dsurface, seat, serial, edges);
+				  dsurface, seat, serial, surf_edges);
 }
 
 static void
diff --git a/libweston/libinput-seat.c b/libweston/libinput-seat.c
index 8cf5666..79b67e3 100644
--- a/libweston/libinput-seat.c
+++ b/libweston/libinput-seat.c
@@ -269,11 +269,11 @@ udev_input_enable(struct udev_input *input)
 		weston_log(
 			"warning: no input devices on entering Weston. "
 			"Possible causes:\n"
+			"\t- no input devices are attached\n"
 			"\t- no permissions to read /dev/input/event*\n"
 			"\t- seats misconfigured "
 			"(Weston backend option 'seat', "
 			"udev device property ID_SEAT)\n");
-		return -1;
 	}
 
 	return 0;
diff --git a/libweston/pixman-renderer.c b/libweston/pixman-renderer.c
index 4ba1377..ee391dd 100644
--- a/libweston/pixman-renderer.c
+++ b/libweston/pixman-renderer.c
@@ -31,6 +31,8 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <assert.h>
+#include <drm_fourcc.h>
+#include <sys/mman.h>
 
 #include "pixman-renderer.h"
 #include "shared/helpers.h"
@@ -340,6 +342,7 @@ repaint_region(struct weston_view *ev, struct weston_output *output,
 	pixman_filter_t filter;
 	pixman_image_t *mask_image;
 	pixman_color_t mask = { 0, };
+	struct weston_buffer *buffer = ps->buffer_ref.buffer;
 
 	/* Clip rendering to the damaged output region */
 	pixman_image_set_clip_region32(po->shadow_image, repaint_output);
@@ -351,8 +354,8 @@ repaint_region(struct weston_view *ev, struct weston_output *output,
 	else
 		filter = PIXMAN_FILTER_NEAREST;
 
-	if (ps->buffer_ref.buffer)
-		wl_shm_buffer_begin_access(ps->buffer_ref.buffer->shm_buffer);
+	if (buffer && wl_shm_buffer_get(buffer->resource))
+		wl_shm_buffer_begin_access(buffer->shm_buffer);
 
 	if (ev->alpha < 1.0) {
 		mask.alpha = 0xffff * ev->alpha;
@@ -371,8 +374,8 @@ repaint_region(struct weston_view *ev, struct weston_output *output,
 	if (mask_image)
 		pixman_image_unref(mask_image);
 
-	if (ps->buffer_ref.buffer)
-		wl_shm_buffer_end_access(ps->buffer_ref.buffer->shm_buffer);
+	if (buffer && wl_shm_buffer_get(buffer->resource))
+		wl_shm_buffer_end_access(buffer->shm_buffer);
 
 	if (pr->repaint_debug)
 		pixman_image_composite32(PIXMAN_OP_OVER,
@@ -598,6 +601,7 @@ pixman_renderer_attach(struct weston_surface *es, struct weston_buffer *buffer)
 {
 	struct pixman_surface_state *ps = get_surface_state(es);
 	struct wl_shm_buffer *shm_buffer;
+	struct linux_dmabuf_buffer *dmabuf_buffer;
 	pixman_format_code_t pixman_format;
 
 	weston_buffer_reference(&ps->buffer_ref, buffer);
@@ -616,38 +620,112 @@ pixman_renderer_attach(struct weston_surface *es, struct weston_buffer *buffer)
 		return;
 
 	shm_buffer = wl_shm_buffer_get(buffer->resource);
+	dmabuf_buffer = linux_dmabuf_buffer_get(buffer->resource);
 
-	if (! shm_buffer) {
-		weston_log("Pixman renderer supports only SHM buffers\n");
+	if (!shm_buffer && !dmabuf_buffer) {
+		weston_log("Pixman renderer supports only SHM and DMABUF buffers\n");
 		weston_buffer_reference(&ps->buffer_ref, NULL);
 		return;
 	}
 
-	switch (wl_shm_buffer_get_format(shm_buffer)) {
-	case WL_SHM_FORMAT_XRGB8888:
-		pixman_format = PIXMAN_x8r8g8b8;
-		break;
-	case WL_SHM_FORMAT_ARGB8888:
-		pixman_format = PIXMAN_a8r8g8b8;
-		break;
-	case WL_SHM_FORMAT_RGB565:
-		pixman_format = PIXMAN_r5g6b5;
-		break;
-	default:
-		weston_log("Unsupported SHM buffer format\n");
-		weston_buffer_reference(&ps->buffer_ref, NULL);
-		return;
-	break;
+	if (shm_buffer) {
+		switch (wl_shm_buffer_get_format(shm_buffer)) {
+		case WL_SHM_FORMAT_XRGB8888:
+			pixman_format = PIXMAN_x8r8g8b8;
+			break;
+		case WL_SHM_FORMAT_ARGB8888:
+			pixman_format = PIXMAN_a8r8g8b8;
+			break;
+		case WL_SHM_FORMAT_XBGR8888:
+			pixman_format = PIXMAN_x8b8g8r8;
+			break;
+		case WL_SHM_FORMAT_ABGR8888:
+			pixman_format = PIXMAN_a8b8g8r8;
+			break;
+		case WL_SHM_FORMAT_RGB888:
+			pixman_format = PIXMAN_r8g8b8;
+			break;
+		case WL_SHM_FORMAT_BGR888:
+			pixman_format = PIXMAN_b8g8r8;
+			break;
+		case WL_SHM_FORMAT_RGB565:
+			pixman_format = PIXMAN_r5g6b5;
+			break;
+		case WL_SHM_FORMAT_NV12:
+			pixman_format = PIXMAN_nv12;
+			break;
+		case WL_SHM_FORMAT_YUV420:
+			pixman_format = PIXMAN_yv12;
+			weston_log("Warning: YUV420 will be treated as YVU420 by pixman. Color will be wrong!\n");
+			break;
+		default:
+			weston_log("Unsupported SHM buffer format\n");
+			weston_buffer_reference(&ps->buffer_ref, NULL);
+			return;
+			break;
+		}
+
+		buffer->shm_buffer = shm_buffer;
+		buffer->width = wl_shm_buffer_get_width(shm_buffer);
+		buffer->height = wl_shm_buffer_get_height(shm_buffer);
+
+		ps->image = pixman_image_create_bits(pixman_format,
+				buffer->width, buffer->height,
+				wl_shm_buffer_get_data(shm_buffer),
+				wl_shm_buffer_get_stride(shm_buffer));
 	}
 
-	buffer->shm_buffer = shm_buffer;
-	buffer->width = wl_shm_buffer_get_width(shm_buffer);
-	buffer->height = wl_shm_buffer_get_height(shm_buffer);
+	if (dmabuf_buffer) {
+		void *data = NULL;
+		switch (dmabuf_buffer->attributes.format) {
+		case DRM_FORMAT_XRGB8888:
+			pixman_format = PIXMAN_x8r8g8b8;
+			break;
+		case DRM_FORMAT_ARGB8888:
+			pixman_format = PIXMAN_a8r8g8b8;
+			break;
+		case DRM_FORMAT_XBGR8888:
+			pixman_format = PIXMAN_x8b8g8r8;
+			break;
+		case DRM_FORMAT_ABGR8888:
+			pixman_format = PIXMAN_a8b8g8r8;
+			break;
+		case DRM_FORMAT_RGB888:
+			pixman_format = PIXMAN_r8g8b8;
+			break;
+		case DRM_FORMAT_BGR888:
+			pixman_format = PIXMAN_b8g8r8;
+			break;
+		case DRM_FORMAT_RGB565:
+			pixman_format = PIXMAN_r5g6b5;
+			break;
+		case DRM_FORMAT_NV12:
+			pixman_format = PIXMAN_nv12;
+			break;
+		default:
+			weston_log("Unsupported DMABUF buffer format\n");
+			weston_buffer_reference(&ps->buffer_ref, NULL);
+			return;
+			break;
+		}
 
-	ps->image = pixman_image_create_bits(pixman_format,
-		buffer->width, buffer->height,
-		wl_shm_buffer_get_data(shm_buffer),
-		wl_shm_buffer_get_stride(shm_buffer));
+		buffer->width = dmabuf_buffer->attributes.width;
+		buffer->height = dmabuf_buffer->attributes.height;
+
+		data = linux_dmabuf_buffer_get_user_data(dmabuf_buffer);
+		if (data) {
+			int stride = dmabuf_buffer->attributes.stride[0];
+			/* workaround for pixman handling only 32 bits format */
+			if (stride & 3)
+				stride = (stride & ~3) + 4;
+			ps->image = pixman_image_create_bits(pixman_format,
+												 buffer->width,
+												 buffer->height,
+												 data,
+												 stride);
+		} else
+			weston_log("failed to get data from dmabuf buffer\n");
+	}
 
 	ps->buffer_destroy_listener.notify =
 		buffer_state_handle_buffer_destroy;
@@ -756,6 +834,92 @@ pixman_renderer_destroy(struct weston_compositor *ec)
 	ec->renderer = NULL;
 }
 
+static uint32_t
+get_dmabuf_size(int32_t width, int32_t height, uint32_t format)
+{
+	uint32_t size = width * height;
+
+	switch (format) {
+	case DRM_FORMAT_NV12:
+		size = (size * 3) / 2;
+		break;
+	case DRM_FORMAT_RGB565:
+		size *= 2;
+		break;
+	case DRM_FORMAT_RGB888:
+	case DRM_FORMAT_BGR888:
+		size *= 3;
+		break;
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_ABGR8888:
+		size *= 4;
+		break;
+	default:
+		/* TODO: extend with other formats */
+		size *= 4;
+		break;
+	}
+
+	return size;
+}
+
+static void
+pixman_destroy_dmabuf(struct linux_dmabuf_buffer *buffer)
+{
+	uint32_t size;
+	void *data;
+
+	weston_log("pixman : destroying linux_dmabuf_buffer %p\n", buffer);
+
+	data = linux_dmabuf_buffer_get_user_data(buffer);
+	if (!data) {
+		weston_log("Warning: buffer data NULL\n");
+		return;
+	}
+
+	size = get_dmabuf_size(buffer->attributes.width,
+						   buffer->attributes.height,
+						   buffer->attributes.format);
+	if (munmap(data, size)) {
+		weston_log("ERROR: could not unmmap \n");
+		return;
+	}
+
+	linux_dmabuf_buffer_set_user_data(buffer, NULL, NULL);
+}
+
+static bool
+pixman_import_dmabuf(struct weston_compositor *ec, struct linux_dmabuf_buffer *buffer)
+{
+	uint32_t size;
+	void *data;
+
+	weston_log("pixman : importing linux_dmabuf_buffer %p\n", buffer);
+
+	data = linux_dmabuf_buffer_get_user_data(buffer);
+	if (data) {
+		weston_log("warning: buffer already imported\n");
+		return true;
+	}
+
+	size = get_dmabuf_size(buffer->attributes.width,
+						   buffer->attributes.height,
+						   buffer->attributes.format);
+	data = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED,
+				buffer->attributes.fd[0], 0);
+
+	if (!data) {
+		weston_log("ERROR: could not import buffer\n");
+		return false;
+	}
+
+	linux_dmabuf_buffer_set_user_data(buffer, data, pixman_destroy_dmabuf);
+
+	return true;
+}
+
 static void
 pixman_renderer_surface_get_content_size(struct weston_surface *surface,
 					 int *width, int *height)
@@ -845,6 +1009,7 @@ pixman_renderer_init(struct weston_compositor *ec)
 		pixman_renderer_surface_get_content_size;
 	renderer->base.surface_copy_content =
 		pixman_renderer_surface_copy_content;
+	renderer->base.import_dmabuf = pixman_import_dmabuf;
 	ec->renderer = &renderer->base;
 	ec->capabilities |= WESTON_CAP_ROTATION_ANY;
 	ec->capabilities |= WESTON_CAP_CAPTURE_YFLIP;
@@ -854,7 +1019,13 @@ pixman_renderer_init(struct weston_compositor *ec)
 		weston_compositor_add_debug_binding(ec, KEY_R,
 						    debug_binding, ec);
 
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_XBGR8888);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_ABGR8888);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_RGB888);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_BGR888);
 	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_RGB565);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_NV12);
+	wl_display_add_shm_format(ec->wl_display, WL_SHM_FORMAT_YUV420);
 
 	wl_signal_init(&renderer->destroy_signal);
 
diff --git a/libweston/windowed-output-api.h b/libweston/windowed-output-api.h
new file mode 100644
index 0000000..e0f78b4
--- /dev/null
+++ b/libweston/windowed-output-api.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright © 2016 Armin Krezović
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef WESTON_WINDOWED_OUTPUT_API_H
+#define WESTON_WINDOWED_OUTPUT_API_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#include "plugin-registry.h"
+
+struct weston_compositor;
+struct weston_output;
+
+#define WESTON_WINDOWED_OUTPUT_API_NAME "weston_windowed_output_api_v1"
+
+struct weston_windowed_output_api {
+	/** Assign a given width and height to an output.
+	 *
+	 * \param output An output to be configured.
+	 * \param width  Desired width of the output.
+	 * \param height Desired height of the output.
+	 *
+	 * Returns 0 on success, -1 on failure.
+	 *
+	 * This assigns a desired width and height to a windowed
+         * output. The backend decides what should be done and applies
+	 * the desired configuration. After using this function and
+	 * generic weston_output_set_*, a windowed
+	 * output should be in a state where weston_output_enable()
+	 * can be run.
+	 */
+	int (*output_set_size)(struct weston_output *output,
+			       int width, int height);
+
+	/** Create a new windowed output.
+	 *
+	 * \param compositor The compositor instance.
+	 * \param name       Desired name for a new output.
+	 *
+	 * Returns 0 on success, -1 on failure.
+	 *
+	 * This creates a new output in the backend using this API.
+	 * After this function is ran, the created output should be
+	 * ready for configuration using the output_configure() and
+	 * weston_output_set_{scale,transform}().
+	 *
+	 * An optional name can be assigned to it, so it can be used
+	 * by compositor to configure it. It can't be NULL.
+	 */
+	int (*output_create)(struct weston_compositor *compositor,
+			     const char *name);
+};
+
+static inline const struct weston_windowed_output_api *
+weston_windowed_output_get_api(struct weston_compositor *compositor)
+{
+	const void *api;
+	api = weston_plugin_api_get(compositor, WESTON_WINDOWED_OUTPUT_API_NAME,
+				    sizeof(struct weston_windowed_output_api));
+
+	return (const struct weston_windowed_output_api *)api;
+}
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /* WESTON_WINDOWED_OUTPUT_API_H */
diff --git a/protocol/capture.xml b/protocol/capture.xml
new file mode 100644
index 0000000..9c7cc3e
--- /dev/null
+++ b/protocol/capture.xml
@@ -0,0 +1,43 @@
+<protocol name="capture">
+
+  <interface name="wl_capture" version="1">
+    <request name="start">
+      <description summary="start display capture">
+	From this request, the compositor starts informing the client
+	each time the display output is updated with the related event
+      </description>
+       <arg name="output" type="object" interface="wl_output"/>
+    </request>
+
+    <request name="stop">
+      <description summary="start display capture">
+	From this request, the compositor stops informing the client
+	of any update
+      </description>
+      <arg name="output" type="object" interface="wl_output"/>
+    </request>
+
+    <enum name="error">
+      <entry name="bad_output" value="0"
+             summary="cannot capture wl_output"/>
+      <entry name="no_gl" value="1"
+             summary="gl renderer not set up"/>
+    </enum>
+
+    <event name="update">
+      <description summary="display output updated">
+	The display output has been updated.
+	dmabuf_fd identifies the buffer on display
+      </description>
+      <arg name="output" type="object" interface="wl_output"/>
+      <arg name="dmabuf_fd" type="fd"/>
+      <arg name="width" type="uint"/>
+      <arg name="height" type="uint"/>
+      <arg name="stride" type="uint"/>
+      <arg name="format" type="uint"/>
+      <arg name="msecs" type="uint"/>
+    </event>
+
+  </interface>
+
+</protocol>
-- 
2.7.4

