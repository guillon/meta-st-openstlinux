From aef11a2a951ac6b7867080826e024550f3abdffa Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@linaro.org>
Date: Thu, 7 Apr 2016 10:32:33 +0200
Subject: [PATCH 12/24] STM: waylandsink: support fullscreen

Add the fullscreen property that makes the sink displayed all across
the output.
This is implemented in two steps:
- the area_surface is displayed in fullscreen wayland mode
- the embededded video_surface is scaled to the output size

 Signed-off-by: Fabien Dessenne <fabien.dessenne@st.com>

Change-Id: I2562f83b3b27f5b2217dc74df87cd732266de836
---
 ext/wayland/gstwaylandsink.c | 32 +++++++++++++++++++++++++++++---
 ext/wayland/gstwaylandsink.h |  1 +
 ext/wayland/wldisplay.c      | 30 ++++++++++++++++++++++++++++++
 ext/wayland/wldisplay.h      |  4 ++++
 ext/wayland/wlwindow.c       | 14 ++++++++++----
 ext/wayland/wlwindow.h       |  3 ++-
 6 files changed, 76 insertions(+), 8 deletions(-)

diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 448aa9b..b71d46d 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -60,7 +60,8 @@ enum
 enum
 {
   PROP_0,
-  PROP_DISPLAY
+  PROP_DISPLAY,
+  PROP_FULLSCREEN
 };
 
 GST_DEBUG_CATEGORY (gstwayland_debug);
@@ -158,6 +159,11 @@ gst_wayland_sink_class_init (GstWaylandSinkClass * klass)
       g_param_spec_string ("display", "Wayland Display name", "Wayland "
           "display name to connect to, if not supplied via the GstContext",
           NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_FULLSCREEN,
+      g_param_spec_boolean ("fullscreen",
+          "Fullscreen", "Display on fullscreen", FALSE,
+          G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE));
 }
 
 static void
@@ -167,6 +173,8 @@ gst_wayland_sink_init (GstWaylandSink * sink)
 
   gst_base_sink_set_last_sample_enabled (basesink, FALSE);
 
+  sink->fullscreen = FALSE;
+
   g_mutex_init (&sink->display_lock);
   g_mutex_init (&sink->render_lock);
 }
@@ -183,6 +191,9 @@ gst_wayland_sink_get_property (GObject * object,
       g_value_set_string (value, sink->display_name);
       GST_OBJECT_UNLOCK (sink);
       break;
+    case PROP_FULLSCREEN:
+      g_value_set_boolean (value, sink->fullscreen);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -201,6 +212,9 @@ gst_wayland_sink_set_property (GObject * object,
       sink->display_name = g_value_dup_string (value);
       GST_OBJECT_UNLOCK (sink);
       break;
+    case PROP_FULLSCREEN:
+      sink->fullscreen = g_value_get_boolean (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -330,7 +344,7 @@ gst_wayland_sink_change_state (GstElement * element, GstStateChange transition)
           g_clear_object (&sink->window);
         } else {
           /* remove buffer from surface, show nothing */
-          gst_wl_window_render (sink->window, NULL, NULL);
+          gst_wl_window_render (sink->window, NULL, NULL, 0, 0);
         }
       }
       break;
@@ -577,6 +591,7 @@ render_last_buffer (GstWaylandSink * sink)
   const GstVideoInfo *info = NULL;
   struct wl_surface *surface;
   struct wl_callback *callback;
+  guint width = 0, height = 0;
 
   wlbuffer = gst_buffer_get_wl_buffer (sink->last_buffer);
   surface = gst_wl_window_get_wl_surface (sink->window);
@@ -589,7 +604,18 @@ render_last_buffer (GstWaylandSink * sink)
     info = &sink->video_info;
     sink->video_info_changed = FALSE;
   }
-  gst_wl_window_render (sink->window, wlbuffer, info);
+
+  if (G_UNLIKELY (sink->fullscreen) &&
+      G_UNLIKELY (!sink->window->set_size_done)) {
+    /* "_set_fullscreen" this only makes the area_surface in fullscreen, the
+     * video_surface needs then to be scaled */
+    wl_shell_surface_set_fullscreen (sink->window->shell_surface,
+        WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT, 0, NULL);
+    width = sink->display->output_width;
+    height = sink->display->output_height;
+  }
+
+  gst_wl_window_render (sink->window, wlbuffer, info, width, height);
 }
 
 static GstFlowReturn
diff --git a/ext/wayland/gstwaylandsink.h b/ext/wayland/gstwaylandsink.h
index afbed40..350cc4a 100644
--- a/ext/wayland/gstwaylandsink.h
+++ b/ext/wayland/gstwaylandsink.h
@@ -65,6 +65,7 @@ struct _GstWaylandSink
   gboolean redraw_pending;
   GMutex render_lock;
   GstBuffer *last_buffer;
+  gboolean fullscreen;
 };
 
 struct _GstWaylandSinkClass
diff --git a/ext/wayland/wldisplay.c b/ext/wayland/wldisplay.c
index 08c0e77..628d525 100644
--- a/ext/wayland/wldisplay.c
+++ b/ext/wayland/wldisplay.c
@@ -145,6 +145,31 @@ static const struct wl_shm_listener shm_listener = {
 };
 
 static void
+wl_display_handle_geometry (void *data, struct wl_output *wl_output,
+    int x, int y, int phy_w, int phy_h, int subpixel,
+    const char *make, const char *model, int transform)
+{
+  /* ignored */
+}
+
+static void
+wl_display_handle_mode (void *data, struct wl_output *wl_output, uint32_t flags,
+    int width, int height, int refresh)
+{
+  GstWlDisplay *self = data;
+
+  if (flags & WL_OUTPUT_MODE_CURRENT) {
+    self->output_width = width;
+    self->output_height = height;
+  }
+}
+
+static const struct wl_output_listener output_listener = {
+  wl_display_handle_geometry,
+  wl_display_handle_mode
+};
+
+static void
 registry_handle_global (void *data, struct wl_registry *registry,
     uint32_t id, const char *interface, uint32_t version)
 {
@@ -164,6 +189,9 @@ registry_handle_global (void *data, struct wl_registry *registry,
   } else if (g_strcmp0 (interface, "wp_viewporter") == 0) {
     self->viewporter =
         wl_registry_bind (registry, id, &wp_viewporter_interface, 1);
+  } else if ((g_strcmp0 (interface, "wl_output") == 0) && !self->output) {
+    self->output = wl_registry_bind (registry, id, &wl_output_interface, 1);
+    wl_output_add_listener (self->output, &output_listener, self);
   }
 }
 
@@ -237,6 +265,7 @@ gst_wl_display_new_existing (struct wl_display * display,
   self = g_object_new (GST_TYPE_WL_DISPLAY, NULL);
   self->display = display;
   self->own_display = take_ownership;
+  self->output = NULL;
 
   self->queue = wl_display_create_queue (self->display);
   self->registry = wl_display_get_registry (self->display);
@@ -268,6 +297,7 @@ gst_wl_display_new_existing (struct wl_display * display,
   VERIFY_INTERFACE_EXISTS (shell, "wl_shell");
   VERIFY_INTERFACE_EXISTS (shm, "wl_shm");
   VERIFY_INTERFACE_EXISTS (viewporter, "wp_viewporter");
+  VERIFY_INTERFACE_EXISTS (output, "wl_output");
 
 #undef VERIFY_INTERFACE_EXISTS
 
diff --git a/ext/wayland/wldisplay.h b/ext/wayland/wldisplay.h
index 9cbb500..95cc871 100644
--- a/ext/wayland/wldisplay.h
+++ b/ext/wayland/wldisplay.h
@@ -52,6 +52,7 @@ struct _GstWlDisplay
   struct wl_shell *shell;
   struct wl_shm *shm;
   struct wp_viewporter *viewporter;
+  struct wl_output *output;
   GArray *shm_formats;
 
   /* private */
@@ -62,6 +63,9 @@ struct _GstWlDisplay
   GMutex buffers_mutex;
   GHashTable *buffers;
   gboolean shutting_down;
+
+  gint output_width;
+  gint output_height;
 };
 
 struct _GstWlDisplayClass
diff --git a/ext/wayland/wlwindow.c b/ext/wayland/wlwindow.c
index bf3bcab..1f5e28c 100644
--- a/ext/wayland/wlwindow.c
+++ b/ext/wayland/wlwindow.c
@@ -141,6 +141,7 @@ gst_wl_window_new_internal (GstWlDisplay * display)
   window->x = 0;
   window->y = 0;
   window->pending_configure = FALSE;
+  window->set_size_done = FALSE;
 
   /* draw the area_subsurface */
   gst_video_info_set_format (&info,
@@ -289,9 +290,12 @@ gst_wl_window_resize_video_surface (GstWlWindow * window, gboolean commit)
 
 void
 gst_wl_window_render (GstWlWindow * window, GstWlBuffer * buffer,
-    const GstVideoInfo * info)
+    const GstVideoInfo * info, guint width, guint height)
 {
-  if (G_UNLIKELY (info)) {
+  if (G_UNLIKELY (width)) {
+    window->video_width = width;
+    window->video_height = height;
+  } else if (G_UNLIKELY (info)) {
     window->video_width =
         gst_util_uint64_scale_int_round (info->width, info->par_n, info->par_d);
     window->video_height = info->height;
@@ -308,13 +312,14 @@ gst_wl_window_render (GstWlWindow * window, GstWlBuffer * buffer,
   wl_surface_damage (window->video_surface, 0, 0, window->surface_width,
       window->surface_height);
 
-  if (G_UNLIKELY (window->pending_configure))
+  if (G_UNLIKELY (window->pending_configure) || G_UNLIKELY (width))
     wp_viewport_set_destination (window->video_viewport, window->video_width,
         window->video_height);
 
   wl_surface_commit (window->video_surface);
 
-  if (G_UNLIKELY (info) || G_UNLIKELY (window->pending_configure)) {
+  if (G_UNLIKELY (info) || G_UNLIKELY (window->pending_configure)
+      || G_UNLIKELY (width)) {
     /* commit also the parent (area_surface) in order to change
      * the position of the video_subsurface */
     wl_surface_attach (window->area_surface, window->area_buf->wlbuffer,
@@ -329,6 +334,7 @@ gst_wl_window_render (GstWlWindow * window, GstWlBuffer * buffer,
     window->x = 0;
     window->y = 0;
     window->pending_configure = FALSE;
+    window->set_size_done = TRUE;
   }
 
   wl_display_flush (window->display->display);
diff --git a/ext/wayland/wlwindow.h b/ext/wayland/wlwindow.h
index fde52fc..7a8bb00 100644
--- a/ext/wayland/wlwindow.h
+++ b/ext/wayland/wlwindow.h
@@ -60,6 +60,7 @@ struct _GstWlWindow
   gint x, y;
 
   gboolean pending_configure;
+  gboolean set_size_done;
 
   GstWlBuffer *area_buf;
 };
@@ -81,7 +82,7 @@ struct wl_surface *gst_wl_window_get_wl_surface (GstWlWindow * window);
 gboolean gst_wl_window_is_toplevel (GstWlWindow *window);
 
 void gst_wl_window_render (GstWlWindow * window, GstWlBuffer * buffer,
-        const GstVideoInfo * info);
+        const GstVideoInfo * info, guint width, guint height);
 void gst_wl_window_set_render_rectangle (GstWlWindow * window, gint x, gint y,
         gint w, gint h);
 
-- 
2.7.4

