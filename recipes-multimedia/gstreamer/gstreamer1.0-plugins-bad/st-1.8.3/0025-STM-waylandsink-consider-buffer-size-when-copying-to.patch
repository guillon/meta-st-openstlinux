From 00a640d52114a03698e48f2684b72a36f1af6f15 Mon Sep 17 00:00:00 2001
From: Fabien Dessenne <fabien.dessenne@st.com>
Date: Mon, 30 Jan 2017 11:25:24 +0100
Subject: [PATCH 25/26] STM: waylandsink: consider buffer size when copying to
 wl shm pool

When the sink receives a buffer that is neither a wl_shm one nor a
dmabuf one, this buffer is copied to an internal wl_shm buffer before
being sent to the display.
In that case, the actual size of the received buffer (which may differ
from the one negotiated in the caps) must be used.

*** STM internal ***
The gstreamer-0.10+ ported version of this patch will be proposed for
upstream.

Issue reproduced with this pipeline:
gst-launch-1.0 videotestsrc ! "video/x-raw,format=BGRx" ! v4l2video0convert ! "video/x-raw, format=NV12, width=500, height=500" ! waylandsink

In that case v4l2video0convert calls bdisp which aligns 500 to 504, so
the buffer is 504x500x1.5 bytes.

-> Crash in weston.

Change-Id: Iee9e7223cb49d997954df65fe8f03065817da67c
Signed-off-by: Fabien Dessenne <fabien.dessenne@st.com>
Reviewed-on: https://gerrit.st.com/64304
Reviewed-by: CITOOLS <smet-aci-reviews@lists.codex.cro.st.com>
---
 ext/wayland/gstwaylandsink.c | 22 +++++++++++++++++-----
 1 file changed, 17 insertions(+), 5 deletions(-)

diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 61c5527..cdeb77b 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -756,6 +756,8 @@ gst_wayland_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
         "display, creating it", buffer);
 
     /* update video info from video meta */
+    mem = gst_buffer_peek_memory (buffer, 0);
+
     vmeta = gst_buffer_get_video_meta (buffer);
     if (vmeta) {
       gint i;
@@ -763,13 +765,12 @@ gst_wayland_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
         sink->video_info.offset[i] = vmeta->offset[i];
         sink->video_info.stride[i] = vmeta->stride[i];
       }
+      sink->video_info.size = mem->size;
     } else if (buffer->pool) {
       /* update video info from pool video alignment */
       gst_wayland_set_video_alignment (buffer->pool, &sink->video_info);
     }
 
-    mem = gst_buffer_peek_memory (buffer, 0);
-
     if (gst_is_wl_shm_memory (mem))
       wbuf = gst_wl_shm_memory_construct_wl_buffer (mem, sink->display,
           &sink->video_info);
@@ -791,9 +792,20 @@ gst_wayland_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
 
       /* sink->pool always exists (created in set_caps), but it may not
        * be active if upstream is not using it */
-      if (!gst_buffer_pool_is_active (sink->pool) &&
-          !gst_buffer_pool_set_active (sink->pool, TRUE))
-        goto activate_failed;
+      if (!gst_buffer_pool_is_active (sink->pool)) {
+        GstStructure *config;
+        GstCaps *caps;
+        guint min, max;
+
+        /* update the pool buffers size */
+        config = gst_buffer_pool_get_config (sink->pool);
+        gst_buffer_pool_config_get_params (config, &caps, NULL, &min, &max);
+        gst_buffer_pool_config_set_params (config, caps, sink->video_info.size,
+            min, max);
+        if (!gst_buffer_pool_set_config (sink->pool, config) ||
+            !gst_buffer_pool_set_active (sink->pool, TRUE))
+          goto activate_failed;
+      }
 
       ret = gst_buffer_pool_acquire_buffer (sink->pool, &to_render, NULL);
       if (ret != GST_FLOW_OK)
-- 
2.7.4

