From bb88a36ec4f8410bce9633add14bd76ce5b21f4f Mon Sep 17 00:00:00 2001
From: Jean-Christophe Trotin <jean-christophe.trotin@st.com>
Date: Wed, 26 Oct 2016 15:25:24 +0200
Subject: [PATCH 22/23] v4l2transform: set the output format from imported pool
 video info

If the output-io-mode is GST_V4L2_IO_DMABUF_IMPORT, the output format
and selection shall be set according to the format of the upstream
pool buffers (resolution, alignment).

Change-Id: I99f1450e49f51731bc2b47d14fb19965498dc462
Reviewed-on: https://gerrit.st.com/58635
Tested-by: Jean Christophe TROTIN <jean-christophe.trotin@st.com>
Reviewed-by: Jean Christophe TROTIN <jean-christophe.trotin@st.com>
---
 sys/v4l2/gstv4l2transform.c | 92 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 92 insertions(+)

diff --git a/sys/v4l2/gstv4l2transform.c b/sys/v4l2/gstv4l2transform.c
index 3b17c1b..4bbfc6d 100644
--- a/sys/v4l2/gstv4l2transform.c
+++ b/sys/v4l2/gstv4l2transform.c
@@ -876,6 +876,88 @@ done:
 }
 
 static GstFlowReturn
+gst_v4l2_transform_set_output_format (GstV4l2Transform * self,
+    GstBufferPool * bpool)
+{
+  GstV4l2BufferPool *pool = GST_V4L2_BUFFER_POOL (bpool);
+  GstV4l2Object *obj = self->v4l2output;
+  GstVideoInfo *info;
+  GstStructure *config;
+  gboolean is_mplane;
+  guint32 pixelformat;
+  GstVideoAlignment align;
+  gint width, height, crop_width, crop_height;
+  struct v4l2_format format;
+  struct v4l2_selection selection;
+
+  is_mplane = V4L2_TYPE_IS_MULTIPLANAR (obj->type);
+  if (is_mplane != V4L2_TYPE_IS_MULTIPLANAR (pool->obj->type))
+    goto setup_failed;
+
+  info = &pool->obj->info;
+  pixelformat = obj->fmtdesc->pixelformat;
+  if (pixelformat != gst_video_format_to_fourcc (GST_VIDEO_INFO_FORMAT (info)))
+    goto setup_failed;
+
+  crop_width = GST_VIDEO_INFO_WIDTH (info);
+  crop_height = GST_VIDEO_INFO_HEIGHT (info);
+
+  gst_video_alignment_reset (&align);
+  config = gst_buffer_pool_get_config (bpool);
+  if (gst_buffer_pool_config_has_option (config,
+          GST_BUFFER_POOL_OPTION_VIDEO_ALIGNMENT))
+    gst_buffer_pool_config_get_video_alignment (config, &align);
+
+  width = crop_width + align.padding_left + align.padding_right;
+  height = crop_height + align.padding_top + align.padding_bottom;
+
+  GST_DEBUG_OBJECT (self, "Upstream pool buffers: %dx%d cropped to %dx%d",
+      width, height, crop_width, crop_height);
+
+  memset (&format, 0, sizeof (format));
+  format.type = obj->type;
+  if (is_mplane) {
+    gint n_planes = GST_VIDEO_INFO_N_PLANES (info);
+    gint i = 0;
+
+    format.fmt.pix_mp.pixelformat = pixelformat;
+    format.fmt.pix_mp.width = width;
+    format.fmt.pix_mp.height = height;
+    format.fmt.pix_mp.num_planes = n_planes;
+
+    for (i = 0; i < n_planes; i++)
+      format.fmt.pix_mp.plane_fmt[i].bytesperline =
+          GST_VIDEO_INFO_PLANE_STRIDE (info, i);
+  } else {
+    format.fmt.pix.pixelformat = pixelformat;
+    format.fmt.pix.width = width;
+    format.fmt.pix.height = height;
+    format.fmt.pix.bytesperline = GST_VIDEO_INFO_PLANE_STRIDE (info, 0);
+  }
+
+  if (v4l2_ioctl (obj->video_fd, VIDIOC_S_FMT, &format) < 0)
+    goto setup_failed;
+
+  if ((width != crop_width) || (height != crop_height)) {
+    memset (&selection, 0, sizeof selection);
+    selection.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+    selection.target = V4L2_SEL_TGT_CROP;
+    selection.r.width = crop_width;
+    selection.r.height = crop_height;
+
+    if (v4l2_ioctl (obj->video_fd, VIDIOC_S_SELECTION, &selection) < 0)
+      goto setup_failed;
+  }
+
+  return GST_FLOW_OK;
+
+setup_failed:
+  GST_ERROR_OBJECT (self,
+      "failed to set the output format from the format of the upstream pool buffers");
+  return GST_FLOW_ERROR;
+}
+
+static GstFlowReturn
 gst_v4l2_transform_prepare_output_buffer (GstBaseTransform * trans,
     GstBuffer * inbuf, GstBuffer ** outbuf)
 {
@@ -893,6 +975,16 @@ gst_v4l2_transform_prepare_output_buffer (GstBaseTransform * trans,
   /* Ensure input internal pool is active */
   if (!gst_buffer_pool_is_active (pool)) {
     GstStructure *config = gst_buffer_pool_get_config (pool);
+
+    if ((inbuf->pool != pool) &&
+        (self->v4l2output->mode == GST_V4L2_IO_DMABUF_IMPORT))
+      /* in importing mode, set the output format according to the format
+       * of the upstream pool buffers (resolution, alignment)
+       */
+      if (gst_v4l2_transform_set_output_format (self, inbuf->pool) !=
+          GST_FLOW_OK)
+        goto activate_failed;
+
     gint min = self->v4l2output->min_buffers == 0 ? GST_V4L2_MIN_BUFFERS :
         self->v4l2output->min_buffers;
     gst_buffer_pool_config_set_params (config, self->incaps,
-- 
2.7.4

