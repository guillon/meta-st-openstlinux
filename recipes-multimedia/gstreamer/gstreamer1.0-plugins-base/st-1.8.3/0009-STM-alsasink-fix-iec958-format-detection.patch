From 1996121423af57e47f30ba3bf865e47dfaf8d8dc Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@linaro.org>
Date: Wed, 6 Apr 2016 15:55:39 +0200
Subject: [PATCH 09/13] STM: alsasink: fix iec958 format detection

Add specific function that first close the current pcm device
before trying to re-open it with AES parameters.

Change-Id: I943f0c5d392bd4d3a7898bb2d13fa762d3fdfb5e
Signed-off-by: Arnaud Pouliquen <arnaud.pouliquen@st.com>
---
 ext/alsa/gstalsa.c     | 61 ++++++++++++++++++++++++++++++++++++++------------
 ext/alsa/gstalsa.h     |  4 ++++
 ext/alsa/gstalsasink.c | 13 +++++++++++
 3 files changed, 64 insertions(+), 14 deletions(-)

diff --git a/ext/alsa/gstalsa.c b/ext/alsa/gstalsa.c
index 9d2a973..52fa1aa 100644
--- a/ext/alsa/gstalsa.c
+++ b/ext/alsa/gstalsa.c
@@ -488,7 +488,6 @@ gst_alsa_probe_supported_formats (GstObject * obj, gchar * device,
     snd_pcm_t * handle, const GstCaps * template_caps)
 {
   snd_pcm_hw_params_t *hw_params;
-  snd_pcm_stream_t stream_type;
   GstCaps *caps;
   gint err;
 
@@ -496,8 +495,6 @@ gst_alsa_probe_supported_formats (GstObject * obj, gchar * device,
   if ((err = snd_pcm_hw_params_any (handle, hw_params)) < 0)
     goto error;
 
-  stream_type = snd_pcm_stream (handle);
-
   caps = gst_alsa_detect_formats (obj, hw_params,
       gst_caps_copy (template_caps), G_BYTE_ORDER);
 
@@ -519,17 +516,6 @@ gst_alsa_probe_supported_formats (GstObject * obj, gchar * device,
   if (!(caps = gst_alsa_detect_channels (obj, hw_params, caps)))
     goto subroutine_error;
 
-  /* Try opening IEC958 device to see if we can support that format (playback
-   * only for now but we could add SPDIF capture later) */
-  if (stream_type == SND_PCM_STREAM_PLAYBACK) {
-    snd_pcm_t *pcm = gst_alsa_open_iec958_pcm (obj, device);
-
-    if (G_LIKELY (pcm)) {
-      gst_caps_append (caps, gst_caps_from_string (PASSTHROUGH_CAPS));
-      snd_pcm_close (pcm);
-    }
-  }
-
   snd_pcm_hw_params_free (hw_params);
   return caps;
 
@@ -549,6 +535,53 @@ subroutine_error:
   }
 }
 
+/*
+ * gst_alsa_probe_supported_formats:
+ *
+ * Takes the template caps and returns the subset which is actually
+ * supported by this device.
+ */
+gboolean gst_alsa_iec958_formats_supported (GstObject * obj, gchar * device,
+    snd_pcm_t ** handle)
+{
+  snd_pcm_stream_t stream_type;
+  gboolean supported = FALSE;
+  snd_pcm_t *pcm;
+  gint err;
+
+  /* Try opening IEC958 device to see if we can support that format (playback
+   * only for now but we could add SPDIF capture later) */
+  stream_type = snd_pcm_stream (*handle);
+  if (stream_type == SND_PCM_STREAM_PLAYBACK) {
+    /* Close the exiting device to re-open it as iec958 device*/
+    err = snd_pcm_close(*handle);
+    if (G_UNLIKELY (err < 0)) {
+      GST_DEBUG_OBJECT (obj, " failed closing alsa device: %s",
+        snd_strerror (err));
+      return FALSE;
+    }
+
+    pcm = gst_alsa_open_iec958_pcm(GST_OBJECT (obj), device);
+    if (G_LIKELY (pcm)) {
+      supported = TRUE;
+      snd_pcm_close (pcm);
+    }
+
+    /* Reopen device in raw audio mode*/
+    err = snd_pcm_open (handle, device, SND_PCM_STREAM_PLAYBACK,
+        SND_PCM_NONBLOCK);
+    if (G_UNLIKELY (err < 0)) {
+       GST_DEBUG_OBJECT (obj, "failed re-opening alsa device: %s",
+           snd_strerror (err));
+    }
+    return supported;
+  }
+
+  GST_DEBUG_OBJECT (obj, "only supported for playback");
+  return FALSE;
+
+}
+
 /* returns the card name when the device number is unknown or -1 */
 static gchar *
 gst_alsa_find_device_name_no_handle (GstObject * obj, const gchar * devcard,
diff --git a/ext/alsa/gstalsa.h b/ext/alsa/gstalsa.h
index 8026619..292f04a 100644
--- a/ext/alsa/gstalsa.h
+++ b/ext/alsa/gstalsa.h
@@ -58,6 +58,10 @@ GstCaps * gst_alsa_probe_supported_formats (GstObject      * obj,
                                             snd_pcm_t      * handle,
                                             const GstCaps  * template_caps);
 
+gboolean gst_alsa_iec958_formats_supported (GstObject * obj,
+                                            gchar * device,
+                                            snd_pcm_t ** handle);
+
 gchar   * gst_alsa_find_device_name (GstObject        * obj,
                                      const gchar      * device,
                                      snd_pcm_t        * handle,
diff --git a/ext/alsa/gstalsasink.c b/ext/alsa/gstalsasink.c
index 4233cb5..a5e8605 100644
--- a/ext/alsa/gstalsasink.c
+++ b/ext/alsa/gstalsasink.c
@@ -283,6 +283,9 @@ gst_alsasink_getcaps (GstBaseSink * bsink, GstCaps * filter)
   GstPadTemplate *pad_template;
   GstAlsaSink *sink = GST_ALSA_SINK (bsink);
   GstCaps *caps, *templ_caps;
+  snd_pcm_stream_t stream_type;
+  snd_pcm_t *pcm;
+  int res;
 
   GST_OBJECT_LOCK (sink);
   if (sink->handle == NULL) {
@@ -321,6 +324,16 @@ gst_alsasink_getcaps (GstBaseSink * bsink, GstCaps * filter)
       sink->handle, templ_caps);
   gst_caps_unref (templ_caps);
 
+  /* Try opening IEC958 device to see if we can support that format (playback
+   * only for now but we could add SPDIF capture later)
+   */
+
+  if (gst_alsa_iec958_formats_supported(GST_OBJECT (sink), sink->device,
+    &sink->handle) == TRUE) {
+    GST_LOG_OBJECT (sink, "Add pass-through capabilities");
+    gst_caps_append (caps, gst_caps_from_string (PASSTHROUGH_CAPS));
+  }
+
   if (caps) {
     sink->cached_caps = gst_caps_ref (caps);
   }
-- 
2.7.4

