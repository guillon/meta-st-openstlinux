From 2efa12e97bf2fb5a10c4dceb1f06488069dbef55 Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@st.com>
Date: Fri, 17 Feb 2017 11:42:49 +0100
Subject: [PATCH 4/4] add libhva and codecparser

---
 configure.ac                                       |   15 +
 lib/Makefile.am                                    |    4 +-
 lib/libv4l-codecparsers/Makefile.am                |   20 +
 lib/libv4l-codecparsers/codecparsers/Makefile.am   |   40 +
 .../codecparsers/gstmpegvideoparser.c              | 1311 +++++++++
 .../codecparsers/gstmpegvideoparser.h              |  574 ++++
 lib/libv4l-codecparsers/codecparsers/parserutils.c |   57 +
 lib/libv4l-codecparsers/codecparsers/parserutils.h |  108 +
 lib/libv4l-codecparsers/libv4l-codecparsers.pc.in  |   12 +
 lib/libv4l-codecparsers/libv4l-cparsers-mpeg2.c    |  366 +++
 lib/libv4l-codecparsers/libv4l-cparsers.c          |  455 +++
 lib/libv4l-codecparsers/libv4l-cparsers.h          |  120 +
 lib/libv4l-hva/Makefile.am                         |   32 +
 lib/libv4l-hva/gst/base/gstbitwriter.c             |  278 ++
 lib/libv4l-hva/gst/base/gstbitwriter.h             |  361 +++
 lib/libv4l-hva/gst/codecparsers/gsth264parser.h    |  807 ++++++
 lib/libv4l-hva/gst/vaapi/glibcompat.h              |  164 ++
 lib/libv4l-hva/gst/vaapi/gstcompat.h               |  351 +++
 lib/libv4l-hva/gst/vaapi/gstvaapicodec_objects.h   |  270 ++
 lib/libv4l-hva/gst/vaapi/gstvaapicodedbuffer.h     |   53 +
 .../gst/vaapi/gstvaapicodedbuffer_priv.h           |   78 +
 lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferpool.h |   45 +
 .../gst/vaapi/gstvaapicodedbufferproxy.h           |   82 +
 .../gst/vaapi/gstvaapicodedbufferproxy_priv.h      |   70 +
 lib/libv4l-hva/gst/vaapi/gstvaapicompat.h          |   57 +
 lib/libv4l-hva/gst/vaapi/gstvaapicontext.h         |  148 +
 lib/libv4l-hva/gst/vaapi/gstvaapicontext_overlay.h |   52 +
 lib/libv4l-hva/gst/vaapi/gstvaapidebug.h           |   33 +
 lib/libv4l-hva/gst/vaapi/gstvaapidecoder.h         |  134 +
 lib/libv4l-hva/gst/vaapi/gstvaapidecoder_objects.h |  263 ++
 lib/libv4l-hva/gst/vaapi/gstvaapidisplay.h         |  209 ++
 lib/libv4l-hva/gst/vaapi/gstvaapidisplay_priv.h    |  266 ++
 lib/libv4l-hva/gst/vaapi/gstvaapidisplaycache.h    |   79 +
 lib/libv4l-hva/gst/vaapi/gstvaapiencoder.h         |  178 ++
 lib/libv4l-hva/gst/vaapi/gstvaapiencoder_h264.c    | 2922 ++++++++++++++++++++
 lib/libv4l-hva/gst/vaapi/gstvaapiencoder_h264.h    |  160 ++
 lib/libv4l-hva/gst/vaapi/gstvaapiencoder_objects.h |  277 ++
 lib/libv4l-hva/gst/vaapi/gstvaapiencoder_priv.h    |  345 +++
 lib/libv4l-hva/gst/vaapi/gstvaapiimage.h           |  136 +
 lib/libv4l-hva/gst/vaapi/gstvaapiminiobject.h      |  156 ++
 lib/libv4l-hva/gst/vaapi/gstvaapiobject.h          |   79 +
 lib/libv4l-hva/gst/vaapi/gstvaapiobject_priv.h     |  257 ++
 lib/libv4l-hva/gst/vaapi/gstvaapiparser_frame.h    |   87 +
 lib/libv4l-hva/gst/vaapi/gstvaapiprofile.h         |  206 ++
 lib/libv4l-hva/gst/vaapi/gstvaapisubpicture.h      |   86 +
 lib/libv4l-hva/gst/vaapi/gstvaapisurface.h         |  226 ++
 lib/libv4l-hva/gst/vaapi/gstvaapisurface_priv.h    |  118 +
 lib/libv4l-hva/gst/vaapi/gstvaapisurfacepool.h     |   44 +
 lib/libv4l-hva/gst/vaapi/gstvaapisurfaceproxy.h    |  150 +
 lib/libv4l-hva/gst/vaapi/gstvaapitexture.h         |   96 +
 lib/libv4l-hva/gst/vaapi/gstvaapitypes.h           |  153 +
 lib/libv4l-hva/gst/vaapi/gstvaapiutils.h           |  135 +
 lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264.c      |  399 +++
 lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264.h      |   95 +
 lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264_priv.h |   95 +
 lib/libv4l-hva/gst/vaapi/gstvaapivalue.h           |  162 ++
 lib/libv4l-hva/gst/vaapi/gstvaapivideopool.h       |   94 +
 lib/libv4l-hva/gst/vaapi/gstvaapivideopool_priv.h  |  107 +
 lib/libv4l-hva/gst/vaapi/gstvaapiworkarounds.h     |   42 +
 lib/libv4l-hva/gst/vaapi/libgstvaapi_priv_check.h  |   25 +
 lib/libv4l-hva/gst/vaapi/video-format.h            |   61 +
 lib/libv4l-hva/libv4l-hva-h264.c                   |  404 +++
 lib/libv4l-hva/libv4l-hva.c                        |  323 +++
 lib/libv4l-hva/libv4l-hva.h                        |  102 +
 lib/libv4l-hva/va/sysdeps.h                        |   79 +
 lib/libv4l-hva/va/va.h                             | 2666 ++++++++++++++++++
 lib/libv4l-hva/va/va_compat.h                      |  116 +
 lib/libv4l-hva/va/va_dec_jpeg.h                    |  178 ++
 lib/libv4l-hva/va/va_enc_h264.h                    |  592 ++++
 lib/libv4l-hva/va/va_version.h                     |   85 +
 70 files changed, 18349 insertions(+), 1 deletion(-)
 create mode 100644 lib/libv4l-codecparsers/Makefile.am
 create mode 100644 lib/libv4l-codecparsers/codecparsers/Makefile.am
 create mode 100644 lib/libv4l-codecparsers/codecparsers/gstmpegvideoparser.c
 create mode 100644 lib/libv4l-codecparsers/codecparsers/gstmpegvideoparser.h
 create mode 100644 lib/libv4l-codecparsers/codecparsers/parserutils.c
 create mode 100644 lib/libv4l-codecparsers/codecparsers/parserutils.h
 create mode 100644 lib/libv4l-codecparsers/libv4l-codecparsers.pc.in
 create mode 100644 lib/libv4l-codecparsers/libv4l-cparsers-mpeg2.c
 create mode 100644 lib/libv4l-codecparsers/libv4l-cparsers.c
 create mode 100644 lib/libv4l-codecparsers/libv4l-cparsers.h
 create mode 100644 lib/libv4l-hva/Makefile.am
 create mode 100644 lib/libv4l-hva/gst/base/gstbitwriter.c
 create mode 100644 lib/libv4l-hva/gst/base/gstbitwriter.h
 create mode 100644 lib/libv4l-hva/gst/codecparsers/gsth264parser.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/glibcompat.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstcompat.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapicodec_objects.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapicodedbuffer.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapicodedbuffer_priv.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferpool.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferproxy.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferproxy_priv.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapicompat.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapicontext.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapicontext_overlay.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapidebug.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapidecoder.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapidecoder_objects.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapidisplay.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapidisplay_priv.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapidisplaycache.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiencoder.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiencoder_h264.c
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiencoder_h264.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiencoder_objects.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiencoder_priv.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiimage.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiminiobject.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiobject.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiobject_priv.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiparser_frame.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiprofile.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapisubpicture.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapisurface.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapisurface_priv.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapisurfacepool.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapisurfaceproxy.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapitexture.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapitypes.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiutils.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264.c
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264_priv.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapivalue.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapivideopool.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapivideopool_priv.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/gstvaapiworkarounds.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/libgstvaapi_priv_check.h
 create mode 100644 lib/libv4l-hva/gst/vaapi/video-format.h
 create mode 100644 lib/libv4l-hva/libv4l-hva-h264.c
 create mode 100644 lib/libv4l-hva/libv4l-hva.c
 create mode 100644 lib/libv4l-hva/libv4l-hva.h
 create mode 100644 lib/libv4l-hva/va/sysdeps.h
 create mode 100644 lib/libv4l-hva/va/va.h
 create mode 100644 lib/libv4l-hva/va/va_compat.h
 create mode 100644 lib/libv4l-hva/va/va_dec_jpeg.h
 create mode 100644 lib/libv4l-hva/va/va_enc_h264.h
 create mode 100644 lib/libv4l-hva/va/va_version.h

diff --git a/configure.ac b/configure.ac
index ded4cfb..656ac1a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -17,6 +17,9 @@ AC_CONFIG_FILES([Makefile
 	lib/libdvbv5/Makefile
 	lib/libv4l2rds/Makefile
 	lib/libv4l-mplane/Makefile
+	lib/libv4l-hva/Makefile
+	lib/libv4l-codecparsers/Makefile
+	lib/libv4l-codecparsers/codecparsers/Makefile
 
 	utils/Makefile
 	utils/libv4l2util/Makefile
@@ -56,6 +59,7 @@ AC_CONFIG_FILES([Makefile
 	lib/libv4lconvert/libv4lconvert.pc
 	lib/libv4l1/libv4l1.pc
 	lib/libv4l2/libv4l2.pc
+	lib/libv4l-codecparsers/libv4l-codecparsers.pc
 	lib/libdvbv5/libdvbv5.pc
 	lib/libv4l2rds/libv4l2rds.pc
 	utils/media-ctl/libmediactl.pc
@@ -352,6 +356,17 @@ AC_DEFINE_DIR([LIBV4LCONVERT_PRIV_DIR], [libv4lconvertprivdir], [libv4lconvert p
 AC_DEFINE_DIR([IR_KEYTABLE_SYSTEM_DIR], [keytablesystemdir], [ir-keytable preinstalled tables directory])
 AC_DEFINE_DIR([IR_KEYTABLE_USER_DIR], [keytableuserdir], [ir-keytable user defined tables directory])
 
+dnl ---------------------------------------------------------------------------
+dnl -- GStreamer                                                             --
+dnl ---------------------------------------------------------------------------
+
+PKG_CHECK_MODULES([GST], [gstreamer-1.0 >= 1.0])
+PKG_CHECK_MODULES([GST_BASE], [gstreamer-base-1.0 >= 1.0])
+
+dnl ---------------------------------------------------------------------------
+dnl -- Gstreamer end                                                         --
+dnl ---------------------------------------------------------------------------
+
 MAJOR=`echo "$PACKAGE_VERSION" | perl -ne 'print $1 if (m/^(\d+)\.(\d+)\.(\d+)/)'`
 MINOR=`echo "$PACKAGE_VERSION" | perl -ne 'print $2 if (m/^(\d+)\.(\d+)\.(\d+)/)'`
 PATCH=`echo "$PACKAGE_VERSION" | perl -ne 'print $3 if (m/^(\d+)\.(\d+)\.(\d+)/)'`
diff --git a/lib/Makefile.am b/lib/Makefile.am
index a105c95..30844a7 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -3,7 +3,9 @@ SUBDIRS = \
 	libv4l2 \
 	libv4l1 \
 	libv4l2rds \
-	libv4l-mplane
+	libv4l-codecparsers \
+	libv4l-mplane \
+	libv4l-hva
 
 if WITH_LIBDVBV5
 SUBDIRS += \
diff --git a/lib/libv4l-codecparsers/Makefile.am b/lib/libv4l-codecparsers/Makefile.am
new file mode 100644
index 0000000..79ac183
--- /dev/null
+++ b/lib/libv4l-codecparsers/Makefile.am
@@ -0,0 +1,20 @@
+if WITH_V4L_PLUGINS
+libv4l2plugin_LTLIBRARIES = libv4l-codecparsers.la
+endif
+
+libv4l_codecparsers_la_SOURCES = libv4l-cparsers.c libv4l-cparsers.h
+
+libv4l_codecparsers_la_CPPFLAGS = $(CFLAG_VISIBILITY)
+libv4l_codecparsers_la_LDFLAGS = -avoid-version -module -shared -export-dynamic -lpthread
+libv4l_codecparsers_la_LIBADD = ../libv4l2/libv4l2.la
+
+# GStreamer codecparsers library
+noinst_HEADERS = codecparsers/parserutils.h
+libv4l_codecparsers_la_SOURCES += codecparsers/parserutils.c
+libv4l_codecparsers_la_SOURCES += codecparsers/gstmpegvideoparser.c
+libv4l_codecparsers_la_CFLAGS =	$(GST_CFLAGS)	-DGST_USE_UNSTABLE_API
+libv4l_codecparsers_la_LDFLAGS +=	$(GST_LIB_LDFLAGS)
+libv4l_codecparsers_la_LIBADD +=	$(GLIB_LIBS)	$(GST_BASE_LIBS)	$(GST_LIBS)
+
+# MPEG-2 parser back-end
+libv4l_codecparsers_la_SOURCES += libv4l-cparsers-mpeg2.c
diff --git a/lib/libv4l-codecparsers/codecparsers/Makefile.am b/lib/libv4l-codecparsers/codecparsers/Makefile.am
new file mode 100644
index 0000000..bd77573
--- /dev/null
+++ b/lib/libv4l-codecparsers/codecparsers/Makefile.am
@@ -0,0 +1,40 @@
+lib_LTLIBRARIES = libgstcodecparsers.la
+
+libgstcodecparsers_la_SOURCES = \
+	gstmpegvideoparser.c \
+	parserutils.c \
+	gstmpegvideoparser.h \
+	$(NULL)
+
+noinst_HEADERS = parserutils.h
+
+libgstcodecparsers_la_CFLAGS = \
+	$(GST_BASE_CFLAGS) \
+	-DGST_USE_UNSTABLE_API \
+	$(GST_CFLAGS)
+
+libgstcodecparsers_la_LIBADD = \
+	$(GST_BASE_LIBS) \
+	$(GST_LIBS) \
+	$(LIBM)
+
+libgstcodecparsers_la_LDFLAGS = \
+	$(GST_LIB_LDFLAGS) \
+	$(GST_ALL_LDFLAGS) \
+	$(GST_LT_LDFLAGS)
+
+Android.mk:  $(BUILT_SOURCES) Makefile.am
+	androgenizer -:PROJECT libgstcodecparsers -:STATIC libgstcodecparsers-@GST_API_VERSION@ \
+	 -:TAGS eng debug \
+         -:REL_TOP $(top_srcdir) -:ABS_TOP $(abs_top_srcdir) \
+	 -:SOURCES $(libgstcodecparsers_@GST_API_VERSION@_la_SOURCES) \
+         $(built_sources) \
+	 -:CFLAGS $(DEFS) $(libgstcodecparsers_@GST_API_VERSION@_la_CFLAGS) \
+	 -:LDFLAGS $(libgstcodecparsers_@GST_API_VERSION@_la_LDFLAGS) \
+	           $(libgstcodecparsers@GST_API_VERSION@_la_LIBADD) \
+	           -ldl \
+	 -:HEADER_TARGET gstreamer-@GST_API_VERSION@/gst/codecparsers \
+	 -:HEADERS $(libgstcodecparsersinclude_HEADERS) \
+         $(built_headers) \
+	 -:PASSTHROUGH LOCAL_ARM_MODE:=arm \
+	> $@
diff --git a/lib/libv4l-codecparsers/codecparsers/gstmpegvideoparser.c b/lib/libv4l-codecparsers/codecparsers/gstmpegvideoparser.c
new file mode 100644
index 0000000..0d903e1
--- /dev/null
+++ b/lib/libv4l-codecparsers/codecparsers/gstmpegvideoparser.c
@@ -0,0 +1,1311 @@
+/* Gstreamer
+ * Copyright (C) <2011> Intel Corporation
+ * Copyright (C) <2011> Collabora Ltd.
+ * Copyright (C) <2011> Thibault Saunier <thibault.saunier@collabora.com>
+ *
+ * From bad/sys/vdpau/mpeg/mpegutil.c:
+ *   Copyright (C) <2007> Jan Schmidt <thaytan@mad.scientist.com>
+ *   Copyright (C) <2009> Carl-Anton Ingmarsson <ca.ingmarsson@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:gstmpegvideoparser
+ * @short_description: Convenience library for mpeg1 and 2 video
+ * bitstream parsing.
+ *
+ * <refsect2>
+ * <para>
+ * Provides useful functions for mpeg videos bitstream parsing.
+ * </para>
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "gstmpegvideoparser.h"
+#include "parserutils.h"
+
+#include <string.h>
+#include <gst/base/gstbitreader.h>
+#include <gst/base/gstbytereader.h>
+
+#define MARKER_BIT 0x1
+
+/* default intra quant matrix, in zig-zag order */
+static const guint8 default_intra_quantizer_matrix[64] = {
+  8,
+  16, 16,
+  19, 16, 19,
+  22, 22, 22, 22,
+  22, 22, 26, 24, 26,
+  27, 27, 27, 26, 26, 26,
+  26, 27, 27, 27, 29, 29, 29,
+  34, 34, 34, 29, 29, 29, 27, 27,
+  29, 29, 32, 32, 34, 34, 37,
+  38, 37, 35, 35, 34, 35,
+  38, 38, 40, 40, 40,
+  48, 48, 46, 46,
+  56, 56, 58,
+  69, 69,
+  83
+};
+
+static const guint8 mpeg_zigzag_8x8[64] = {
+  0, 1, 8, 16, 9, 2, 3, 10,
+  17, 24, 32, 25, 18, 11, 4, 5,
+  12, 19, 26, 33, 40, 48, 41, 34,
+  27, 20, 13, 6, 7, 14, 21, 28,
+  35, 42, 49, 56, 57, 50, 43, 36,
+  29, 22, 15, 23, 30, 37, 44, 51,
+  58, 59, 52, 45, 38, 31, 39, 46,
+  53, 60, 61, 54, 47, 55, 62, 63
+};
+
+enum
+{
+  GST_MPEG_VIDEO_MACROBLOCK_ESCAPE = G_MAXUINT,
+};
+
+/* Table B-1: Variable length codes for macroblock_address_increment */
+static const VLCTable mpeg2_mbaddr_vlc_table[] = {
+  {1, 0x01, 1},
+  {2, 0x03, 3},
+  {3, 0x02, 3},
+  {4, 0x03, 4},
+  {5, 0x02, 4},
+  {6, 0x03, 5},
+  {7, 0x02, 5},
+  {8, 0x07, 7},
+  {9, 0x06, 7},
+  {10, 0x0b, 8},
+  {11, 0x0a, 8},
+  {12, 0x09, 8},
+  {13, 0x08, 8},
+  {14, 0x07, 8},
+  {15, 0x06, 8},
+  {16, 0x17, 10},
+  {17, 0x16, 10},
+  {18, 0x15, 10},
+  {19, 0x14, 10},
+  {20, 0x13, 10},
+  {21, 0x12, 10},
+  {22, 0x23, 11},
+  {23, 0x22, 11},
+  {24, 0x21, 11},
+  {25, 0x20, 11},
+  {26, 0x1f, 11},
+  {27, 0x1e, 11},
+  {28, 0x1d, 11},
+  {29, 0x1c, 11},
+  {30, 0x1b, 11},
+  {31, 0x1a, 11},
+  {32, 0x19, 11},
+  {33, 0x18, 11},
+  {GST_MPEG_VIDEO_MACROBLOCK_ESCAPE, 0x08, 11}
+};
+
+GST_DEBUG_CATEGORY (mpegvideo_parser_debug);
+#define GST_CAT_DEFAULT mpegvideo_parser_debug
+
+#define INITIALIZE_DEBUG_CATEGORY \
+  GST_DEBUG_CATEGORY_INIT (mpegvideo_parser_debug, "codecparsers_mpegvideo", \
+      0, "Mpegvideo parser library");
+
+
+/* Set the Pixel Aspect Ratio in our hdr from a ASR code in the data */
+static void
+set_par_from_asr_mpeg1 (GstMpegVideoSequenceHdr * seqhdr, guint8 asr_code)
+{
+  int ratios[16][2] = {
+    {0, 0},                     /* 0, Invalid */
+    {1, 1},                     /* 1, 1.0 */
+    {10000, 6735},              /* 2, 0.6735 */
+    {64, 45},                   /* 3, 0.7031 16:9 625 line */
+    {10000, 7615},              /* 4, 0.7615 */
+    {10000, 8055},              /* 5, 0.8055 */
+    {32, 27},                   /* 6, 0.8437 */
+    {10000, 8935},              /* 7, 0.8935 */
+    {10000, 9375},              /* 8, 0.9375 */
+    {10000, 9815},              /* 9, 0.9815 */
+    {10000, 10255},             /* 10, 1.0255 */
+    {10000, 10695},             /* 11, 1.0695 */
+    {8, 9},                     /* 12, 1.125 */
+    {10000, 11575},             /* 13, 1.1575 */
+    {10000, 12015},             /* 14, 1.2015 */
+    {0, 0},                     /* 15, invalid */
+  };
+  asr_code &= 0xf;
+
+  seqhdr->par_w = ratios[asr_code][0];
+  seqhdr->par_h = ratios[asr_code][1];
+}
+
+static void
+set_fps_from_code (GstMpegVideoSequenceHdr * seqhdr, guint8 fps_code)
+{
+  const gint framerates[][2] = {
+    {30, 1}, {24000, 1001}, {24, 1}, {25, 1},
+    {30000, 1001}, {30, 1}, {50, 1}, {60000, 1001},
+    {60, 1}, {30, 1}
+  };
+
+  if (fps_code && fps_code < 10) {
+    seqhdr->fps_n = framerates[fps_code][0];
+    seqhdr->fps_d = framerates[fps_code][1];
+  } else {
+    GST_DEBUG ("unknown/invalid frame_rate_code %d", fps_code);
+    /* Force a valid framerate */
+    /* FIXME or should this be kept unknown ?? */
+    seqhdr->fps_n = 30000;
+    seqhdr->fps_d = 1001;
+  }
+}
+
+/* @size and @offset are wrt current reader position */
+static inline gint
+scan_for_start_codes (const GstByteReader * reader, guint offset, guint size)
+{
+  const guint8 *data;
+  guint i = 0;
+
+  g_assert ((guint64) offset + size <= reader->size - reader->byte);
+
+  /* we can't find the pattern with less than 4 bytes */
+  if (G_UNLIKELY (size < 4))
+    return -1;
+
+  data = reader->data + reader->byte + offset;
+
+  while (i <= (size - 4)) {
+    if (data[i + 2] > 1) {
+      i += 3;
+    } else if (data[i + 1]) {
+      i += 2;
+    } else if (data[i] || data[i + 2] != 1) {
+      i++;
+    } else {
+      break;
+    }
+  }
+
+  if (i <= (size - 4))
+    return offset + i;
+
+  /* nothing found */
+  return -1;
+}
+
+/****** API *******/
+/**
+ * gst_mpeg_video_get_extension_code:
+ * @packet: a #GstMpegVideoPacket to read to find the extension code
+ *
+ * Returns: extension code
+ */
+guint8 gst_mpeg_video_get_extension_code (const GstMpegVideoPacket * packet)
+{
+  GstBitReader br;
+  unsigned char  ExtensionCode;
+
+  gst_bit_reader_init (&br, &packet->data[packet->offset], packet->size);
+  READ_UINT8 (&br,  ExtensionCode, 4);
+
+  return ExtensionCode;
+
+failed:
+  {
+    GST_WARNING ("Failed to get extension code");
+    return 0;
+  }
+}
+
+/**
+ * gst_mpeg_video_parse:
+ * @packet: a #GstMpegVideoPacket to fill with the data and offset of the
+ *     next packet found
+ * @data: The data to parse
+ * @size: The size of @data
+ * @offset: The offset from which to start parsing
+ *
+ * Parses the MPEG 1/2 video bitstream contained in @data, and returns the
+ * offset, and if known also the size, in @packet. This function will scan
+ * the data to find the next packet if needed.
+ *
+ * Returns: TRUE if a packet start code was found, otherwise FALSE.
+ */
+gboolean
+gst_mpeg_video_parse (GstMpegVideoPacket * packet,
+    const guint8 * data, gsize size, guint offset)
+{
+  gint off;
+  GstByteReader br;
+
+  INITIALIZE_DEBUG_CATEGORY;
+
+  if (size <= offset) {
+    GST_DEBUG ("Can't parse from offset %d, buffer is to small", offset);
+    return FALSE;
+  }
+
+  size -= offset;
+  gst_byte_reader_init (&br, &data[offset], size);
+
+  off = scan_for_start_codes (&br, 0, size);
+
+  if (off < 0) {
+    GST_DEBUG ("No start code prefix in this buffer");
+    return FALSE;
+  }
+
+  if (gst_byte_reader_skip (&br, off + 3) == FALSE)
+    goto failed;
+
+  if (gst_byte_reader_get_uint8 (&br, &packet->type) == FALSE)
+    goto failed;
+
+  packet->data = data;
+  packet->offset = offset + off + 4;
+  packet->size = -1;
+
+  /* try to find end of packet */
+  size -= off + 4;
+  off = scan_for_start_codes (&br, 0, size);
+
+  if (off > 0)
+    packet->size = off;
+
+  return TRUE;
+
+failed:
+  {
+    GST_WARNING ("Failed to parse");
+    return FALSE;
+  }
+}
+
+/**
+ * gst_mpeg_video_packet_parse_sequence_header:
+ * @packet: The #GstMpegVideoPacket that carries the data
+ * @seqhdr: (out): The #GstMpegVideoSequenceHdr structure to fill
+ *
+ * Parses the @seqhdr MPEG Video Sequence Header structure members
+ * from video @packet
+ *
+ * Returns: %TRUE if the seqhdr could be parsed correctly, %FALSE otherwise.
+ *
+ * Since: 1.2
+ */
+gboolean
+gst_mpeg_video_packet_parse_sequence_header (const GstMpegVideoPacket * packet,
+    GstMpegVideoSequenceHdr * seqhdr)
+{
+  GstBitReader br;
+  guint8 bits;
+
+  g_return_val_if_fail (seqhdr != NULL, FALSE);
+
+  if (packet->size < 8)
+    return FALSE;
+
+  INITIALIZE_DEBUG_CATEGORY;
+
+  gst_bit_reader_init (&br, &packet->data[packet->offset], packet->size);
+
+  /* Setting the height/width codes */
+  READ_UINT16 (&br, seqhdr->width, 12);
+  READ_UINT16 (&br, seqhdr->height, 12);
+
+  READ_UINT8 (&br, seqhdr->aspect_ratio_info, 4);
+  /* Interpret PAR according to MPEG-1. Needs to be reinterpreted
+   * later, if a sequence_display extension is seen */
+  set_par_from_asr_mpeg1 (seqhdr, seqhdr->aspect_ratio_info);
+
+  READ_UINT8 (&br, seqhdr->frame_rate_code, 4);
+  set_fps_from_code (seqhdr, seqhdr->frame_rate_code);
+
+  READ_UINT32 (&br, seqhdr->bitrate_value, 18);
+  if (seqhdr->bitrate_value == 0x3ffff) {
+    /* VBR stream */
+    seqhdr->bitrate = 0;
+  } else {
+    /* Value in header is in units of 400 bps */
+    seqhdr->bitrate = seqhdr->bitrate_value * 400;
+  }
+
+  READ_UINT8 (&br, bits, 1);
+  if (bits != MARKER_BIT)
+    goto failed;
+
+  /* VBV buffer size */
+  READ_UINT16 (&br, seqhdr->vbv_buffer_size_value, 10);
+
+  /* constrained_parameters_flag */
+  READ_UINT8 (&br, seqhdr->constrained_parameters_flag, 1);
+
+  /* load_intra_quantiser_matrix */
+  READ_UINT8 (&br, seqhdr->load_intra_quantiser_matrix, 1);
+  if (seqhdr->load_intra_quantiser_matrix) {
+    gint i;
+    for (i = 0; i < 64; i++)
+      READ_UINT8 (&br, seqhdr->intra_quantizer_matrix[i], 8);
+  } else
+    memcpy (seqhdr->intra_quantizer_matrix, default_intra_quantizer_matrix, 64);
+
+  /* non intra quantizer matrix */
+  READ_UINT8 (&br, seqhdr->load_non_intra_quantiser_matrix, 1);
+  if (seqhdr->load_non_intra_quantiser_matrix) {
+    gint i;
+    for (i = 0; i < 64; i++)
+      READ_UINT8 (&br, seqhdr->non_intra_quantizer_matrix[i], 8);
+  } else
+    memset (seqhdr->non_intra_quantizer_matrix, 16, 64);
+
+  /* dump some info */
+  GST_LOG ("width x height: %d x %d", seqhdr->width, seqhdr->height);
+  GST_LOG ("fps: %d/%d", seqhdr->fps_n, seqhdr->fps_d);
+  GST_LOG ("par: %d/%d", seqhdr->par_w, seqhdr->par_h);
+  GST_LOG ("bitrate: %d", seqhdr->bitrate);
+
+  return TRUE;
+
+  /* ERRORS */
+failed:
+  {
+    GST_WARNING ("Failed to parse sequence header");
+    /* clear out stuff */
+    memset (seqhdr, 0, sizeof (*seqhdr));
+    return FALSE;
+  }
+}
+
+/**
+ * gst_mpeg_video_packet_parse_sequence_extension:
+ * @packet: The #GstMpegVideoPacket that carries the data
+ * @seqext: (out): The #GstMpegVideoSequenceExt structure to fill
+ *
+ * Parses the @seqext MPEG Video Sequence Extension structure members
+ * from video @packet
+ *
+ * Returns: %TRUE if the seqext could be parsed correctly, %FALSE otherwise.
+ *
+ * Since: 1.2
+ */
+gboolean
+gst_mpeg_video_packet_parse_sequence_extension (const GstMpegVideoPacket *
+    packet, GstMpegVideoSequenceExt * seqext)
+{
+  GstBitReader br;
+
+  g_return_val_if_fail (seqext != NULL, FALSE);
+
+  if (packet->size < 6) {
+    GST_DEBUG ("not enough bytes to parse the extension");
+    return FALSE;
+  }
+
+  gst_bit_reader_init (&br, &packet->data[packet->offset], packet->size);
+
+  if (gst_bit_reader_get_bits_uint8_unchecked (&br, 4) !=
+      GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE) {
+    GST_DEBUG ("Not parsing a sequence extension");
+    return FALSE;
+  }
+
+  /* skip profile and level escape bit */
+  seqext->profile_level_escape_bit =
+      gst_bit_reader_get_bits_uint8_unchecked (&br, 1);
+
+  seqext->profile = gst_bit_reader_get_bits_uint8_unchecked (&br, 3);
+  seqext->level = gst_bit_reader_get_bits_uint8_unchecked (&br, 4);
+
+  /* progressive */
+  seqext->progressive = gst_bit_reader_get_bits_uint8_unchecked (&br, 1);
+
+  /* chroma format */
+  seqext->chroma_format = gst_bit_reader_get_bits_uint8_unchecked (&br, 2);
+
+  /* resolution extension */
+  seqext->horiz_size_ext = gst_bit_reader_get_bits_uint8_unchecked (&br, 2);
+  seqext->vert_size_ext = gst_bit_reader_get_bits_uint8_unchecked (&br, 2);
+
+  seqext->bitrate_ext = gst_bit_reader_get_bits_uint16_unchecked (&br, 12);
+
+  /* skip marker bits */
+  gst_bit_reader_skip_unchecked (&br, 1);
+
+  seqext->vbv_buffer_size_extension =
+      gst_bit_reader_get_bits_uint8_unchecked (&br, 8);
+  seqext->low_delay = gst_bit_reader_get_bits_uint8_unchecked (&br, 1);
+
+  /* framerate extension */
+  seqext->fps_n_ext = gst_bit_reader_get_bits_uint8_unchecked (&br, 2);
+  seqext->fps_d_ext = gst_bit_reader_get_bits_uint8_unchecked (&br, 2);
+
+  return TRUE;
+}
+
+/**
+ * gst_mpeg_video_packet_parse_sequence_display_extension:
+ * @packet: The #GstMpegVideoPacket that carries the data
+ * @seqdisplayext: (out): The #GstMpegVideoSequenceDisplayExt
+ *   structure to fill
+ *
+ * Parses the @seqext MPEG Video Sequence Display Extension structure
+ * members from video @packet
+ *
+ * Returns: %TRUE if the seqext could be parsed correctly, %FALSE otherwise.
+ *
+ * Since: 1.2
+ */
+gboolean
+gst_mpeg_video_packet_parse_sequence_display_extension (const GstMpegVideoPacket
+    * packet, GstMpegVideoSequenceDisplayExt * seqdisplayext)
+{
+  GstBitReader br;
+
+  g_return_val_if_fail (seqdisplayext != NULL, FALSE);
+
+  if (packet->size < 5) {
+    GST_DEBUG ("not enough bytes to parse the extension");
+    return FALSE;
+  }
+
+  gst_bit_reader_init (&br, &packet->data[packet->offset], packet->size);
+
+  if (gst_bit_reader_get_bits_uint8_unchecked (&br, 4) !=
+      GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE_DISPLAY) {
+    GST_DEBUG ("Not parsing a sequence display extension");
+    return FALSE;
+  }
+
+  seqdisplayext->video_format =
+      gst_bit_reader_get_bits_uint8_unchecked (&br, 3);
+  seqdisplayext->colour_description_flag =
+      gst_bit_reader_get_bits_uint8_unchecked (&br, 1);
+
+  if (seqdisplayext->colour_description_flag) {
+    seqdisplayext->colour_primaries =
+        gst_bit_reader_get_bits_uint8_unchecked (&br, 8);
+    seqdisplayext->transfer_characteristics =
+        gst_bit_reader_get_bits_uint8_unchecked (&br, 8);
+    seqdisplayext->matrix_coefficients =
+        gst_bit_reader_get_bits_uint8_unchecked (&br, 8);
+  }
+
+  if (gst_bit_reader_get_remaining (&br) < 29) {
+    GST_DEBUG ("Not enough remaining bytes to parse the extension");
+    return FALSE;
+  }
+
+  seqdisplayext->display_horizontal_size =
+      gst_bit_reader_get_bits_uint16_unchecked (&br, 14);
+  /* skip marker bit */
+  gst_bit_reader_skip_unchecked (&br, 1);
+  seqdisplayext->display_vertical_size =
+      gst_bit_reader_get_bits_uint16_unchecked (&br, 14);
+
+  return TRUE;
+}
+
+/**
+ * gst_mpeg_video_packet_parse_sequence_scalable_extension:
+ * @packet: The #GstMpegVideoPacket that carries the data
+ * @seqscaleext: (out): The #GstMpegVideoSequenceScalableExt structure to fill
+ *
+ * Parses the @seqscaleext MPEG Video Sequence Scalable Extension structure
+ * members from video @packet
+ *
+ * Returns: %TRUE if the seqext could be parsed correctly, %FALSE otherwise.
+ *
+ * Since: 1.2
+ */
+gboolean
+    gst_mpeg_video_packet_parse_sequence_scalable_extension
+    (const GstMpegVideoPacket * packet,
+    GstMpegVideoSequenceScalableExt * seqscaleext) {
+  GstBitReader br;
+
+  g_return_val_if_fail (seqscaleext != NULL, FALSE);
+
+  if (packet->size < 2) {
+    GST_DEBUG ("not enough bytes to parse the extension");
+    return FALSE;
+  }
+
+  gst_bit_reader_init (&br, &packet->data[packet->offset], packet->size);
+
+  if (gst_bit_reader_get_bits_uint8_unchecked (&br, 4) !=
+      GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE_SCALABLE) {
+    GST_DEBUG ("Not parsing a sequence scalable extension");
+    return FALSE;
+  }
+
+  READ_UINT8 (&br, seqscaleext->scalable_mode, 2);
+  READ_UINT8 (&br, seqscaleext->layer_id, 4);
+
+  if (seqscaleext->scalable_mode == GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_SPATIAL) {
+    READ_UINT16 (&br, seqscaleext->lower_layer_prediction_horizontal_size, 14);
+
+    SKIP (&br, 1);
+
+    READ_UINT16 (&br, seqscaleext->lower_layer_prediction_vertical_size, 14);
+
+    READ_UINT8 (&br, seqscaleext->horizontal_subsampling_factor_m, 5);
+    READ_UINT8 (&br, seqscaleext->horizontal_subsampling_factor_n, 5);
+    READ_UINT8 (&br, seqscaleext->vertical_subsampling_factor_m, 5);
+    READ_UINT8 (&br, seqscaleext->vertical_subsampling_factor_n, 5);
+  }
+
+  if (seqscaleext->scalable_mode == GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_TEMPORAL) {
+    READ_UINT8 (&br, seqscaleext->picture_mux_enable, 1);
+    if (seqscaleext->picture_mux_enable)
+      READ_UINT8 (&br, seqscaleext->mux_to_progressive_sequence, 1);
+    READ_UINT8 (&br, seqscaleext->picture_mux_order, 3);
+    READ_UINT8 (&br, seqscaleext->picture_mux_factor, 3);
+  }
+
+  return TRUE;
+
+failed:
+  GST_WARNING ("error parsing \"Sequence Scalable Extension\"");
+  return FALSE;
+}
+
+gboolean
+gst_mpeg_video_finalise_mpeg2_sequence_header (GstMpegVideoSequenceHdr * seqhdr,
+    GstMpegVideoSequenceExt * seqext,
+    GstMpegVideoSequenceDisplayExt * displayext)
+{
+  guint32 w;
+  guint32 h;
+
+  if (seqext) {
+    seqhdr->fps_n = seqhdr->fps_n * (seqext->fps_n_ext + 1);
+    seqhdr->fps_d = seqhdr->fps_d * (seqext->fps_d_ext + 1);
+    /* Extend width and height to 14 bits by adding the extension bits */
+    seqhdr->width |= (seqext->horiz_size_ext << 12);
+    seqhdr->height |= (seqext->vert_size_ext << 12);
+    seqhdr->bitrate += (seqext->bitrate_ext << 18) * 400;
+  }
+
+  w = seqhdr->width;
+  h = seqhdr->height;
+  if (displayext) {
+    /* Use the display size for calculating PAR when display ext present.
+     * But we are handling this like what DVD players are doing. Which means,
+     * ignore the display extension values if they are greater than the width/height
+     * values provided by seqhdr and calculate the PAR based on the seqhdr values. */
+    if (displayext->display_horizontal_size < w)
+      w = displayext->display_horizontal_size;
+    if (displayext->display_vertical_size < h)
+      h = displayext->display_vertical_size;
+  }
+
+  /* Pixel_width = DAR_width * display_vertical_size */
+  /* Pixel_height = DAR_height * display_horizontal_size */
+  switch (seqhdr->aspect_ratio_info) {
+    case 0x01:                 /* Square pixels */
+      seqhdr->par_w = seqhdr->par_h = 1;
+      break;
+    case 0x02:                 /* 3:4 DAR = 4:3 pixels */
+      seqhdr->par_w = 4 * h;
+      seqhdr->par_h = 3 * w;
+      break;
+    case 0x03:                 /* 9:16 DAR */
+      seqhdr->par_w = 16 * h;
+      seqhdr->par_h = 9 * w;
+      break;
+    case 0x04:                 /* 1:2.21 DAR */
+      seqhdr->par_w = 221 * h;
+      seqhdr->par_h = 100 * w;
+      break;
+    default:
+      GST_DEBUG ("unknown/invalid aspect_ratio_information %d",
+          seqhdr->aspect_ratio_info);
+      break;
+  }
+
+  return TRUE;
+}
+
+/**
+ * gst_mpeg_video_packet_parse_quant_matrix_extension:
+ * @packet: The #GstMpegVideoPacket that carries the data
+ * @quant: (out): The #GstMpegVideoQuantMatrixExt structure to fill
+ *
+ * Parses the @quant MPEG Video Quantization Matrix Extension
+ * structure members from video @packet
+ *
+ * Returns: %TRUE if the quant matrix extension could be parsed correctly,
+ * %FALSE otherwise.
+ *
+ * Since: 1.2
+ */
+gboolean
+gst_mpeg_video_packet_parse_quant_matrix_extension (const GstMpegVideoPacket *
+    packet, GstMpegVideoQuantMatrixExt * quant)
+{
+  guint8 i;
+  GstBitReader br;
+
+  g_return_val_if_fail (quant != NULL, FALSE);
+
+  if (packet->size < 1) {
+    GST_DEBUG ("not enough bytes to parse the extension");
+    return FALSE;
+  }
+
+  gst_bit_reader_init (&br, &packet->data[packet->offset], packet->size);
+
+  if (gst_bit_reader_get_bits_uint8_unchecked (&br, 4) !=
+      GST_MPEG_VIDEO_PACKET_EXT_QUANT_MATRIX) {
+    GST_DEBUG ("Not parsing a quant matrix extension");
+    return FALSE;
+  }
+
+  READ_UINT8 (&br, quant->load_intra_quantiser_matrix, 1);
+  if (quant->load_intra_quantiser_matrix) {
+    for (i = 0; i < 64; i++) {
+      READ_UINT8 (&br, quant->intra_quantiser_matrix[i], 8);
+    }
+  }
+
+  READ_UINT8 (&br, quant->load_non_intra_quantiser_matrix, 1);
+  if (quant->load_non_intra_quantiser_matrix) {
+    for (i = 0; i < 64; i++) {
+      READ_UINT8 (&br, quant->non_intra_quantiser_matrix[i], 8);
+    }
+  }
+
+  READ_UINT8 (&br, quant->load_chroma_intra_quantiser_matrix, 1);
+  if (quant->load_chroma_intra_quantiser_matrix) {
+    for (i = 0; i < 64; i++) {
+      READ_UINT8 (&br, quant->chroma_intra_quantiser_matrix[i], 8);
+    }
+  }
+
+  READ_UINT8 (&br, quant->load_chroma_non_intra_quantiser_matrix, 1);
+  if (quant->load_chroma_non_intra_quantiser_matrix) {
+    for (i = 0; i < 64; i++) {
+      READ_UINT8 (&br, quant->chroma_non_intra_quantiser_matrix[i], 8);
+    }
+  }
+
+  return TRUE;
+
+failed:
+  GST_WARNING ("error parsing \"Quant Matrix Extension\"");
+  return FALSE;
+}
+
+/**
+ * gst_mpeg_video_packet_parse_picture_extension:
+ * @packet: The #GstMpegVideoPacket that carries the data
+ * @ext: (out): The #GstMpegVideoPictureExt structure to fill
+ *
+ * Parse the @ext MPEG Video Picture Extension structure members from
+ * video @packet
+ *
+ * Returns: %TRUE if the picture extension could be parsed correctly,
+ * %FALSE otherwise.
+ *
+ * Since: 1.2
+ */
+gboolean
+gst_mpeg_video_packet_parse_picture_extension (const GstMpegVideoPacket *
+    packet, GstMpegVideoPictureExt * ext)
+{
+  GstBitReader br;
+
+  g_return_val_if_fail (ext != NULL, FALSE);
+
+  if (packet->size < 5)
+    return FALSE;
+
+  gst_bit_reader_init (&br, &packet->data[packet->offset], packet->size);
+
+  if (gst_bit_reader_get_bits_uint8_unchecked (&br, 4) !=
+      GST_MPEG_VIDEO_PACKET_EXT_PICTURE) {
+    GST_DEBUG ("Extension is not a picture extension");
+    return FALSE;
+  }
+
+  /* f_code */
+  READ_UINT8 (&br, ext->f_code[0][0], 4);
+  READ_UINT8 (&br, ext->f_code[0][1], 4);
+  READ_UINT8 (&br, ext->f_code[1][0], 4);
+  READ_UINT8 (&br, ext->f_code[1][1], 4);
+
+  /* intra DC precision */
+  READ_UINT8 (&br, ext->intra_dc_precision, 2);
+
+  /* picture structure */
+  READ_UINT8 (&br, ext->picture_structure, 2);
+
+  /* top field first */
+  READ_UINT8 (&br, ext->top_field_first, 1);
+
+  /* frame pred frame dct */
+  READ_UINT8 (&br, ext->frame_pred_frame_dct, 1);
+
+  /* concealment motion vectors */
+  READ_UINT8 (&br, ext->concealment_motion_vectors, 1);
+
+  /* q scale type */
+  READ_UINT8 (&br, ext->q_scale_type, 1);
+
+  /* intra vlc format */
+  READ_UINT8 (&br, ext->intra_vlc_format, 1);
+
+  /* alternate scan */
+  READ_UINT8 (&br, ext->alternate_scan, 1);
+
+  /* repeat first field */
+  READ_UINT8 (&br, ext->repeat_first_field, 1);
+
+  /* chroma_420_type */
+  READ_UINT8 (&br, ext->chroma_420_type, 1);
+
+  /* progressive_frame */
+  READ_UINT8 (&br, ext->progressive_frame, 1);
+
+  /* composite display */
+  READ_UINT8 (&br, ext->composite_display, 1);
+
+  if (ext->composite_display) {
+
+    /* v axis */
+    READ_UINT8 (&br, ext->v_axis, 1);
+
+    /* field sequence */
+    READ_UINT8 (&br, ext->field_sequence, 3);
+
+    /* sub carrier */
+    READ_UINT8 (&br, ext->sub_carrier, 1);
+
+    /* burst amplitude */
+    READ_UINT8 (&br, ext->burst_amplitude, 7);
+
+    /* sub_carrier phase */
+    READ_UINT8 (&br, ext->sub_carrier_phase, 8);
+  }
+
+  return TRUE;
+
+failed:
+  GST_WARNING ("error parsing \"Picture Coding Extension\"");
+  return FALSE;
+
+}
+
+/**
+ * gst_mpeg_video_packet_parse_picture_header:
+ * @packet: The #GstMpegVideoPacket that carries the data
+ * @pichdr: (out): The #GstMpegVideoPictureHdr structure to fill
+ *
+ * Parsers the @pichdr MPEG Video Picture Header structure members
+ * from video @packet
+ *
+ * Returns: %TRUE if the picture sequence could be parsed correctly, %FALSE
+ * otherwise.
+ *
+ * Since: 1.2
+ */
+gboolean
+gst_mpeg_video_packet_parse_picture_header (const GstMpegVideoPacket * packet,
+    GstMpegVideoPictureHdr * hdr)
+{
+  GstBitReader br;
+
+  if (packet->size < 4)
+    goto failed;
+
+  gst_bit_reader_init (&br, &packet->data[packet->offset], packet->size);
+
+  /* temperal sequence number */
+  if (!gst_bit_reader_get_bits_uint16 (&br, &hdr->tsn, 10))
+    goto failed;
+
+
+  /* frame type */
+  if (!gst_bit_reader_get_bits_uint8 (&br, (guint8 *) & hdr->pic_type, 3))
+    goto failed;
+
+
+  if (hdr->pic_type == 0 || hdr->pic_type > 4)
+    goto bad_pic_type;          /* Corrupted picture packet */
+
+  /* VBV delay */
+  if (!gst_bit_reader_get_bits_uint16 (&br, &hdr->vbv_delay, 16))
+    goto failed;
+
+  if (hdr->pic_type == GST_MPEG_VIDEO_PICTURE_TYPE_P
+      || hdr->pic_type == GST_MPEG_VIDEO_PICTURE_TYPE_B) {
+
+    READ_UINT8 (&br, hdr->full_pel_forward_vector, 1);
+
+    READ_UINT8 (&br, hdr->f_code[0][0], 3);
+    hdr->f_code[0][1] = hdr->f_code[0][0];
+  } else {
+    hdr->full_pel_forward_vector = 0;
+    hdr->f_code[0][0] = hdr->f_code[0][1] = 0;
+  }
+
+  if (hdr->pic_type == GST_MPEG_VIDEO_PICTURE_TYPE_B) {
+    READ_UINT8 (&br, hdr->full_pel_backward_vector, 1);
+
+    READ_UINT8 (&br, hdr->f_code[1][0], 3);
+    hdr->f_code[1][1] = hdr->f_code[1][0];
+  } else {
+    hdr->full_pel_backward_vector = 0;
+    hdr->f_code[1][0] = hdr->f_code[1][1] = 0;
+  }
+
+  return TRUE;
+
+bad_pic_type:
+  {
+    GST_WARNING ("Unsupported picture type : %d", hdr->pic_type);
+    return FALSE;
+  }
+
+failed:
+  {
+    GST_WARNING ("Not enough data to parse picture header");
+    return FALSE;
+  }
+}
+
+/**
+ * gst_mpeg_video_packet_parse_gop:
+ * @packet: The #GstMpegVideoPacket that carries the data
+ * @gop: (out): The #GstMpegVideoGop structure to fill
+ *
+ * Parses the @gop MPEG Video Group of Picture structure members from
+ * video @packet
+ *
+ * Returns: %TRUE if the gop could be parsed correctly, %FALSE otherwise.
+ *
+ * Since: 1.2
+ */
+gboolean
+gst_mpeg_video_packet_parse_gop (const GstMpegVideoPacket * packet,
+    GstMpegVideoGop * gop)
+{
+  GstBitReader br;
+
+  g_return_val_if_fail (gop != NULL, FALSE);
+
+  if (packet->size < 4)
+    return FALSE;
+
+  gst_bit_reader_init (&br, &packet->data[packet->offset], packet->size);
+
+  READ_UINT8 (&br, gop->drop_frame_flag, 1);
+
+  READ_UINT8 (&br, gop->hour, 5);
+
+  READ_UINT8 (&br, gop->minute, 6);
+
+  /* skip unused bit */
+  if (!gst_bit_reader_skip (&br, 1))
+    return FALSE;
+
+  READ_UINT8 (&br, gop->second, 6);
+
+  READ_UINT8 (&br, gop->frame, 6);
+
+  READ_UINT8 (&br, gop->closed_gop, 1);
+
+  READ_UINT8 (&br, gop->broken_link, 1);
+
+  return TRUE;
+
+failed:
+  GST_WARNING ("error parsing \"GOP\"");
+  return FALSE;
+}
+
+/**
+ * gst_mpeg_video_packet_parse_slice_header:
+ * @packet: The #GstMpegVideoPacket that carries the data
+ * @slice_hdr: (out): The #GstMpegVideoSliceHdr structure to fill
+ * @seqhdr: The #GstMpegVideoSequenceHdr header
+ * @seqscaleext: The #GstMpegVideoSequenceScalableExt header
+ *
+ * Parses the @GstMpegVideoSliceHdr  structure members from @data
+ *
+ * Returns: %TRUE if the slice could be parsed correctly, %FALSE otherwise.
+ *
+ * Since: 1.2
+ */
+gboolean
+gst_mpeg_video_packet_parse_slice_header (const GstMpegVideoPacket * packet,
+    GstMpegVideoSliceHdr * slice_hdr, GstMpegVideoSequenceHdr * seqhdr,
+    GstMpegVideoSequenceScalableExt * seqscaleext)
+{
+  GstBitReader br;
+  guint height;
+  guint mb_inc;
+  guint8 bits, extra_bits;
+  guint8 vertical_position, vertical_position_extension = 0;
+
+  g_return_val_if_fail (seqhdr != NULL, FALSE);
+
+  if (packet->size < 1)
+    return FALSE;
+
+  gst_bit_reader_init (&br, &packet->data[packet->offset], packet->size);
+
+  if (packet->type < GST_MPEG_VIDEO_PACKET_SLICE_MIN ||
+      packet->type > GST_MPEG_VIDEO_PACKET_SLICE_MAX) {
+    GST_DEBUG ("Not parsing a slice");
+    return FALSE;
+  }
+  vertical_position = packet->type - GST_MPEG_VIDEO_PACKET_SLICE_MIN;
+
+  height = seqhdr->height;
+  if (height > 2800)
+    READ_UINT8 (&br, vertical_position_extension, 3);
+
+  slice_hdr->vertical_position = packet->type;
+  slice_hdr->vertical_position_ext = vertical_position_extension;
+
+  if (seqscaleext)
+    if (seqscaleext->scalable_mode ==
+        GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_DATA_PARTITIONING)
+      READ_UINT8 (&br, slice_hdr->priority_breakpoint, 7);
+
+  READ_UINT8 (&br, slice_hdr->quantiser_scale_code, 5);
+
+  READ_UINT8 (&br, slice_hdr->slice_ext_flag, 1);
+  if (!slice_hdr->slice_ext_flag)
+    slice_hdr->intra_slice = 0;
+  else {
+    READ_UINT8 (&br, slice_hdr->intra_slice, 1);
+    READ_UINT8 (&br, slice_hdr->slice_picture_id_enable, 1);
+    READ_UINT8 (&br, slice_hdr->slice_picture_id, 6);
+
+    READ_UINT8 (&br, bits, 1);
+    while (bits) {
+      READ_UINT8 (&br, extra_bits, 8);
+      READ_UINT8 (&br, bits, 1);
+    }
+  }
+
+  slice_hdr->header_size = gst_bit_reader_get_pos (&br);
+
+  if (height > 2800)
+    slice_hdr->mb_row = (vertical_position_extension << 7) + vertical_position;
+  else
+    slice_hdr->mb_row = vertical_position;
+
+  slice_hdr->mb_column = -1;
+  do {
+    if (!decode_vlc (&br, &mb_inc, mpeg2_mbaddr_vlc_table,
+            G_N_ELEMENTS (mpeg2_mbaddr_vlc_table))) {
+      GST_WARNING ("failed to decode first macroblock_address_increment");
+      goto failed;
+    }
+    slice_hdr->mb_column +=
+        mb_inc == GST_MPEG_VIDEO_MACROBLOCK_ESCAPE ? 33 : mb_inc;
+  } while (mb_inc == GST_MPEG_VIDEO_MACROBLOCK_ESCAPE);
+
+  return TRUE;
+
+failed:
+  GST_WARNING ("error parsing \"Slice\"");
+  return FALSE;
+}
+
+/**
+ * gst_mpeg_video_quant_matrix_get_raster_from_zigzag:
+ * @out_quant: (out): The resulting quantization matrix
+ * @quant: The source quantization matrix
+ *
+ * Converts quantization matrix @quant from zigzag scan order to
+ * raster scan order and store the resulting factors into @out_quant.
+ *
+ * Note: it is an error to pass the same table in both @quant and
+ * @out_quant arguments.
+ *
+ * Since: 1.2
+ */
+void
+gst_mpeg_video_quant_matrix_get_raster_from_zigzag (guint8 out_quant[64],
+    const guint8 quant[64])
+{
+  guint i;
+
+  g_return_if_fail (out_quant != quant);
+
+  for (i = 0; i < 64; i++)
+    out_quant[mpeg_zigzag_8x8[i]] = quant[i];
+}
+
+/**
+ * gst_mpeg_video_quant_matrix_get_zigzag_from_raster:
+ * @out_quant: (out): The resulting quantization matrix
+ * @quant: The source quantization matrix
+ *
+ * Converts quantization matrix @quant from raster scan order to
+ * zigzag scan order and store the resulting factors into @out_quant.
+ *
+ * Note: it is an error to pass the same table in both @quant and
+ * @out_quant arguments.
+ *
+ * Since: 1.2
+ */
+void
+gst_mpeg_video_quant_matrix_get_zigzag_from_raster (guint8 out_quant[64],
+    const guint8 quant[64])
+{
+  guint i;
+
+  g_return_if_fail (out_quant != quant);
+
+  for (i = 0; i < 64; i++)
+    out_quant[i] = quant[mpeg_zigzag_8x8[i]];
+}
+
+/****** Deprecated API *******/
+
+/**
+ * gst_mpeg_video_parse_sequence_header:
+ * @seqhdr: (out): The #GstMpegVideoSequenceHdr structure to fill
+ * @data: The data from which to parse the sequence header
+ * @size: The size of @data
+ * @offset: The offset in byte from which to start parsing @data
+ *
+ * Parses the @seqhdr Mpeg Video Sequence Header structure members from @data
+ *
+ * Returns: %TRUE if the seqhdr could be parsed correctly, %FALSE otherwise.
+ *
+ * Deprecated: Use gst_mpeg_video_packet_parse_sequence_header() instead.
+ */
+#ifndef GST_REMOVE_DEPRECATED
+#ifdef GST_DISABLE_DEPRECATED
+gboolean
+gst_mpeg_video_parse_sequence_header (GstMpegVideoSequenceHdr * seqhdr,
+    const guint8 * data, gsize size, guint offset);
+#endif
+gboolean
+gst_mpeg_video_parse_sequence_header (GstMpegVideoSequenceHdr * seqhdr,
+    const guint8 * data, gsize size, guint offset)
+{
+  GstMpegVideoPacket packet;
+
+  packet.data = data;
+  packet.type = GST_MPEG_VIDEO_PACKET_SEQUENCE;
+  packet.offset = offset;
+  packet.size = size - offset;
+  return gst_mpeg_video_packet_parse_sequence_header (&packet, seqhdr);
+}
+#endif
+
+/**
+ * gst_mpeg_video_parse_sequence_extension:
+ * @seqext: (out): The #GstMpegVideoSequenceExt structure to fill
+ * @data: The data from which to parse the sequence extension
+ * @size: The size of @data
+ * @offset: The offset in byte from which to start parsing @data
+ *
+ * Parses the @seqext Mpeg Video Sequence Extension structure members from @data
+ *
+ * Returns: %TRUE if the seqext could be parsed correctly, %FALSE otherwise.
+ *
+ * Deprecated: Use gst_mpeg_video_packet_parse_sequence_extension() instead.
+ */
+#ifndef GST_REMOVE_DEPRECATED
+#ifdef GST_DISABLE_DEPRECATED
+gboolean
+gst_mpeg_video_parse_sequence_extension (GstMpegVideoSequenceExt * seqext,
+    const guint8 * data, gsize size, guint offset);
+#endif
+gboolean
+gst_mpeg_video_parse_sequence_extension (GstMpegVideoSequenceExt * seqext,
+    const guint8 * data, gsize size, guint offset)
+{
+  GstMpegVideoPacket packet;
+
+  packet.data = data;
+  packet.type = GST_MPEG_VIDEO_PACKET_EXTENSION;
+  packet.offset = offset;
+  packet.size = size - offset;
+  return gst_mpeg_video_packet_parse_sequence_extension (&packet, seqext);
+}
+#endif
+
+#ifndef GST_REMOVE_DEPRECATED
+#ifdef GST_DISABLE_DEPRECATED
+gboolean
+gst_mpeg_video_parse_sequence_display_extension (GstMpegVideoSequenceDisplayExt
+    * seqdisplayext, const guint8 * data, gsize size, guint offset);
+#endif
+gboolean
+gst_mpeg_video_parse_sequence_display_extension (GstMpegVideoSequenceDisplayExt
+    * seqdisplayext, const guint8 * data, gsize size, guint offset)
+{
+  GstMpegVideoPacket packet;
+
+  packet.data = data;
+  packet.type = GST_MPEG_VIDEO_PACKET_EXTENSION;
+  packet.offset = offset;
+  packet.size = size - offset;
+  return gst_mpeg_video_packet_parse_sequence_display_extension (&packet,
+      seqdisplayext);
+}
+#endif
+
+/**
+ * gst_mpeg_video_parse_quant_matrix_extension:
+ * @quant: (out): The #GstMpegVideoQuantMatrixExt structure to fill
+ * @data: The data from which to parse the Quantization Matrix extension
+ * @size: The size of @data
+ * @offset: The offset in byte from which to start the parsing
+ *
+ * Parses the @quant Mpeg Video Quant Matrix Extension structure members from
+ * @data
+ *
+ * Returns: %TRUE if the quant matrix extension could be parsed correctly,
+ * %FALSE otherwise.
+ *
+ * Deprecated: Use gst_mpeg_video_packet_parse_quant_matrix_extension() instead.
+ */
+#ifndef GST_REMOVE_DEPRECATED
+#ifdef GST_DISABLE_DEPRECATED
+gboolean
+gst_mpeg_video_parse_quant_matrix_extension (GstMpegVideoQuantMatrixExt * quant,
+    const guint8 * data, gsize size, guint offset);
+#endif
+gboolean
+gst_mpeg_video_parse_quant_matrix_extension (GstMpegVideoQuantMatrixExt * quant,
+    const guint8 * data, gsize size, guint offset)
+{
+  GstMpegVideoPacket packet;
+
+  packet.data = data;
+  packet.type = GST_MPEG_VIDEO_PACKET_EXTENSION;
+  packet.offset = offset;
+  packet.size = size - offset;
+  return gst_mpeg_video_packet_parse_quant_matrix_extension (&packet, quant);
+}
+#endif
+
+/**
+ * gst_mpeg_video_parse_picture_header:
+ * @hdr: (out): The #GstMpegVideoPictureHdr structure to fill
+ * @data: The data from which to parse the picture header
+ * @size: The size of @data
+ * @offset: The offset in byte from which to start the parsing
+ *
+ * Parsers the @hdr Mpeg Video Picture Header structure members from @data
+ *
+ * Returns: %TRUE if the picture sequence could be parsed correctly, %FALSE
+ * otherwise.
+ *
+ * Deprecated: Use gst_mpeg_video_packet_parse_picture_header() instead.
+ */
+#ifndef GST_REMOVE_DEPRECATED
+#ifdef GST_DISABLE_DEPRECATED
+gboolean
+gst_mpeg_video_parse_picture_header (GstMpegVideoPictureHdr * hdr,
+    const guint8 * data, gsize size, guint offset);
+#endif
+gboolean
+gst_mpeg_video_parse_picture_header (GstMpegVideoPictureHdr * hdr,
+    const guint8 * data, gsize size, guint offset)
+{
+  GstMpegVideoPacket packet;
+
+  packet.data = data;
+  packet.type = GST_MPEG_VIDEO_PACKET_PICTURE;
+  packet.offset = offset;
+  packet.size = size - offset;
+  return gst_mpeg_video_packet_parse_picture_header (&packet, hdr);
+}
+#endif
+
+/**
+ * gst_mpeg_video_parse_picture_extension:
+ * @ext: (out): The #GstMpegVideoPictureExt structure to fill
+ * @data: The data from which to parse the picture extension
+ * @size: The size of @data
+ * @offset: The offset in byte from which to start the parsing
+ *
+ * Parse the @ext Mpeg Video Picture Extension structure members from @data
+ *
+ * Returns: %TRUE if the picture extension could be parsed correctly,
+ * %FALSE otherwise.
+ *
+ * Deprecated: Use gst_mpeg_video_packet_parse_picture_extension() instead.
+ */
+#ifndef GST_REMOVE_DEPRECATED
+#ifdef GST_DISABLE_DEPRECATED
+gboolean
+gst_mpeg_video_parse_picture_extension (GstMpegVideoPictureExt * ext,
+    const guint8 * data, gsize size, guint offset);
+#endif
+gboolean
+gst_mpeg_video_parse_picture_extension (GstMpegVideoPictureExt * ext,
+    const guint8 * data, gsize size, guint offset)
+{
+  GstMpegVideoPacket packet;
+
+  packet.data = data;
+  packet.type = GST_MPEG_VIDEO_PACKET_EXTENSION;
+  packet.offset = offset;
+  packet.size = size - offset;
+  return gst_mpeg_video_packet_parse_picture_extension (&packet, ext);
+}
+#endif
+
+/**
+ * gst_mpeg_video_parse_gop:
+ * @gop: (out): The #GstMpegVideoGop structure to fill
+ * @data: The data from which to parse the gop
+ * @size: The size of @data
+ * @offset: The offset in byte from which to start the parsing
+ *
+ * Parses the @gop Mpeg Video Group of Picture structure members from @data
+ *
+ * Returns: %TRUE if the gop could be parsed correctly, %FALSE otherwise.
+ *
+ * Deprecated: Use gst_mpeg_video_packet_parse_gop() instead.
+ */
+#ifndef GST_REMOVE_DEPRECATED
+#ifdef GST_DISABLE_DEPRECATED
+gboolean
+gst_mpeg_video_parse_gop (GstMpegVideoGop * gop, const guint8 * data,
+    gsize size, guint offset);
+#endif
+gboolean
+gst_mpeg_video_parse_gop (GstMpegVideoGop * gop, const guint8 * data,
+    gsize size, guint offset)
+{
+  GstMpegVideoPacket packet;
+
+  packet.data = data;
+  packet.type = GST_MPEG_VIDEO_PACKET_GOP;
+  packet.offset = offset;
+  packet.size = size - offset;
+  return gst_mpeg_video_packet_parse_gop (&packet, gop);
+}
+#endif
diff --git a/lib/libv4l-codecparsers/codecparsers/gstmpegvideoparser.h b/lib/libv4l-codecparsers/codecparsers/gstmpegvideoparser.h
new file mode 100644
index 0000000..04e6e99
--- /dev/null
+++ b/lib/libv4l-codecparsers/codecparsers/gstmpegvideoparser.h
@@ -0,0 +1,574 @@
+/* Gstreamer
+ * Copyright (C) <2011> Intel Corporation
+ * Copyright (C) <2011> Collabora Ltd.
+ * Copyright (C) <2011> Thibault Saunier <thibault.saunier@collabora.com>
+ *
+ * From bad/sys/vdpau/mpeg/mpegutil.c:
+ *   Copyright (C) <2007> Jan Schmidt <thaytan@mad.scientist.com>
+ *   Copyright (C) <2009> Carl-Anton Ingmarsson <ca.ingmarsson@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_MPEG_VIDEO_UTILS_H__
+#define __GST_MPEG_VIDEO_UTILS_H__
+
+#ifndef GST_USE_UNSTABLE_API
+#warning "The Mpeg video parsing library is unstable API and may change in future."
+#warning "You can define GST_USE_UNSTABLE_API to avoid this warning."
+#endif
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GstMpegVideoPacketTypeCode:
+ * @GST_MPEG_VIDEO_PACKET_PICTURE: Picture packet starting code
+ * @GST_MPEG_VIDEO_PACKET_SLICE_MIN: Slice min packet starting code
+ * @GST_MPEG_VIDEO_PACKET_SLICE_MAX: Slice max packet starting code
+ * @GST_MPEG_VIDEO_PACKET_USER_DATA: User data packet starting code
+ * @GST_MPEG_VIDEO_PACKET_SEQUENCE : Sequence packet starting code
+ * @GST_MPEG_VIDEO_PACKET_EXTENSION: Extension packet starting code
+ * @GST_MPEG_VIDEO_PACKET_SEQUENCE_END: Sequence end packet code
+ * @GST_MPEG_VIDEO_PACKET_GOP: Group of Picture packet starting code
+ * @GST_MPEG_VIDEO_PACKET_NONE: None packet code
+ *
+ * Indicates the type of MPEG packet
+ */
+typedef enum {
+  GST_MPEG_VIDEO_PACKET_PICTURE      = 0x00,
+  GST_MPEG_VIDEO_PACKET_SLICE_MIN    = 0x01,
+  GST_MPEG_VIDEO_PACKET_SLICE_MAX    = 0xaf,
+  GST_MPEG_VIDEO_PACKET_USER_DATA    = 0xb2,
+  GST_MPEG_VIDEO_PACKET_SEQUENCE     = 0xb3,
+  GST_MPEG_VIDEO_PACKET_EXTENSION    = 0xb5,
+  GST_MPEG_VIDEO_PACKET_SEQUENCE_END = 0xb7,
+  GST_MPEG_VIDEO_PACKET_GOP          = 0xb8,
+  GST_MPEG_VIDEO_PACKET_NONE         = 0xff
+} GstMpegVideoPacketTypeCode;
+
+/**
+ * GST_MPEG_VIDEO_PACKET_IS_SLICE:
+ * @typecode: The MPEG video packet type code
+ *
+ * Checks whether a packet type code is a slice.
+ *
+ * Returns: %TRUE if the packet type code corresponds to a slice,
+ * else %FALSE.
+ */
+#define GST_MPEG_VIDEO_PACKET_IS_SLICE(typecode) ((typecode) >= GST_MPEG_VIDEO_PACKET_SLICE_MIN && \
+                                                  (typecode) <= GST_MPEG_VIDEO_PACKET_SLICE_MAX)
+
+/**
+ * GstMpegVideoPacketExtensionCode:
+ * @GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE: Sequence extension code
+ * @GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE_DISPLAY: Sequence Display extension code
+ * @GST_MPEG_VIDEO_PACKET_EXT_QUANT_MATRIX: Quantization Matrix extension code
+ * @GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE_SCALABLE: Sequence Scalable extension code
+ * @GST_MPEG_VIDEO_PACKET_EXT_PICTURE: Picture coding extension
+ *
+ * Indicates what type of packets are in this block, some are mutually
+ * exclusive though - ie, sequence packs are accumulated separately. GOP &
+ * Picture may occur together or separately.
+ */
+typedef enum {
+  GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE          = 0x01,
+  GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE_DISPLAY  = 0x02,
+  GST_MPEG_VIDEO_PACKET_EXT_QUANT_MATRIX      = 0x03,
+  GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE_SCALABLE = 0x05,
+  GST_MPEG_VIDEO_PACKET_EXT_PICTURE           = 0x08
+} GstMpegVideoPacketExtensionCode;
+
+/**
+ * GstMpegVideoSequenceScalableMode:
+ * @GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_DATA_PARTITIONING: Data partitioning
+ * @GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_SPATIAL: Spatial Scalability
+ * @GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_SNR: SNR Scalability
+ * @GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_TEMPORAL: Temporal Scalability
+ */
+typedef enum {
+  GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_DATA_PARTITIONING  = 0x00,
+  GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_SPATIAL            = 0x01,
+  GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_SNR                = 0x02,
+  GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_TEMPORAL           = 0x03
+} GstMpegVideoSequenceScalableMode;
+
+/**
+ * GstMpegVideoLevel:
+ * @GST_MPEG_VIDEO_LEVEL_LOW: Low level (LL)
+ * @GST_MPEG_VIDEO_LEVEL_MAIN: Main level (ML)
+ * @GST_MPEG_VIDEO_LEVEL_HIGH_1440: High 1440 level (H-14)
+ * @GST_MPEG_VIDEO_LEVEL_HIGH: High level (HL)
+ *
+ * Mpeg-2 Levels.
+ **/
+typedef enum {
+ GST_MPEG_VIDEO_LEVEL_HIGH      = 0x04,
+ GST_MPEG_VIDEO_LEVEL_HIGH_1440 = 0x06,
+ GST_MPEG_VIDEO_LEVEL_MAIN      = 0x08,
+ GST_MPEG_VIDEO_LEVEL_LOW       = 0x0a
+} GstMpegVideoLevel;
+
+/**
+ * GstMpegVideoProfile:
+ * @GST_MPEG_VIDEO_PROFILE_422: 4:2:2 profile (422)
+ * @GST_MPEG_VIDEO_PROFILE_HIGH: High profile (HP)
+ * @GST_MPEG_VIDEO_PROFILE_SPATIALLY_SCALABLE: Spatially Scalable profile (Spatial)
+ * @GST_MPEG_VIDEO_PROFILE_SNR_SCALABLE: SNR Scalable profile (SNR)
+ * @GST_MPEG_VIDEO_PROFILE_MAIN: Main profile (MP)
+ * @GST_MPEG_VIDEO_PROFILE_SIMPLE: Simple profile (SP)
+ *
+ * Mpeg-2 Profiles.
+ **/
+typedef enum {
+  GST_MPEG_VIDEO_PROFILE_422                 = 0x00,
+  GST_MPEG_VIDEO_PROFILE_HIGH                = 0x01,
+  GST_MPEG_VIDEO_PROFILE_SPATIALLY_SCALABLE  = 0x02,
+  GST_MPEG_VIDEO_PROFILE_SNR_SCALABLE        = 0x03,
+  GST_MPEG_VIDEO_PROFILE_MAIN                = 0x04,
+  GST_MPEG_VIDEO_PROFILE_SIMPLE              = 0x05
+} GstMpegVideoProfile;
+
+/**
+ * GstMpegVideoChromaFormat:
+ * @GST_MPEG_VIDEO_CHROMA_RES: Invalid (reserved for future use)
+ * @GST_MPEG_VIDEO_CHROMA_420: 4:2:0 subsampling
+ * @GST_MPEG_VIDEO_CHROMA_422: 4:2:2 subsampling
+ * @GST_MPEG_VIDEO_CHROMA_444: 4:4:4 (non-subsampled)
+ *
+ * Chroma subsampling type.
+ */
+typedef enum {
+  GST_MPEG_VIDEO_CHROMA_RES = 0x00,
+  GST_MPEG_VIDEO_CHROMA_420 = 0x01,
+  GST_MPEG_VIDEO_CHROMA_422 = 0x02,
+  GST_MPEG_VIDEO_CHROMA_444 = 0x03,
+} GstMpegVideoChromaFormat;
+
+/**
+ * GstMpegVideoPictureType:
+ * @GST_MPEG_VIDEO_PICTURE_TYPE_I: Intra-coded (I) frame
+ * @GST_MPEG_VIDEO_PICTURE_TYPE_P: Predictive-codec (P) frame
+ * @GST_MPEG_VIDEO_PICTURE_TYPE_B: Bidirectionally predictive-coded (B) frame
+ * @GST_MPEG_VIDEO_PICTURE_TYPE_D: D frame
+ *
+ * Picture type.
+ */
+typedef enum {
+  GST_MPEG_VIDEO_PICTURE_TYPE_I = 0x01,
+  GST_MPEG_VIDEO_PICTURE_TYPE_P = 0x02,
+  GST_MPEG_VIDEO_PICTURE_TYPE_B = 0x03,
+  GST_MPEG_VIDEO_PICTURE_TYPE_D = 0x04
+} GstMpegVideoPictureType;
+
+/**
+ * GstMpegVideoPictureStructure:
+ * @GST_MPEG_VIDEO_PICTURE_STRUCTURE_TOP_FIELD: Top field
+ * @GST_MPEG_VIDEO_PICTURE_STRUCTURE_BOTTOM_FIELD: Bottom field
+ * @GST_MPEG_VIDEO_PICTURE_STRUCTURE_FRAME: Frame picture
+ *
+ * Picture structure type.
+ */
+typedef enum {
+    GST_MPEG_VIDEO_PICTURE_STRUCTURE_TOP_FIELD    = 0x01,
+    GST_MPEG_VIDEO_PICTURE_STRUCTURE_BOTTOM_FIELD = 0x02,
+    GST_MPEG_VIDEO_PICTURE_STRUCTURE_FRAME        = 0x03
+} GstMpegVideoPictureStructure;
+
+typedef struct _GstMpegVideoSequenceHdr     GstMpegVideoSequenceHdr;
+typedef struct _GstMpegVideoSequenceExt     GstMpegVideoSequenceExt;
+typedef struct _GstMpegVideoSequenceDisplayExt GstMpegVideoSequenceDisplayExt;
+typedef struct _GstMpegVideoSequenceScalableExt GstMpegVideoSequenceScalableExt;
+typedef struct _GstMpegVideoPictureHdr      GstMpegVideoPictureHdr;
+typedef struct _GstMpegVideoGop             GstMpegVideoGop;
+typedef struct _GstMpegVideoPictureExt      GstMpegVideoPictureExt;
+typedef struct _GstMpegVideoQuantMatrixExt  GstMpegVideoQuantMatrixExt;
+typedef struct _GstMpegVideoSliceHdr        GstMpegVideoSliceHdr;
+typedef struct _GstMpegVideoPacket          GstMpegVideoPacket;
+
+/**
+ * GstMpegVideoSequenceHdr:
+ * @width: Width of each frame
+ * @height: Height of each frame
+ * @par_w: Calculated Pixel Aspect Ratio width
+ * @par_h: Calculated Pixel Aspect Ratio height
+ * @fps_n: Calculated Framrate nominator
+ * @fps_d: Calculated Framerate denominator
+ * @bitrate_value: Value of the bitrate as is in the stream (400bps unit)
+ * @bitrate: the real bitrate of the Mpeg video stream in bits per second, 0 if VBR stream
+ * @constrained_parameters_flag: %TRUE if this stream uses contrained parameters.
+ * @load_intra_quantiser_matrix: %TRUE indicates the presence of intra_quantiser_matrix
+ * @intra_quantizer_matrix: intra-quantization table, in zigzag scan order
+ * @load_non_intra_quantiser_matrix: %TRUE indicates the presence of non_intra_quantiser_matrix
+ * @non_intra_quantizer_matrix: non-intra quantization table, in zigzag scan order
+ *
+ * The Mpeg2 Video Sequence Header structure.
+ */
+struct _GstMpegVideoSequenceHdr
+{
+  guint16 width, height;
+  guint8  aspect_ratio_info;
+  guint8  frame_rate_code;
+  guint32 bitrate_value;
+  guint16 vbv_buffer_size_value;
+
+  guint8  constrained_parameters_flag;
+
+  guint8  load_intra_quantiser_matrix;
+  guint8  intra_quantizer_matrix[64];
+  guint8  load_non_intra_quantiser_matrix;
+  guint8  non_intra_quantizer_matrix[64];
+
+  /* Calculated values */
+  guint   par_w, par_h;
+  guint   fps_n, fps_d;
+  guint   bitrate;
+};
+
+/**
+ * GstMpegVideoSequenceExt:
+ * @profile: mpeg2 decoder profile
+ * @level: mpeg2 decoder level
+ * @progressive: %TRUE if the frames are progressive %FALSE otherwise
+ * @chroma_format: indicates the chrominance format
+ * @horiz_size_ext: Horizontal size
+ * @vert_size_ext: Vertical size
+ * @bitrate_ext: The bitrate
+ * @vbv_buffer_size_extension: VBV vuffer size
+ * @low_delay: %TRUE if the sequence doesn't contain any B-pictures, %FALSE
+ * otherwise
+ * @fps_n_ext: Framerate nominator code
+ * @fps_d_ext: Framerate denominator code
+ * @profile_level_escape_bit: Escape bit. If set, the meaning of the
+ *    @profile and @level fields is different.
+ *
+ * The Mpeg2 Video Sequence Extension structure.
+ **/
+struct _GstMpegVideoSequenceExt
+{
+  /* mpeg2 decoder profile */
+  guint8 profile;
+  /* mpeg2 decoder level */
+  guint8 level;
+
+  guint8 progressive;
+  guint8 chroma_format;
+
+  guint8 horiz_size_ext, vert_size_ext;
+
+  guint16 bitrate_ext;
+  guint8 vbv_buffer_size_extension;
+  guint8 low_delay;
+  guint8 fps_n_ext, fps_d_ext;
+
+  /* Additional information */
+  guint8 profile_level_escape_bit;
+};
+
+/**
+ * GstMpegVideoSequenceDisplayExt:
+ * @profile: mpeg2 decoder profil
+
+ */
+struct _GstMpegVideoSequenceDisplayExt
+{
+  guint8 video_format;
+  guint8 colour_description_flag;
+
+  /* if colour_description_flag: */
+    guint8 colour_primaries;
+    guint8 transfer_characteristics;
+    guint8 matrix_coefficients;
+
+  guint16 display_horizontal_size;
+  guint16 display_vertical_size;
+};
+
+/**
+ * GstMpegVideoSequenceScalableExt:
+ * @scalable_mode:
+ * @layer_id:
+ * @lower_layer_prediction_horizontal_size:
+ * @lower_layer_prediction_vertical_size:
+ * @horizontal_subsampling_factor_m:
+ * @horizontal_subsampling_factor_n:
+ * @vertical_subsampling_factor_m:
+ * @vertical_subsampling_factor_n:
+ * @picture_mux_enable:
+ * @mux_to_progressive_sequence:
+ * @picture_mux_order:
+ * @picture_mux_factor:
+ *
+ * The Sequence Scalable Extension structure.
+ *
+ * Since: 1.2
+ */
+struct _GstMpegVideoSequenceScalableExt
+{
+  guint8 scalable_mode;
+  guint8 layer_id;
+
+  /* if spatial scalability */
+  guint16 lower_layer_prediction_horizontal_size;
+  guint16 lower_layer_prediction_vertical_size;
+  guint8 horizontal_subsampling_factor_m;
+  guint8 horizontal_subsampling_factor_n;
+  guint8 vertical_subsampling_factor_m;
+  guint8 vertical_subsampling_factor_n;
+
+  /* if temporal scalability */
+  guint8 picture_mux_enable;
+  guint8 mux_to_progressive_sequence;
+  guint8 picture_mux_order;
+  guint8 picture_mux_factor;
+};
+
+/**
+ * GstMpegVideoQuantMatrixExt:
+ * @load_intra_quantiser_matrix:
+ * @intra_quantiser_matrix:
+ * @load_non_intra_quantiser_matrix:
+ * @non_intra_quantiser_matrix:
+ * @load_chroma_intra_quantiser_matrix:
+ * @chroma_intra_quantiser_matrix:
+ * @load_chroma_non_intra_quantiser_matrix:
+ * @chroma_non_intra_quantiser_matrix:
+ *
+ * The Quant Matrix Extension structure that exposes quantization
+ * matrices in zigzag scan order. i.e. the original encoded scan
+ * order.
+ */
+struct _GstMpegVideoQuantMatrixExt
+{
+ guint8 load_intra_quantiser_matrix;
+ guint8 intra_quantiser_matrix[64];
+ guint8 load_non_intra_quantiser_matrix;
+ guint8 non_intra_quantiser_matrix[64];
+ guint8 load_chroma_intra_quantiser_matrix;
+ guint8 chroma_intra_quantiser_matrix[64];
+ guint8 load_chroma_non_intra_quantiser_matrix;
+ guint8 chroma_non_intra_quantiser_matrix[64];
+};
+
+/**
+ * GstMpegVideoPictureHdr:
+ * @tsn: Temporal Sequence Number
+ * @pic_type: Type of the frame
+ * @full_pel_forward_vector: the full pel forward flag of
+ *  the frame: 0 or 1.
+ * @full_pel_backward_vector: the full pel backward flag
+ *  of the frame: 0 or 1.
+ * @f_code: F code
+ *
+ * The Mpeg2 Video Picture Header structure.
+ */
+struct _GstMpegVideoPictureHdr
+{
+  guint16 tsn;
+  guint8 pic_type;
+  guint16 vbv_delay;
+
+  guint8 full_pel_forward_vector, full_pel_backward_vector;
+
+  guint8 f_code[2][2];
+};
+
+/**
+ * GstMpegVideoPictureExt:
+ * @intra_dc_precision: Intra DC precision
+ * @picture_structure: Structure of the picture
+ * @top_field_first: Top field first
+ * @frame_pred_frame_dct: Frame
+ * @concealment_motion_vectors: Concealment Motion Vectors
+ * @q_scale_type: Q Scale Type
+ * @intra_vlc_format: Intra Vlc Format
+ * @alternate_scan: Alternate Scan
+ * @repeat_first_field: Repeat First Field
+ * @chroma_420_type: Chroma 420 Type
+ * @progressive_frame: %TRUE if the frame is progressive %FALSE otherwise
+ *
+ * The Mpeg2 Video Picture Extension structure.
+ */
+struct _GstMpegVideoPictureExt
+{
+  guint8 f_code[2][2];
+
+  guint8 intra_dc_precision;
+  guint8 picture_structure;
+  guint8 top_field_first;
+  guint8 frame_pred_frame_dct;
+  guint8 concealment_motion_vectors;
+  guint8 q_scale_type;
+  guint8 intra_vlc_format;
+  guint8 alternate_scan;
+  guint8 repeat_first_field;
+  guint8 chroma_420_type;
+  guint8 progressive_frame;
+  guint8 composite_display;
+  guint8 v_axis;
+  guint8 field_sequence;
+  guint8 sub_carrier;
+  guint8 burst_amplitude;
+  guint8 sub_carrier_phase;
+};
+
+/**
+ * GstMpegVideoGop:
+ * @drop_frame_flag: Drop Frame Flag
+ * @hour: Hour (0-23)
+ * @minute: Minute (O-59)
+ * @second: Second (0-59)
+ * @frame: Frame (0-59)
+ * @closed_gop: Closed Gop
+ * @broken_link: Broken link
+ *
+ * The Mpeg Video Group of Picture structure.
+ */
+struct _GstMpegVideoGop
+{
+  guint8 drop_frame_flag;
+
+  guint8 hour, minute, second, frame;
+
+  guint8 closed_gop;
+  guint8 broken_link;
+};
+
+/**
+ * GstMpegVideoSliceHdr:
+ * @vertical_position: slice vertical position
+ * @vertical_position_extension: Extension to slice_vertical_position
+ * @priority_breakpoint: Point where the bitstream shall be partitioned
+ * @quantiser_scale_code: Quantiser value (range: 1-31)
+ * @slice_ext_flag: Slice Extension flag
+ * @intra_slice: Equal to one if all the macroblocks are intra macro blocks.
+ * @slice_picture_id_enable: controls the semantics of slice_picture_id
+ * @slice_picture_id: Intended to aid recovery on severe bursts of
+ *   errors for certain types of applications
+ *
+ * The Mpeg2 Video Slice Header structure.
+ *
+ * Since: 1.2
+ */
+struct _GstMpegVideoSliceHdr
+{
+  guint8 vertical_position;
+  guint8 vertical_position_ext;
+
+  guint8 priority_breakpoint;
+  guint8 quantiser_scale_code;
+  guint8 slice_ext_flag;
+  guint8 intra_slice;
+  guint8 slice_picture_id_enable;
+  guint8 slice_picture_id;
+
+  /* Calculated values */
+  guint header_size;            /* slice_header size in bits */
+  gint mb_row;                  /* macroblock row */
+  gint mb_column;               /* macroblock column */
+};
+
+/**
+ * GstMpegVideoPacket:
+ * @type: the type of the packet that start at @offset, as a #GstMpegVideoPacketTypeCode
+ * @data: the data containing the packet starting at @offset
+ * @offset: the offset of the packet start in bytes from @data. This is the
+ *     start of the packet itself without the sync code
+ * @size: The size in bytes of the packet or -1 if the end wasn't found. This
+ *     is the size of the packet itself without the sync code
+ *
+ * A structure that contains the type of a packet, its offset and its size
+ */
+struct _GstMpegVideoPacket
+{
+  const guint8 *data;
+  guint8 type;
+  guint  offset;
+  gint   size;
+};
+
+
+guint8 gst_mpeg_video_get_extension_code              (const GstMpegVideoPacket * packet);
+
+gboolean gst_mpeg_video_parse                         (GstMpegVideoPacket * packet,
+                                                       const guint8 * data, gsize size, guint offset);
+
+gboolean gst_mpeg_video_packet_parse_sequence_header    (const GstMpegVideoPacket * packet,
+                                                         GstMpegVideoSequenceHdr * seqhdr);
+
+gboolean gst_mpeg_video_packet_parse_sequence_extension (const GstMpegVideoPacket * packet,
+                                                         GstMpegVideoSequenceExt * seqext);
+
+gboolean gst_mpeg_video_packet_parse_sequence_display_extension (const GstMpegVideoPacket * packet,
+                                                         GstMpegVideoSequenceDisplayExt * seqdisplayext);
+
+gboolean gst_mpeg_video_packet_parse_sequence_scalable_extension (const GstMpegVideoPacket * packet,
+                                                         GstMpegVideoSequenceScalableExt * seqscaleext);
+
+gboolean gst_mpeg_video_packet_parse_picture_header     (const GstMpegVideoPacket * packet,
+                                                         GstMpegVideoPictureHdr* pichdr);
+
+gboolean gst_mpeg_video_packet_parse_picture_extension  (const GstMpegVideoPacket * packet,
+                                                         GstMpegVideoPictureExt *picext);
+
+gboolean gst_mpeg_video_packet_parse_gop                (const GstMpegVideoPacket * packet,
+                                                         GstMpegVideoGop * gop);
+
+gboolean gst_mpeg_video_packet_parse_slice_header       (const GstMpegVideoPacket * packet,
+                                                         GstMpegVideoSliceHdr * slice_hdr,
+                                                         GstMpegVideoSequenceHdr * seq_hdr,
+                                                         GstMpegVideoSequenceScalableExt * seqscaleext);
+
+gboolean gst_mpeg_video_packet_parse_quant_matrix_extension (const GstMpegVideoPacket * packet,
+                                                         GstMpegVideoQuantMatrixExt * quant);
+
+/* seqext and displayext may be NULL if not received */
+gboolean gst_mpeg_video_finalise_mpeg2_sequence_header (GstMpegVideoSequenceHdr *hdr,
+   GstMpegVideoSequenceExt *seqext, GstMpegVideoSequenceDisplayExt *displayext);
+
+#ifndef GST_DISABLE_DEPRECATED
+gboolean gst_mpeg_video_parse_picture_header          (GstMpegVideoPictureHdr* hdr,
+                                                       const guint8 * data, gsize size, guint offset);
+
+gboolean gst_mpeg_video_parse_picture_extension       (GstMpegVideoPictureExt *ext,
+                                                       const guint8 * data, gsize size, guint offset);
+
+gboolean gst_mpeg_video_parse_gop                     (GstMpegVideoGop * gop,
+                                                       const guint8 * data, gsize size, guint offset);
+
+gboolean gst_mpeg_video_parse_sequence_header         (GstMpegVideoSequenceHdr * seqhdr,
+                                                       const guint8 * data, gsize size, guint offset);
+
+gboolean gst_mpeg_video_parse_sequence_extension      (GstMpegVideoSequenceExt * seqext,
+                                                       const guint8 * data, gsize size, guint offset);
+
+gboolean gst_mpeg_video_parse_sequence_display_extension (GstMpegVideoSequenceDisplayExt * seqdisplayext,
+                                                       const guint8 * data, gsize size, guint offset);
+
+gboolean gst_mpeg_video_parse_quant_matrix_extension  (GstMpegVideoQuantMatrixExt * quant,
+                                                       const guint8 * data, gsize size, guint offset);
+#endif
+
+void     gst_mpeg_video_quant_matrix_get_raster_from_zigzag (guint8 out_quant[64],
+                                                             const guint8 quant[64]);
+
+void     gst_mpeg_video_quant_matrix_get_zigzag_from_raster (guint8 out_quant[64],
+                                                             const guint8 quant[64]);
+
+G_END_DECLS
+
+#endif
diff --git a/lib/libv4l-codecparsers/codecparsers/parserutils.c b/lib/libv4l-codecparsers/codecparsers/parserutils.c
new file mode 100644
index 0000000..d4a3f40
--- /dev/null
+++ b/lib/libv4l-codecparsers/codecparsers/parserutils.c
@@ -0,0 +1,57 @@
+/* Gstreamer
+ * Copyright (C) <2011> Intel Corporation
+ * Copyright (C) <2011> Collabora Ltd.
+ * Copyright (C) <2011> Thibault Saunier <thibault.saunier@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "parserutils.h"
+
+gboolean
+decode_vlc (GstBitReader * br, guint * res, const VLCTable * table,
+    guint length)
+{
+  guint8 i;
+  guint cbits = 0;
+  guint32 value = 0;
+
+  for (i = 0; i < length; i++) {
+    if (cbits != table[i].cbits) {
+      cbits = table[i].cbits;
+      if (!gst_bit_reader_peek_bits_uint32 (br, &value, cbits)) {
+        goto failed;
+      }
+    }
+
+    if (value == table[i].cword) {
+      SKIP (br, cbits);
+      if (res)
+        *res = table[i].value;
+
+      return TRUE;
+    }
+  }
+
+  GST_DEBUG ("Did not find code");
+
+failed:
+  {
+    GST_WARNING ("Could not decode VLC returning");
+
+    return FALSE;
+  }
+}
diff --git a/lib/libv4l-codecparsers/codecparsers/parserutils.h b/lib/libv4l-codecparsers/codecparsers/parserutils.h
new file mode 100644
index 0000000..6b54ded
--- /dev/null
+++ b/lib/libv4l-codecparsers/codecparsers/parserutils.h
@@ -0,0 +1,108 @@
+/* Gstreamer
+ * Copyright (C) <2011> Intel
+ * Copyright (C) <2011> Collabora Ltd.
+ * Copyright (C) <2011> Thibault Saunier <thibault.saunier@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __PARSER_UTILS__
+#define __PARSER_UTILS__
+
+#include <gst/gst.h>
+#include <gst/base/gstbitreader.h>
+
+/* Parsing utils */
+#define GET_BITS(b, num, bits) G_STMT_START {        \
+  if (!gst_bit_reader_get_bits_uint32(b, bits, num)) \
+    goto failed;                                     \
+  GST_TRACE ("parsed %d bits: %d", num, *(bits));    \
+} G_STMT_END
+
+#define CHECK_ALLOWED(val, min, max) G_STMT_START { \
+  if (val < min || val > max) { \
+    GST_WARNING ("value not in allowed range. value: %d, range %d-%d", \
+                     val, min, max); \
+    goto failed; \
+  } \
+} G_STMT_END
+
+#define READ_UINT8(reader, val, nbits) G_STMT_START { \
+  if (!gst_bit_reader_get_bits_uint8 (reader, &val, nbits)) { \
+    GST_WARNING ("failed to read uint8, nbits: %d", nbits); \
+    goto failed; \
+  } \
+} G_STMT_END
+
+#define READ_UINT16(reader, val, nbits) G_STMT_START { \
+  if (!gst_bit_reader_get_bits_uint16 (reader, &val, nbits)) { \
+    GST_WARNING ("failed to read uint16, nbits: %d", nbits); \
+    goto failed; \
+  } \
+} G_STMT_END
+
+#define READ_UINT32(reader, val, nbits) G_STMT_START { \
+  if (!gst_bit_reader_get_bits_uint32 (reader, &val, nbits)) { \
+    GST_WARNING ("failed to read uint32, nbits: %d", nbits); \
+    goto failed; \
+  } \
+} G_STMT_END
+
+#define READ_UINT64(reader, val, nbits) G_STMT_START { \
+  if (!gst_bit_reader_get_bits_uint64 (reader, &val, nbits)) { \
+    GST_WARNING ("failed to read uint64, nbits: %d", nbits); \
+    goto failed; \
+  } \
+} G_STMT_END
+
+
+#define U_READ_UINT8(reader, val, nbits) G_STMT_START { \
+  val = gst_bit_reader_get_bits_uint8_unchecked (reader, nbits); \
+} G_STMT_END
+
+#define U_READ_UINT16(reader, val, nbits) G_STMT_START { \
+  val = gst_bit_reader_get_bits_uint16_unchecked (reader, nbits); \
+} G_STMT_END
+
+#define U_READ_UINT32(reader, val, nbits) G_STMT_START { \
+  val = gst_bit_reader_get_bits_uint32_unchecked (reader, nbits); \
+} G_STMT_END
+
+#define U_READ_UINT64(reader, val, nbits) G_STMT_START { \
+  val = gst_bit_reader_get_bits_uint64_unchecked (reader, nbits); \
+} G_STMT_END
+
+#define SKIP(reader, nbits) G_STMT_START { \
+  if (!gst_bit_reader_skip (reader, nbits)) { \
+    GST_WARNING ("failed to skip nbits: %d", nbits); \
+    goto failed; \
+  } \
+} G_STMT_END
+
+typedef struct _VLCTable VLCTable;
+
+struct _VLCTable
+{
+  guint value;
+  guint cword;
+  guint cbits;
+};
+
+gboolean
+decode_vlc (GstBitReader * br, guint * res, const VLCTable * table,
+    guint length);
+
+#endif /* __PARSER_UTILS__ */
diff --git a/lib/libv4l-codecparsers/libv4l-codecparsers.pc.in b/lib/libv4l-codecparsers/libv4l-codecparsers.pc.in
new file mode 100644
index 0000000..ea367ee
--- /dev/null
+++ b/lib/libv4l-codecparsers/libv4l-codecparsers.pc.in
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+includedir=@includedir@
+libdir=@libdir@
+
+Name: libv4l-codecparsers
+Description: v4l2 library to parse video bitstream, needed by stateless video decoders
+Version: @PACKAGE_VERSION@
+Requires.private: libv4l-gst
+Libs: -L${libdir} -lv4l2
+Libs.private: -lpthread
+Cflags: -I${includedir}
diff --git a/lib/libv4l-codecparsers/libv4l-cparsers-mpeg2.c b/lib/libv4l-codecparsers/libv4l-cparsers-mpeg2.c
new file mode 100644
index 0000000..1c0398a
--- /dev/null
+++ b/lib/libv4l-codecparsers/libv4l-cparsers-mpeg2.c
@@ -0,0 +1,366 @@
+/*
+ * libv4l-cparsers-mpeg2.c
+ *
+ * Copyright (C) STMicroelectronics SA 2017
+ * Authors: Hugues Fruchet <hugues.fruchet@st.com>
+ *          Tifaine Inguere <tifaine.inguere@st.com>
+ *          for STMicroelectronics.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335  USA
+ */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "codecparsers/gstmpegvideoparser.h"
+#include "libv4l-cparsers.h"
+
+/* disable verbose trace */
+#define CPARSERS_LOG_VDEBUG(...)
+
+/* parsing meta data ids and their
+ * associated control ids.
+ * keep in sync both enum and array,
+ * this is used to index metas[<meta id>]
+ */
+enum mpeg2_meta_id {
+	SEQ_HDR,
+	SEQ_EXT,
+	SEQ_DISP_EXT,
+	SEQ_MATRIX_EXT,
+	PIC_HDR,
+	PIC_HDR1,/* 2nd field decoding of interlaced stream */
+	PIC_EXT,
+	PIC_EXT1,/* 2nd field decoding of interlaced stream */
+};
+
+static const struct v4l2_ext_control mpeg2_metas[] = {
+	{
+	.id = V4L2_CID_MPEG_VIDEO_MPEG2_SEQ_HDR,
+	.size = sizeof(struct v4l2_mpeg2_seq_hdr),
+	},
+	{
+	.id = V4L2_CID_MPEG_VIDEO_MPEG2_SEQ_EXT,
+	.size = sizeof(struct v4l2_mpeg2_seq_ext),
+	},
+	{
+	.id = V4L2_CID_MPEG_VIDEO_MPEG2_SEQ_DISPLAY_EXT,
+	.size = sizeof(struct v4l2_mpeg2_seq_disp_ext),
+	},
+	{
+	.id = V4L2_CID_MPEG_VIDEO_MPEG2_SEQ_MATRIX_EXT,
+	.size = sizeof(struct v4l2_mpeg2_seq_matrix_ext),
+	},
+	{
+	.id = V4L2_CID_MPEG_VIDEO_MPEG2_PIC_HDR,
+	.size = sizeof(struct v4l2_mpeg2_pic_hdr),
+	},
+	{/* 2nd field decoding of interlaced stream */
+	.id = V4L2_CID_MPEG_VIDEO_MPEG2_PIC_HDR,
+	.size = sizeof(struct v4l2_mpeg2_pic_hdr),
+	},
+	{
+	.id = V4L2_CID_MPEG_VIDEO_MPEG2_PIC_EXT,
+	.size = sizeof(struct v4l2_mpeg2_pic_ext),
+	},
+	{/* 2nd field decoding of interlaced stream */
+	.id = V4L2_CID_MPEG_VIDEO_MPEG2_PIC_EXT,
+	.size = sizeof(struct v4l2_mpeg2_pic_ext),
+	},
+};
+
+/* Potential improvements:
+ * - parsing errors tracing (trace in case of gst_parse_xxx fails)
+ */
+unsigned int mpeg2_decode_header(void *au_addr,
+								 unsigned int au_size,
+								 struct v4l2_ext_control *metas_store,
+								 struct v4l2_ext_control *metas,
+								 unsigned int *nb_of_metas)
+{
+	unsigned char extension_code;
+	bool startcode_found = false;
+	bool meta_found = false;
+	GstMpegVideoPacket packet_data;
+	unsigned int slice_index = 0;
+	GstMpegVideoSequenceHdr gst_seq_hdr;
+	GstMpegVideoSequenceExt gst_seq_ext;
+	GstMpegVideoSequenceDisplayExt gst_seq_disp_ext;
+	GstMpegVideoQuantMatrixExt gst_seq_matrix_ext;
+	GstMpegVideoPictureHdr gst_pic_hdr;
+	GstMpegVideoPictureExt gst_pic_ext;
+	struct v4l2_mpeg2_seq_hdr *seq_hdr;
+	struct v4l2_mpeg2_seq_ext *seq_ext;
+	struct v4l2_mpeg2_seq_disp_ext *seq_disp_ext;
+	struct v4l2_mpeg2_seq_matrix_ext *seq_matrix_ext;
+	struct v4l2_mpeg2_pic_hdr *pic_hdrs[2];
+	struct v4l2_mpeg2_pic_ext *pic_exts[2];
+
+	seq_hdr = metas_store[SEQ_HDR].ptr;
+	seq_ext = metas_store[SEQ_EXT].ptr;
+	seq_disp_ext = metas_store[SEQ_DISP_EXT].ptr;
+	seq_matrix_ext = metas_store[SEQ_MATRIX_EXT].ptr;
+	pic_hdrs[0] = metas_store[PIC_HDR].ptr;
+	pic_hdrs[1] = metas_store[PIC_HDR + 1].ptr;
+	pic_exts[0] = metas_store[PIC_EXT].ptr;
+	pic_exts[1] = metas_store[PIC_EXT + 1].ptr;
+
+	if ((!au_addr) || (!au_size) || (!metas_store) || (!metas)) {
+		CPARSERS_LOG_ERR("%s: invalid input: au_addr=%p, au_size=%d, metas_store=%p, metas=%p\n",
+					  __func__, au_addr, au_size, metas_store, metas);
+		return 0;
+	}
+
+	memset(&packet_data, 0, sizeof(packet_data));
+
+	while (((packet_data.offset + 4) < au_size)) {
+		CPARSERS_LOG_VDEBUG("%s: parsing input from offset=%d\n", __func__,
+						 packet_data.offset);
+		startcode_found = gst_mpeg_video_parse(&packet_data, au_addr, au_size, packet_data.offset);
+		if (!startcode_found) {
+			CPARSERS_LOG_DEBUG("%s: parsing is over\n", __func__);
+			break;
+		}
+		/* gst_mpeg_video_parse compute packet size by searching for next
+		 * startcode, but if next startcode is not found (end of access unit),
+		 * packet size is set to -1. We fix this here and set packet size
+		 * to remaining size in this case.
+		 */
+		if (packet_data.size < 0)
+			packet_data.size = au_size - packet_data.offset;
+
+		CPARSERS_LOG_VDEBUG("%s: found startcode 0x%02x @offset=%u, size=%d\n",
+						 __func__, packet_data.type, packet_data.offset - 4, packet_data.size);
+
+		switch (packet_data.type) {
+		case GST_MPEG_VIDEO_PACKET_PICTURE:
+			if (gst_mpeg_video_packet_parse_picture_header
+					(&packet_data, &gst_pic_hdr)) {
+				struct v4l2_mpeg2_pic_hdr *pic_hdr = pic_hdrs[slice_index];
+
+				metas[(*nb_of_metas)++] = metas_store[PIC_HDR + slice_index];
+
+				memset(pic_hdr, 0, sizeof(*pic_hdr));
+				pic_hdr->tsn = gst_pic_hdr.tsn;
+				pic_hdr->pic_type = gst_pic_hdr.pic_type;
+				pic_hdr->vbv_delay = gst_pic_hdr.vbv_delay;
+				pic_hdr->full_pel_forward_vector = gst_pic_hdr.full_pel_forward_vector;
+				pic_hdr->full_pel_backward_vector = gst_pic_hdr.full_pel_backward_vector;
+				memcpy(&pic_hdr->f_code, &gst_pic_hdr.f_code, sizeof(pic_hdr->f_code));
+
+				CPARSERS_LOG_DEBUG("%s: PICTURE HEADER\n", __func__);
+				meta_found = true;
+			}
+			break;
+
+		case GST_MPEG_VIDEO_PACKET_SLICE_MIN:
+			/* New slice encountered */
+			if (slice_index > 1) {
+				CPARSERS_LOG_ERR("%s: more than 2 slices detected @offset=%d, ignoring this slice...\n",
+							  __func__, packet_data.offset);
+				break;
+			}
+			/* store its offset, including startcode */
+			pic_hdrs[slice_index]->offset = packet_data.offset - 4;
+			slice_index++;
+
+			CPARSERS_LOG_DEBUG("%s: START OF SLICE @ offset=%d\n", __func__, packet_data.offset);
+			meta_found = true;
+			goto done;
+
+			break;
+
+		case GST_MPEG_VIDEO_PACKET_USER_DATA:
+			/* not implemented : do nothing */
+			CPARSERS_LOG_DEBUG("%s: USER DATA, not implemented\n", __func__);
+			break;
+
+		case GST_MPEG_VIDEO_PACKET_SEQUENCE:
+			if (gst_mpeg_video_packet_parse_sequence_header
+					(&packet_data, &gst_seq_hdr)) {
+				metas[(*nb_of_metas)++] = metas_store[SEQ_HDR];
+
+				memset(seq_hdr, 0, sizeof(*seq_hdr));
+				seq_hdr->width = gst_seq_hdr.width;
+				seq_hdr->height = gst_seq_hdr.height;
+				seq_hdr->load_intra_quantiser_matrix = gst_seq_hdr.load_intra_quantiser_matrix;
+				seq_hdr->load_non_intra_quantiser_matrix = gst_seq_hdr.load_non_intra_quantiser_matrix;
+				memcpy(&seq_hdr->intra_quantiser_matrix,
+					   &gst_seq_hdr.intra_quantizer_matrix,
+					   sizeof(seq_hdr->intra_quantiser_matrix));
+				memcpy(&seq_hdr->non_intra_quantiser_matrix,
+					   &gst_seq_hdr.non_intra_quantizer_matrix,
+					   sizeof(seq_hdr->non_intra_quantiser_matrix));
+
+				CPARSERS_LOG_DEBUG("%s: SEQUENCE HEADER\n", __func__);
+				meta_found = true;
+			}
+			break;
+
+		case GST_MPEG_VIDEO_PACKET_EXTENSION:
+			extension_code = gst_mpeg_video_get_extension_code(&packet_data);
+			CPARSERS_LOG_DEBUG("%s: extension code=0x%02x  \n", __func__, extension_code);
+
+			switch (extension_code) {
+			case GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE:
+				if (gst_mpeg_video_packet_parse_sequence_extension
+						(&packet_data, &gst_seq_ext)) {
+					metas[(*nb_of_metas)++] = metas_store[SEQ_EXT];
+
+					memset(seq_ext, 0, sizeof(*seq_ext));
+					seq_ext->profile = gst_seq_ext.profile;
+					seq_ext->level = gst_seq_ext.level;
+					seq_ext->progressive = gst_seq_ext.progressive;
+					seq_ext->chroma_format = gst_seq_ext.chroma_format;
+					seq_ext->horiz_size_ext = gst_seq_ext.horiz_size_ext;
+					seq_ext->vert_size_ext = gst_seq_ext.vert_size_ext;
+
+					CPARSERS_LOG_DEBUG("%s: SEQUENCE EXTENSION\n", __func__);
+					meta_found = true;
+				}
+				break;
+
+			case GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE_DISPLAY:
+				if (gst_mpeg_video_packet_parse_sequence_display_extension
+						(&packet_data, &gst_seq_disp_ext)) {
+					metas[(*nb_of_metas)++] = metas_store[SEQ_DISP_EXT];
+
+					memset(seq_disp_ext, 0, sizeof(*seq_disp_ext));
+					seq_disp_ext->video_format = gst_seq_disp_ext.video_format;
+					seq_disp_ext->colour_description_flag = gst_seq_disp_ext.colour_description_flag;
+					seq_disp_ext->colour_primaries = gst_seq_disp_ext.colour_primaries;
+					seq_disp_ext->transfer_characteristics = gst_seq_disp_ext.transfer_characteristics;
+					seq_disp_ext->matrix_coefficients = gst_seq_disp_ext.matrix_coefficients;
+					seq_disp_ext->display_horizontal_size = gst_seq_disp_ext.display_horizontal_size;
+					seq_disp_ext->display_vertical_size = gst_seq_disp_ext.display_vertical_size;
+
+					CPARSERS_LOG_DEBUG("%s: SEQUENCE DISPLAY EXTENSION\n", __func__);
+					meta_found = true;
+				}
+				break;
+
+			case GST_MPEG_VIDEO_PACKET_EXT_QUANT_MATRIX:
+				if (gst_mpeg_video_packet_parse_quant_matrix_extension
+						(&packet_data, &gst_seq_matrix_ext)) {
+					metas[(*nb_of_metas)++] = metas_store[SEQ_DISP_EXT];
+
+					memset(seq_matrix_ext, 0, sizeof(*seq_matrix_ext));
+					seq_matrix_ext->load_intra_quantiser_matrix =
+						gst_seq_matrix_ext.load_intra_quantiser_matrix;
+					memcpy(&seq_matrix_ext->intra_quantiser_matrix,
+						   &gst_seq_matrix_ext.intra_quantiser_matrix,
+						   sizeof(seq_matrix_ext->intra_quantiser_matrix));
+					seq_matrix_ext->load_non_intra_quantiser_matrix =
+						gst_seq_matrix_ext.load_non_intra_quantiser_matrix;
+					memcpy(&seq_matrix_ext->non_intra_quantiser_matrix,
+						   &gst_seq_matrix_ext.non_intra_quantiser_matrix,
+						   sizeof(seq_matrix_ext->non_intra_quantiser_matrix));
+					seq_matrix_ext->load_chroma_intra_quantiser_matrix =
+						gst_seq_matrix_ext.load_chroma_intra_quantiser_matrix;
+					memcpy(&seq_matrix_ext->chroma_intra_quantiser_matrix,
+						   &gst_seq_matrix_ext.chroma_intra_quantiser_matrix,
+						   sizeof(seq_matrix_ext->chroma_intra_quantiser_matrix));
+					seq_matrix_ext->load_chroma_non_intra_quantiser_matrix =
+						gst_seq_matrix_ext.load_chroma_non_intra_quantiser_matrix;
+					memcpy(&seq_matrix_ext->chroma_non_intra_quantiser_matrix,
+						   &gst_seq_matrix_ext.chroma_non_intra_quantiser_matrix,
+						   sizeof(seq_matrix_ext->chroma_non_intra_quantiser_matrix));
+
+					CPARSERS_LOG_DEBUG("%s: SEQUENCE MATRIX EXTENSION\n", __func__);
+					meta_found = true;
+				}
+				break;
+
+			case GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE_SCALABLE:
+				/* not implemented : do nothing */
+				CPARSERS_LOG_DEBUG("%s: SEQUENCE SCALABLE EXTENSION, not implemented\n", __func__);
+				break;
+
+			case GST_MPEG_VIDEO_PACKET_EXT_PICTURE:
+				if (gst_mpeg_video_packet_parse_picture_extension
+						(&packet_data, &gst_pic_ext)) {
+					struct v4l2_mpeg2_pic_ext *pic_ext = pic_exts[slice_index];
+
+					metas[(*nb_of_metas)++] = metas_store[PIC_EXT + slice_index];
+
+					memset(pic_ext, 0, sizeof(*pic_ext));
+					memcpy(&pic_ext->f_code, &gst_pic_ext.f_code, sizeof(pic_ext->f_code));
+					pic_ext->intra_dc_precision = gst_pic_ext.intra_dc_precision;
+					pic_ext->picture_structure = gst_pic_ext.picture_structure;
+					pic_ext->top_field_first = gst_pic_ext.top_field_first;
+					pic_ext->frame_pred_frame_dct = gst_pic_ext.frame_pred_frame_dct;
+					pic_ext->concealment_motion_vectors = gst_pic_ext.concealment_motion_vectors;
+					pic_ext->q_scale_type = gst_pic_ext.q_scale_type;
+					pic_ext->intra_vlc_format = gst_pic_ext.intra_vlc_format;
+					pic_ext->alternate_scan = gst_pic_ext.alternate_scan;
+					pic_ext->repeat_first_field = gst_pic_ext.repeat_first_field;
+					pic_ext->chroma_420_type = gst_pic_ext.chroma_420_type;
+					pic_ext->progressive_frame = gst_pic_ext.progressive_frame;
+					pic_ext->composite_display = gst_pic_ext.composite_display;
+					pic_ext->v_axis = gst_pic_ext.v_axis;
+					pic_ext->field_sequence = gst_pic_ext.field_sequence;
+					pic_ext->sub_carrier = gst_pic_ext.sub_carrier;
+					pic_ext->burst_amplitude = gst_pic_ext.burst_amplitude;
+					pic_ext->sub_carrier_phase = gst_pic_ext.sub_carrier_phase;
+
+					CPARSERS_LOG_DEBUG("%s: PICTURE EXTENSION, top_field_first=%d\n",
+									__func__, pic_exts[slice_index]->top_field_first);
+					meta_found = true;
+				}
+				break;
+
+			default:
+				break;
+			}
+			break;
+
+		case GST_MPEG_VIDEO_PACKET_SEQUENCE_END:
+			CPARSERS_LOG_DEBUG("%s: END OF PACKET SEQUENCE\n", __func__);
+			break;
+
+		case GST_MPEG_VIDEO_PACKET_GOP:
+			CPARSERS_LOG_DEBUG("%s: GOP\n", __func__);
+			break;
+
+		default:
+			CPARSERS_LOG_VDEBUG("%s: unknown/unsupported header %02x\n",
+							 __func__, packet_data.type);
+			break;
+		}
+	}
+
+done:
+	return meta_found;
+}
+
+const struct meta_parser mpeg2parse = {
+	.name = "mpeg2",
+	.streamformat = V4L2_PIX_FMT_MPEG2,
+	.parsedformat = V4L2_PIX_FMT_MPEG2_PARSED,
+	.nb_of_metas = sizeof(mpeg2_metas) / sizeof(mpeg2_metas[0]),
+	.metas = mpeg2_metas,
+	.decode_header = mpeg2_decode_header,
+};
+
+const struct meta_parser mpeg1parse = {
+	.name = "mpeg1",
+	.streamformat = V4L2_PIX_FMT_MPEG1,
+	.parsedformat = V4L2_PIX_FMT_MPEG1_PARSED,
+	.nb_of_metas = sizeof(mpeg2_metas) / sizeof(mpeg2_metas[0]),
+	.metas = mpeg2_metas,
+	.decode_header = mpeg2_decode_header,
+};
diff --git a/lib/libv4l-codecparsers/libv4l-cparsers.c b/lib/libv4l-codecparsers/libv4l-cparsers.c
new file mode 100644
index 0000000..432c5da
--- /dev/null
+++ b/lib/libv4l-codecparsers/libv4l-cparsers.c
@@ -0,0 +1,455 @@
+/*
+ * libv4l-cparsers.c
+ *
+ * Copyright (C) STMicroelectronics SA 2017
+ * Authors: Hugues Fruchet <hugues.fruchet@st.com>
+ *          Tifaine Inguere <tifaine.inguere@st.com>
+ *          for STMicroelectronics.
+ */
+/*
+ *             (C) 2012 Mauro Carvalho Chehab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335  USA
+ */
+
+#include <config.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+#include "../libv4lconvert/libv4lsyscall-priv.h"
+#include "libv4l-plugin.h"
+#include "libv4l-cparsers.h"
+
+#if HAVE_VISIBILITY
+#define PLUGIN_PUBLIC __attribute__ ((visibility("default")))
+#else
+#define PLUGIN_PUBLIC
+#endif
+
+/* available parsers */
+extern const struct meta_parser mpeg1parse;
+extern const struct meta_parser mpeg2parse;
+const struct meta_parser *parsers[] = {
+    &mpeg1parse,
+    &mpeg2parse,
+};
+
+static void *plugin_init(int fd)
+{
+	struct cparsers_plugin *cparsers = NULL;
+	struct v4l2_capability cap;
+	int ret;
+	unsigned int i;
+	struct v4l2_fmtdesc fmt;
+	bool found = false;
+
+	/* check if device needs cparsers plugin */
+	memset(&cap, 0, sizeof(cap));
+	ret = SYS_IOCTL(fd, VIDIOC_QUERYCAP, &cap);
+	if (ret)
+		return NULL;
+
+	if (!(cap.capabilities & V4L2_CAP_VIDEO_M2M))
+		return NULL;
+
+	memset(&fmt, 0, sizeof(fmt));
+	fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	while (SYS_IOCTL(fd, VIDIOC_ENUM_FMT, &fmt) >= 0) {
+		for (i = 0; i < (sizeof(parsers) / sizeof(parsers[0])); i++) {
+			if (parsers[i]->parsedformat == fmt.pixelformat) {
+				CPARSERS_LOG_DEBUG("%s: %s device matches %s parser for conversion %4.4s=>%4.4s(%s)\n",
+						__func__, cap.driver, parsers[i]->name,
+						(char *)&parsers[i]->streamformat,
+						(char *)&fmt.pixelformat, fmt.description);
+				found = true;
+				break;
+			}
+		}
+		fmt.index++;
+	}
+
+	if (!found)
+		return NULL;
+
+	CPARSERS_LOG_INFO("%s: %s device needs libv4l-codecparsers plugin\n",
+			__func__, cap.driver);
+
+	/* allocate and initialize private data */
+	cparsers = calloc(1, sizeof(struct cparsers_plugin));
+	if (!cparsers) {
+		CPARSERS_LOG_ERR
+		    ("%s: couldn't allocate memory\n", __func__);
+		return NULL;
+	}
+
+	/* store driver name (debug purpose) */
+	memcpy(cparsers->driver_name, cap.driver, sizeof(cparsers->driver_name));
+
+	return cparsers;
+}
+
+static void plugin_close(void *dev_ops_priv)
+{
+	struct cparsers_plugin *cparsers = dev_ops_priv;
+	unsigned int i, j;
+
+	if (!cparsers)
+		return;
+
+	if (!cparsers->buffer_info)
+		return;
+
+	for (i = 0; i < cparsers->buffer_nb; i++) {
+		struct cparsers_buffer_info *buf_info = &cparsers->buffer_info[i];
+
+		/* unmap AU */
+		if (buf_info->au_addr)
+			SYS_MUNMAP(buf_info->au_addr, buf_info->au_size);
+
+		/* free metadatas */
+		for (j = 0; j < buf_info->nb_of_metas; j++)
+			if (buf_info->metas[j].ptr)
+				free(buf_info->metas[j].ptr);
+	}
+
+	free(cparsers->buffer_info);
+	free(cparsers);
+}
+
+static int enum_fmt(struct cparsers_plugin *cparsers, int fd,
+					unsigned long int cmd, struct v4l2_fmtdesc *fmtdesc)
+{
+	unsigned int i;
+	int ret = 0;
+	__u32 driver_format;
+
+	if (!fmtdesc)
+		return -EINVAL;
+
+	ret = SYS_IOCTL(fd, cmd, fmtdesc);
+	if (ret)
+		return ret;
+
+	if (fmtdesc->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return 0;
+
+	/* Check if driver enumerate a parsers' supported
+	 * pixel format, in that case override with stream
+	 * format so that conversion is transparent for user
+	 */
+	driver_format = fmtdesc->pixelformat;
+	for (i = 0; i < (sizeof(parsers) / sizeof(parsers[0])); i++) {
+		if (parsers[i]->parsedformat == driver_format) {
+			CPARSERS_LOG_DEBUG("%s: %s parser available, override format %4.4s with %4.4s\n",
+					__func__, parsers[i]->name,
+					(char *)&driver_format, (char *)&parsers[i]->streamformat);
+			fmtdesc->pixelformat = parsers[i]->streamformat;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+
+static int try_fmt(struct cparsers_plugin *cparsers, int fd,
+				   unsigned long int cmd, struct v4l2_format *format)
+{
+	unsigned int i;
+	int ret = 0;
+	__u32 requested_format;
+
+	if (!format)
+		return -EINVAL;
+
+	/* Check if user request for a parsers' supported
+	 * pixel format, in that case override with parsed
+	 * format supported by driver
+	 */
+	requested_format = format->fmt.pix.pixelformat;
+	if (format->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		for (i = 0; i < (sizeof(parsers) / sizeof(parsers[0])); i++) {
+			if (parsers[i]->streamformat == requested_format) {
+				CPARSERS_LOG_DEBUG("%s: %s parser available, override format %4.4s with %4.4s\n",
+						__func__, parsers[i]->name,
+						(char *)&requested_format, (char *)&parsers[i]->parsedformat);
+				format->fmt.pix.pixelformat = parsers[i]->parsedformat;
+				break;
+			}
+		}
+
+	ret = SYS_IOCTL(fd, cmd, format);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+static int g_fmt(struct cparsers_plugin *cparsers, int fd,
+				 unsigned long int cmd, struct v4l2_format *format)
+{
+	unsigned int i;
+	int ret = 0;
+	__u32 driver_format;
+
+	if (!format)
+		return -EINVAL;
+
+	ret = SYS_IOCTL(fd, cmd, format);
+	if (ret)
+		return ret;
+
+	driver_format = format->fmt.pix.pixelformat;
+
+	/* Check if driver returns a parsers' supported
+	 * pixel format, in that case override with stream
+	 * format so that conversion is transparent for user
+	 */
+	if (format->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		for (i = 0; i < (sizeof(parsers) / sizeof(parsers[0])); i++) {
+			if (parsers[i]->parsedformat == driver_format) {
+				CPARSERS_LOG_DEBUG("%s: %s parser available, override format %4.4s with %4.4s\n",
+						__func__, parsers[i]->name,
+						(char *)&driver_format, (char *)&parsers[i]->streamformat);
+				format->fmt.pix.pixelformat = parsers[i]->streamformat;
+				break;
+			}
+		}
+
+	return ret;
+}
+
+static int s_fmt(struct cparsers_plugin *cparsers, int fd,
+				 unsigned long int cmd, struct v4l2_format *format)
+{
+	unsigned int i;
+	int ret = 0;
+	__u32 requested_format;
+	bool parser_enabled = false;
+
+	if (!format)
+		return -EINVAL;
+
+	/* Check if user request for a parsers' supported
+	 * pixel format, in that case override with parsed
+	 * format supported by driver
+	 */
+	requested_format = format->fmt.pix.pixelformat;
+	if (format->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		for (i = 0; i < (sizeof(parsers) / sizeof(parsers[0])); i++) {
+			if (parsers[i]->streamformat == requested_format) {
+				CPARSERS_LOG_DEBUG("%s: %s parser available, override format %4.4s with %4.4s\n",
+						__func__, parsers[i]->name,
+						(char *)&requested_format, (char *)&parsers[i]->parsedformat);
+				format->fmt.pix.pixelformat = parsers[i]->parsedformat;
+				parser_enabled = true;
+				break;
+			}
+		}
+
+	ret = SYS_IOCTL(fd, cmd, format);
+	if (ret)
+		return ret;
+
+	if (!parser_enabled)
+		return ret;
+
+	/* We have now a parser candidate and
+	 * S_FMT is sucessful on driver side,
+	 * let's selects this parser for this instance
+	 */
+	cparsers->parser = parsers[i];
+	/* Override format, so that conversion is transparent for user */
+	format->fmt.pix.pixelformat = requested_format;
+
+	CPARSERS_LOG_INFO("%s: %s parser is now selected for device %s\n",
+			__func__, cparsers->parser->name, cparsers->driver_name);
+
+	return ret;
+}
+
+static int reqbufs(struct cparsers_plugin *cparsers, int fd,
+				   unsigned long int cmd,
+				   struct v4l2_requestbuffers *requestbuffers)
+{
+	int ret;
+
+	if (!requestbuffers)
+		return -EINVAL;
+
+	ret = SYS_IOCTL(fd, cmd, requestbuffers);
+	if (ret)
+		return ret;
+
+	if (cparsers->parser &&
+	    (requestbuffers->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) &&
+	    (requestbuffers->count > 0)) {
+		/* Intercept REQBUFS(OUTPUT) to know the nb of buffers to mmap */
+
+		/* Allocates buffer info */
+		cparsers->buffer_info =
+		    calloc(requestbuffers->count,
+			   sizeof(struct cparsers_buffer_info));
+
+		cparsers->buffer_nb = requestbuffers->count;
+	}
+
+	return ret;
+}
+
+static int querybuf(struct cparsers_plugin *cparsers, int fd,
+					unsigned long int cmd, struct v4l2_buffer *buffer)
+{
+	int ret;
+	const struct meta_parser *parser = cparsers->parser;
+	unsigned int i;
+
+	if (!buffer)
+		return -EINVAL;
+
+	ret = SYS_IOCTL(fd, cmd, buffer);
+	if (ret)
+		return ret;
+
+	if (parser &&
+	    (buffer->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) &&
+	    (buffer->length > 0)) {
+		/* Intercept QUERYBUF(OUTPUT) to mmap access unit & allocate metadata */
+
+		struct cparsers_buffer_info *buf_info =
+		    &cparsers->buffer_info[buffer->index];
+		void *vaddr;
+
+		/* AU memory mapping */
+		buf_info->au_size = buffer->length;
+		vaddr = (void *)SYS_MMAP(NULL, buffer->length,
+					 PROT_READ | PROT_WRITE, MAP_SHARED, fd,
+					 buffer->m.offset);
+		if (vaddr == MAP_FAILED) {
+			CPARSERS_LOG_ERR("%s: failed to map AU\n", __func__);
+			return -EINVAL;
+		}
+		buf_info->au_addr = vaddr;
+
+		buf_info->nb_of_metas = parser->nb_of_metas;
+		if (buf_info->nb_of_metas > CPARSERS_MAX_METAS) {
+			CPARSERS_LOG_ERR("%s: not enough room for metas (%d > %d), please increase CPARSERS_MAX_METAS\n",
+					__func__, buf_info->nb_of_metas, CPARSERS_MAX_METAS);
+			return -EINVAL;
+		}
+
+		for (i = 0; i < buf_info->nb_of_metas; i++) {
+			buf_info->metas[i] = parser->metas[i];
+			/* Allocate metadata */
+			vaddr = calloc(1, buf_info->metas[i].size);
+			if (!vaddr) {
+				CPARSERS_LOG_ERR("%s: couldn't allocate metadata memory plugin\n", __func__);
+				return -ENOMEM;
+			}
+			buf_info->metas[i].ptr = vaddr;
+		}
+	}
+
+	return ret;
+}
+
+static int qbuf(struct cparsers_plugin *cparsers, int fd, unsigned long int cmd,
+				struct v4l2_buffer *buffer)
+{
+	struct cparsers_buffer_info *buf_info;
+	struct v4l2_ext_controls ctrls;
+	int ret = 0;
+	void *au_addr;
+	unsigned int au_size;
+	unsigned int found = 0;
+	const struct meta_parser *parser = cparsers->parser;
+	unsigned int nb_of_metas = 0;
+	struct v4l2_ext_control metas[CPARSERS_MAX_METAS];
+
+	if (!buffer)
+		return -EINVAL;
+
+	buf_info = &cparsers->buffer_info[buffer->index];
+	au_addr = buf_info->au_addr;
+	au_size = buffer->bytesused;
+
+	if (parser &&
+	    (buffer->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) &&
+	    (au_size > 0)) {
+		nb_of_metas = 0;
+		memset(metas, 0, sizeof(metas));
+		found = parser->decode_header(au_addr, au_size, buf_info->metas,
+									  metas, &nb_of_metas);
+		if (!found) {
+			CPARSERS_LOG_WARN("%s: no header found within %d bytes input stream\n",
+					__func__, au_size);
+			return 0;
+		}
+
+		/* Call CTRL with metas */
+		memset(&ctrls, 0, sizeof(ctrls));
+		ctrls.controls = metas;
+		ctrls.count = nb_of_metas;
+
+		ret = SYS_IOCTL(fd, VIDIOC_S_EXT_CTRLS, &ctrls);
+		if (ret)
+			return ret;
+	}
+
+	/* Call QBUF */
+	ret = SYS_IOCTL(fd, cmd, buffer);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+static int plugin_ioctl(void *dev_ops_priv, int fd,
+						unsigned long int cmd, void *arg)
+{
+	struct cparsers_plugin *cparsers = dev_ops_priv;
+
+	switch (cmd) {
+	case VIDIOC_ENUM_FMT:
+		return enum_fmt(cparsers, fd, cmd, arg);
+	case VIDIOC_TRY_FMT:
+		return try_fmt(cparsers, fd, cmd, arg);
+	case VIDIOC_G_FMT:
+		return g_fmt(cparsers, fd, cmd, arg);
+	case VIDIOC_S_FMT:
+		return s_fmt(cparsers, fd, cmd, arg);
+	case VIDIOC_REQBUFS:
+		return reqbufs(cparsers, fd, cmd, arg);
+	case VIDIOC_QUERYBUF:
+		return querybuf(cparsers, fd, cmd, arg);
+	case VIDIOC_QBUF:
+		return qbuf(cparsers, fd, cmd, arg);
+	default:
+		return SYS_IOCTL(fd, cmd, arg);
+	}
+}
+
+PLUGIN_PUBLIC const struct libv4l_dev_ops libv4l2_plugin = {
+	.init = &plugin_init,
+	.close = &plugin_close,
+	.ioctl = &plugin_ioctl,
+};
diff --git a/lib/libv4l-codecparsers/libv4l-cparsers.h b/lib/libv4l-codecparsers/libv4l-cparsers.h
new file mode 100644
index 0000000..c4fbb72
--- /dev/null
+++ b/lib/libv4l-codecparsers/libv4l-cparsers.h
@@ -0,0 +1,120 @@
+/*
+ * libv4l-cparsers.h
+ *
+ * Copyright (C) STMicroelectronics SA 2017
+ * Authors: Hugues Fruchet <hugues.fruchet@st.com>
+ *          Tifaine Inguere <tifaine.inguere@st.com>
+ *          for STMicroelectronics.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335  USA
+ */
+
+#ifndef LIBV4L_CPARSERS_H
+#define LIBV4L_CPARSERS_H
+
+#include <stdio.h>
+#include <linux/videodev2.h>
+
+#define CPARSERS_LOG_ERR(...) \
+	do { \
+		fprintf(stderr, "libv4l-cparsers/err " __VA_ARGS__); \
+	} while (0)
+
+#define CPARSERS_LOG_WARN(...) \
+	do { \
+		fprintf(stderr, "libv4l-cparsers/warn " __VA_ARGS__); \
+	} while (0)
+
+#define CPARSERS_LOG_INFO(...) \
+	do { \
+		fprintf(stdout, "libv4l-cparsers/info " __VA_ARGS__); \
+	} while (0)
+
+#define CPARSERS_MAX_METAS 20
+
+struct meta_parser {
+	const char *name;
+	__u32 streamformat;
+	__u32 parsedformat;
+	const struct v4l2_ext_control *metas;
+	unsigned int nb_of_metas;
+
+	/*
+	 * decode_header() - decode the header of a single access unit
+	 * @au_addr: (in) access unit address
+	 * @au_size: (in) access unit size
+	 * @meta: (in/out) metadata
+	 *
+	 * Decode the header of the given access unit. The retrieved
+	 * information (metadatas) are stored in metas/nb_of_metas
+	 */
+	unsigned int (*decode_header) (void *au_addr,
+								   unsigned int au_size,
+								   struct v4l2_ext_control *metas_store,
+								   struct v4l2_ext_control *metas,
+								   unsigned int *nb_of_metas);
+};
+
+/*
+ * struct cparsers_buffer_info
+ *
+ * @au_addr: virtual address of the access unit data
+ * @au_size: size in bytes of the access unit data
+ * @meta:    metadata
+ *
+ * This structure contains the informations about the data to transfer to the
+ * hw device.
+ */
+struct cparsers_buffer_info {
+	void *au_addr;
+	unsigned int au_size;
+	struct v4l2_ext_control metas[CPARSERS_MAX_METAS];
+	unsigned int nb_of_metas;
+};
+
+/*
+ * struct cparsers_plugin
+ *
+ * @driver_name: keep track of driver name which need parser
+ * @parser: the parser backend wich decode metadata from stream
+ * @buffer_info: a pointer on a buffer_info struct
+ * @buffer_nb: number of buffer_info created by the ioctl command reqbufs
+ *
+ * This structure is used throught the calls to the ioctl cparsers commands
+ * It is used to keep in memory informations concerning the allocated buffers
+ * to better control the data and metadata flux
+ *
+ */
+struct cparsers_plugin {
+	__u8 driver_name[16];
+	const struct meta_parser *parser;
+	struct cparsers_buffer_info *buffer_info;
+	unsigned int buffer_nb;
+	unsigned int request_id;
+};
+
+#endif /* LIBV4L_CPARSERS_H */
+
+/* enable or disable the debug trace */
+/* #define HAVE_TRACE */
+
+#ifdef HAVE_TRACE
+#define CPARSERS_LOG_DEBUG(...) \
+	do { \
+		fprintf(stdout, "libv4l-cparsers/dbg " __VA_ARGS__); \
+	} while (0)
+#else
+#define CPARSERS_LOG_DEBUG(...)
+#endif
diff --git a/lib/libv4l-hva/Makefile.am b/lib/libv4l-hva/Makefile.am
new file mode 100644
index 0000000..c5e4459
--- /dev/null
+++ b/lib/libv4l-hva/Makefile.am
@@ -0,0 +1,32 @@
+if WITH_V4L_PLUGINS
+libv4l2plugin_LTLIBRARIES = libv4l-hva.la
+endif
+
+libv4l_hva_la_SOURCES = libv4l-hva.c
+
+##### H264 encoder #####
+libv4l_hva_la_SOURCES += libv4l-hva-h264.c
+
+##### gst library #####
+libv4l_hva_la_SOURCES += \
+	gst/base/gstbitwriter.c \
+	gst/vaapi/gstvaapiutils_h264.c \
+	gst/vaapi/gstvaapiencoder_h264.c
+
+libv4l_hva_la_CPPFLAGS = $(CFLAG_VISIBILITY) \
+	-I$(srcdir)/va \
+	-DHVA_DEBUG
+
+libv4l_hva_la_LIBADD = ../libv4l2/libv4l2.la
+
+libv4l_hva_la_CFLAGS = $(GST_CFLAGS) -DGST_USE_UNSTABLE_API -DIN_LIBGSTVAAPI
+
+libv4l_hva_la_LDFLAGS = -avoid-version -module -shared -export-dynamic -lpthread
+
+libv4l_hva_la_LDFLAGS += $(GST_LIB_LDFLAGS)
+
+libv4l_hva_la_LIBADD = ../libv4l2/libv4l2.la \
+	$(GLIB_LIBS) \
+	$(GST_BASE_LIBS) \
+	$(GST_LIBS) \
+	$(NULL)
diff --git a/lib/libv4l-hva/gst/base/gstbitwriter.c b/lib/libv4l-hva/gst/base/gstbitwriter.c
new file mode 100644
index 0000000..5fbb2fa
--- /dev/null
+++ b/lib/libv4l-hva/gst/base/gstbitwriter.c
@@ -0,0 +1,278 @@
+/*
+ *  gstbitwriter.c - bitstream writer
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#define GST_BIT_WRITER_DISABLE_INLINES
+
+#include "gstbitwriter.h"
+
+/**
+ * gst_bit_writer_init:
+ * @bitwriter: a #GstBitWriter instance
+ * @reserved_bits: reserved bits to allocate data
+ *
+ * Initializes a #GstBitWriter instance and allocate @reserved_bits
+ * data inside.
+ *
+ * Cleanup function: gst_bit_writer_clear
+ */
+void
+gst_bit_writer_init (GstBitWriter * bitwriter, guint32 reserved_bits)
+{
+  bitwriter->bit_size = 0;
+  bitwriter->data = NULL;
+  bitwriter->bit_capacity = 0;
+  bitwriter->auto_grow = TRUE;
+  if (reserved_bits)
+    _gst_bit_writer_check_space (bitwriter, reserved_bits);
+}
+
+/**
+ * gst_bit_writer_init_fill:
+ * @bitwriter: a #GstBitWriter instance
+ * @data: allocated data
+  * @bits: size of allocated @data in bits
+ *
+ * Initializes a #GstBitWriter instance with alocated @data and @bit outside.
+ *
+ * Cleanup function: gst_bit_writer_clear
+ */
+void
+gst_bit_writer_init_fill (GstBitWriter * bitwriter, guint8 * data, guint bits)
+{
+  bitwriter->bit_size = 0;
+  bitwriter->data = data;
+  bitwriter->bit_capacity = bits;
+  bitwriter->auto_grow = FALSE;
+}
+
+/**
+ * gst_bit_writer_clear:
+ * @bitwriter: a #GstBitWriter instance
+ * @free_data: flag to free #GstBitWriter allocated data
+ *
+ * Clear a #GstBitWriter instance and destroy allocated data inside
+ * if @free_data is %TRUE.
+ */
+void
+gst_bit_writer_clear (GstBitWriter * bitwriter, gboolean free_data)
+{
+  if (bitwriter->auto_grow && bitwriter->data && free_data)
+    g_free (bitwriter->data);
+
+  bitwriter->data = NULL;
+  bitwriter->bit_size = 0;
+  bitwriter->bit_capacity = 0;
+}
+
+/**
+ * gst_bit_writer_new:
+ * @bitwriter: a #GstBitWriter instance
+ * @reserved_bits: reserved bits to allocate data
+ *
+ * Create a #GstBitWriter instance and allocate @reserved_bits data inside.
+ *
+ * Free-function: gst_bit_writer_free
+ *
+ * Returns: a new #GstBitWriter instance
+ */
+GstBitWriter *
+gst_bit_writer_new (guint32 reserved_bits)
+{
+  GstBitWriter *ret = g_slice_new0 (GstBitWriter);
+
+  gst_bit_writer_init (ret, reserved_bits);
+
+  return ret;
+}
+
+/**
+ * gst_bit_writer_new_fill:
+ * @bitwriter: a #GstBitWriter instance
+ * @data: allocated data
+ * @bits: size of allocated @data in bits
+ *
+ * Create a #GstBitWriter instance with allocated @data and @bit outside.
+ *
+ * Free-function: gst_bit_writer_free
+ *
+ * Returns: a new #GstBitWriter instance
+ */
+GstBitWriter *
+gst_bit_writer_new_fill (guint8 * data, guint bits)
+{
+  GstBitWriter *ret = g_slice_new0 (GstBitWriter);
+
+  gst_bit_writer_init_fill (ret, data, bits);
+
+  return ret;
+}
+
+/**
+ * gst_bit_writer_free:
+ * @bitwriter: a #GstBitWriter instance
+ * @free_data:  flag to free @data which is allocated inside
+ *
+ * Clear a #GstBitWriter instance and destroy allocated data inside if
+ * @free_data is %TRUE
+ */
+void
+gst_bit_writer_free (GstBitWriter * writer, gboolean free_data)
+{
+  g_return_if_fail (writer != NULL);
+
+  gst_bit_writer_clear (writer, free_data);
+
+  g_slice_free (GstBitWriter, writer);
+}
+
+/**
+ * gst_bit_writer_get_size:
+ * @bitwriter: a #GstBitWriter instance
+ *
+ * Get size of written @data
+ *
+ * Returns: size of bits written in @data
+ */
+guint
+gst_bit_writer_get_size (GstBitWriter * bitwriter)
+{
+  return _gst_bit_writer_get_size_inline (bitwriter);
+}
+
+/**
+ * gst_bit_writer_get_data:
+ * @bitwriter: a #GstBitWriter instance
+ *
+ * Get written @data pointer
+ *
+ * Returns: @data pointer
+ */
+guint8 *
+gst_bit_writer_get_data (GstBitWriter * bitwriter)
+{
+  return _gst_bit_writer_get_data_inline (bitwriter);
+}
+
+/**
+ * gst_bit_writer_get_data:
+ * @bitwriter: a #GstBitWriter instance
+ * @pos: new position of data end
+ *
+ * Set the new postion of data end which should be the new size of @data.
+ *
+ * Returns: %TRUE if successful, %FALSE otherwise
+ */
+gboolean
+gst_bit_writer_set_pos (GstBitWriter * bitwriter, guint pos)
+{
+  return _gst_bit_writer_set_pos_inline (bitwriter, pos);
+}
+
+/**
+ * gst_bit_writer_put_bits_uint8:
+ * @bitwriter: a #GstBitWriter instance
+ * @value: value of #guint8 to write
+ * @nbits: number of bits to write
+ *
+ * Write @nbits bits of @value to #GstBitWriter.
+ *
+ * Returns: %TRUE if successful, %FALSE otherwise.
+ */
+
+/**
+ * gst_bit_writer_put_bits_uint16:
+ * @bitwriter: a #GstBitWriter instance
+ * @value: value of #guint16 to write
+ * @nbits: number of bits to write
+ *
+ * Write @nbits bits of @value to #GstBitWriter.
+ *
+ * Returns: %TRUE if successful, %FALSE otherwise.
+ */
+
+/**
+ * gst_bit_writer_put_bits_uint32:
+ * @bitwriter: a #GstBitWriter instance
+ * @value: value of #guint32 to write
+ * @nbits: number of bits to write
+ *
+ * Write @nbits bits of @value to #GstBitWriter.
+ *
+ * Returns: %TRUE if successful, %FALSE otherwise.
+ */
+
+/**
+ * gst_bit_writer_put_bits_uint64:
+ * @bitwriter: a #GstBitWriter instance
+ * @value: value of #guint64 to write
+ * @nbits: number of bits to write
+ *
+ * Write @nbits bits of @value to #GstBitWriter.
+ *
+ * Returns: %TRUE if successful, %FALSE otherwise.
+ */
+
+#define GST_BIT_WRITER_WRITE_BITS(bits) \
+gboolean \
+gst_bit_writer_put_bits_uint##bits (GstBitWriter *bitwriter, guint##bits value, guint nbits) \
+{ \
+  return _gst_bit_writer_put_bits_uint##bits##_inline (bitwriter, value, nbits); \
+}
+
+GST_BIT_WRITER_WRITE_BITS (8)
+GST_BIT_WRITER_WRITE_BITS (16)
+GST_BIT_WRITER_WRITE_BITS (32)
+GST_BIT_WRITER_WRITE_BITS (64)
+
+#undef GST_BIT_WRITER_WRITE_BITS
+
+/**
+ * gst_bit_writer_put_bytes:
+ * @bitwriter: a #GstBitWriter instance
+ * @data: pointer of data to write
+ * @nbytes: number of bytes to write
+ *
+ * Write @nbytes bytes of @data to #GstBitWriter.
+ *
+ * Returns: %TRUE if successful, %FALSE otherwise.
+ */
+gboolean
+gst_bit_writer_put_bytes (GstBitWriter * bitwriter,
+    const guint8 * data, guint nbytes)
+{
+  return _gst_bit_writer_put_bytes_inline (bitwriter, data, nbytes);
+}
+
+/**
+ * gst_bit_writer_align_bytes:
+ * @bitwriter: a #GstBitWriter instance
+ * @trailing_bit: trailing bits of last byte, 0 or 1
+ *
+ * Write trailing bit to align last byte of @data. @trailing_bit can
+ * only be 1 or 0.
+ *
+ * Returns: %TRUE if successful, %FALSE otherwise.
+ */
+gboolean
+gst_bit_writer_align_bytes (GstBitWriter * bitwriter, guint8 trailing_bit)
+{
+  return _gst_bit_writer_align_bytes_inline (bitwriter, trailing_bit);
+}
diff --git a/lib/libv4l-hva/gst/base/gstbitwriter.h b/lib/libv4l-hva/gst/base/gstbitwriter.h
new file mode 100644
index 0000000..02ceeab
--- /dev/null
+++ b/lib/libv4l-hva/gst/base/gstbitwriter.h
@@ -0,0 +1,361 @@
+/*
+ *  gstbitwriter.h - bitstream writer
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_BIT_WRITER_H
+#define GST_BIT_WRITER_H
+
+#include <gst/gst.h>
+#include <string.h>
+
+G_BEGIN_DECLS
+
+#define GST_BIT_WRITER_DATA(writer)     ((writer)->data)
+#define GST_BIT_WRITER_BIT_SIZE(writer) ((writer)->bit_size)
+#define GST_BIT_WRITER(writer)          ((GstBitWriter *) (writer))
+
+typedef struct _GstBitWriter GstBitWriter;
+
+/**
+ * GstBitWriter:
+ * @data: Allocated @data for bit writer to write
+ * @bit_size: Size of written @data in bits
+ *
+ * Private:
+ * @bit_capacity: Capacity of the allocated @data
+ * @auto_grow: @data space can auto grow
+ *
+ * A bit writer instance.
+ */
+struct _GstBitWriter
+{
+  guint8 *data;
+  guint bit_size;
+
+  /*< private >*/
+  guint bit_capacity;
+  gboolean auto_grow;
+  gpointer _gst_reserved[GST_PADDING];
+};
+
+GstBitWriter *
+gst_bit_writer_new (guint32 reserved_bits) G_GNUC_MALLOC;
+
+GstBitWriter *
+gst_bit_writer_new_fill (guint8 * data, guint bits) G_GNUC_MALLOC;
+
+void
+gst_bit_writer_free (GstBitWriter * writer, gboolean free_data);
+
+void
+gst_bit_writer_init (GstBitWriter * bitwriter, guint32 reserved_bits);
+
+void
+gst_bit_writer_init_fill (GstBitWriter * bitwriter, guint8 * data, guint bits);
+
+void
+gst_bit_writer_clear (GstBitWriter * bitwriter, gboolean free_data);
+
+guint
+gst_bit_writer_get_size (GstBitWriter * bitwriter);
+
+guint8 *
+gst_bit_writer_get_data (GstBitWriter * bitwriter);
+
+gboolean
+gst_bit_writer_set_pos (GstBitWriter * bitwriter, guint pos);
+
+guint
+gst_bit_writer_get_space (GstBitWriter * bitwriter);
+
+gboolean
+gst_bit_writer_put_bits_uint8 (GstBitWriter * bitwriter,
+                               guint8 value, guint nbits);
+
+gboolean
+gst_bit_writer_put_bits_uint16 (GstBitWriter * bitwriter,
+                                guint16 value, guint nbits);
+
+gboolean
+gst_bit_writer_put_bits_uint32 (GstBitWriter * bitwriter,
+                                guint32 value, guint nbits);
+
+gboolean
+gst_bit_writer_put_bits_uint64 (GstBitWriter * bitwriter,
+                                guint64 value, guint nbits);
+
+gboolean
+gst_bit_writer_put_bytes (GstBitWriter * bitwriter, const guint8 * data,
+    guint nbytes);
+
+gboolean
+gst_bit_writer_align_bytes (GstBitWriter * bitwriter, guint8 trailing_bit);
+
+static const guint8 _gst_bit_writer_bit_filling_mask[9] = {
+    0x00, 0x01, 0x03, 0x07,
+    0x0F, 0x1F, 0x3F, 0x7F,
+    0xFF
+};
+
+/* Aligned to 256 bytes */
+#define __GST_BITS_WRITER_ALIGNMENT_MASK 2047
+#define __GST_BITS_WRITER_ALIGNED(bitsize)                   \
+    (((bitsize) + __GST_BITS_WRITER_ALIGNMENT_MASK)&(~__GST_BITS_WRITER_ALIGNMENT_MASK))
+
+static inline gboolean
+_gst_bit_writer_check_space (GstBitWriter * bitwriter, guint32 bits)
+{
+  guint32 new_bit_size = bits + bitwriter->bit_size;
+  guint32 clear_pos;
+
+  g_assert (bitwriter->bit_size <= bitwriter->bit_capacity);
+  if (new_bit_size <= bitwriter->bit_capacity)
+    return TRUE;
+
+  if (!bitwriter->auto_grow)
+    return FALSE;
+
+  /* auto grow space */
+  new_bit_size = __GST_BITS_WRITER_ALIGNED (new_bit_size);
+  g_assert (new_bit_size
+      && ((new_bit_size & __GST_BITS_WRITER_ALIGNMENT_MASK) == 0));
+  clear_pos = ((bitwriter->bit_size + 7) >> 3);
+  bitwriter->data = g_realloc (bitwriter->data, (new_bit_size >> 3));
+  memset (bitwriter->data + clear_pos, 0, (new_bit_size >> 3) - clear_pos);
+  bitwriter->bit_capacity = new_bit_size;
+  return TRUE;
+}
+
+#undef __GST_BITS_WRITER_ALIGNMENT_MASK
+#undef __GST_BITS_WRITER_ALIGNED
+
+#define __GST_BIT_WRITER_WRITE_BITS_UNCHECKED(bits) \
+static inline void \
+gst_bit_writer_put_bits_uint##bits##_unchecked( \
+    GstBitWriter *bitwriter, \
+    guint##bits value, \
+    guint nbits \
+) \
+{ \
+    guint byte_pos, bit_offset; \
+    guint8  *cur_byte; \
+    guint fill_bits; \
+    \
+    byte_pos = (bitwriter->bit_size >> 3); \
+    bit_offset = (bitwriter->bit_size & 0x07); \
+    cur_byte = bitwriter->data + byte_pos; \
+    g_assert (nbits <= bits); \
+    g_assert( bit_offset < 8 && \
+            bitwriter->bit_size <= bitwriter->bit_capacity); \
+    \
+    while (nbits) { \
+        fill_bits = ((8 - bit_offset) < nbits ? (8 - bit_offset) : nbits); \
+        nbits -= fill_bits; \
+        bitwriter->bit_size += fill_bits; \
+        \
+        *cur_byte |= (((value >> nbits) & _gst_bit_writer_bit_filling_mask[fill_bits]) \
+                      << (8 - bit_offset - fill_bits)); \
+        ++cur_byte; \
+        bit_offset = 0; \
+    } \
+    g_assert(cur_byte <= \
+           (bitwriter->data + (bitwriter->bit_capacity >> 3))); \
+}
+
+__GST_BIT_WRITER_WRITE_BITS_UNCHECKED (8)
+__GST_BIT_WRITER_WRITE_BITS_UNCHECKED (16)
+__GST_BIT_WRITER_WRITE_BITS_UNCHECKED (32)
+__GST_BIT_WRITER_WRITE_BITS_UNCHECKED (64)
+#undef __GST_BIT_WRITER_WRITE_BITS_UNCHECKED
+
+static inline guint
+gst_bit_writer_get_size_unchecked (GstBitWriter * bitwriter)
+{
+  return GST_BIT_WRITER_BIT_SIZE (bitwriter);
+}
+
+static inline guint8 *
+gst_bit_writer_get_data_unchecked (GstBitWriter * bitwriter)
+{
+  return GST_BIT_WRITER_DATA (bitwriter);
+}
+
+static inline gboolean
+gst_bit_writer_set_pos_unchecked (GstBitWriter * bitwriter, guint pos)
+{
+  GST_BIT_WRITER_BIT_SIZE (bitwriter) = pos;
+  return TRUE;
+}
+
+static inline guint
+gst_bit_writer_get_space_unchecked (GstBitWriter * bitwriter)
+{
+  return bitwriter->bit_capacity - bitwriter->bit_size;
+}
+
+static inline void
+gst_bit_writer_put_bytes_unchecked (GstBitWriter * bitwriter,
+    const guint8 * data, guint nbytes)
+{
+  if ((bitwriter->bit_size & 0x07) == 0) {
+    memcpy (&bitwriter->data[bitwriter->bit_size >> 3], data, nbytes);
+    bitwriter->bit_size += (nbytes << 3);
+  } else {
+    g_assert (0);
+    while (nbytes) {
+      gst_bit_writer_put_bits_uint8_unchecked (bitwriter, *data, 8);
+      --nbytes;
+      ++data;
+    }
+  }
+}
+
+static inline void
+gst_bit_writer_align_bytes_unchecked (GstBitWriter * bitwriter,
+    guint8 trailing_bit)
+{
+  guint32 bit_offset, bit_left;
+  guint8 value = 0;
+
+  bit_offset = (bitwriter->bit_size & 0x07);
+  if (!bit_offset)
+    return;
+
+  bit_left = 8 - bit_offset;
+  if (trailing_bit)
+    value = _gst_bit_writer_bit_filling_mask[bit_left];
+  return gst_bit_writer_put_bits_uint8_unchecked (bitwriter, value, bit_left);
+}
+
+#define __GST_BIT_WRITER_WRITE_BITS_INLINE(bits) \
+static inline gboolean \
+_gst_bit_writer_put_bits_uint##bits##_inline( \
+    GstBitWriter *bitwriter, \
+    guint##bits value, \
+    guint nbits \
+) \
+{ \
+    g_return_val_if_fail(bitwriter != NULL, FALSE); \
+    g_return_val_if_fail(nbits != 0, FALSE); \
+    g_return_val_if_fail(nbits <= bits, FALSE); \
+    \
+    if (!_gst_bit_writer_check_space(bitwriter, nbits)) \
+        return FALSE; \
+    gst_bit_writer_put_bits_uint##bits##_unchecked(bitwriter, value, nbits); \
+    return TRUE; \
+}
+
+__GST_BIT_WRITER_WRITE_BITS_INLINE (8)
+__GST_BIT_WRITER_WRITE_BITS_INLINE (16)
+__GST_BIT_WRITER_WRITE_BITS_INLINE (32)
+__GST_BIT_WRITER_WRITE_BITS_INLINE (64)
+#undef __GST_BIT_WRITER_WRITE_BITS_INLINE
+
+static inline guint
+_gst_bit_writer_get_size_inline (GstBitWriter * bitwriter)
+{
+  g_return_val_if_fail (bitwriter != NULL, 0);
+
+  return gst_bit_writer_get_size_unchecked (bitwriter);
+}
+
+static inline guint8 *
+_gst_bit_writer_get_data_inline (GstBitWriter * bitwriter)
+{
+  g_return_val_if_fail (bitwriter != NULL, NULL);
+
+  return gst_bit_writer_get_data_unchecked (bitwriter);
+}
+
+static inline gboolean
+_gst_bit_writer_set_pos_inline (GstBitWriter * bitwriter, guint pos)
+{
+  g_return_val_if_fail (bitwriter != NULL, FALSE);
+  g_return_val_if_fail (pos <= bitwriter->bit_capacity, FALSE);
+
+  return gst_bit_writer_set_pos_unchecked (bitwriter, pos);
+}
+
+static inline guint
+_gst_bit_writer_get_space_inline (GstBitWriter * bitwriter)
+{
+  g_return_val_if_fail (bitwriter != NULL, 0);
+  g_return_val_if_fail (bitwriter->bit_size < bitwriter->bit_capacity, 0);
+
+  return gst_bit_writer_get_space_unchecked (bitwriter);
+}
+
+static inline gboolean
+_gst_bit_writer_put_bytes_inline (GstBitWriter * bitwriter,
+    const guint8 * data, guint nbytes)
+{
+  g_return_val_if_fail (bitwriter != NULL, FALSE);
+  g_return_val_if_fail (data != NULL, FALSE);
+  g_return_val_if_fail (nbytes, FALSE);
+
+  if (!_gst_bit_writer_check_space (bitwriter, nbytes * 8))
+    return FALSE;
+
+  gst_bit_writer_put_bytes_unchecked (bitwriter, data, nbytes);
+  return TRUE;
+}
+
+static inline gboolean
+_gst_bit_writer_align_bytes_inline (GstBitWriter * bitwriter,
+    guint8 trailing_bit)
+{
+  g_return_val_if_fail (bitwriter != NULL, FALSE);
+  g_return_val_if_fail ((trailing_bit == 0 || trailing_bit == 1), FALSE);
+  g_return_val_if_fail (((bitwriter->bit_size + 7) & (~7)) <=
+      bitwriter->bit_capacity, FALSE);
+
+  gst_bit_writer_align_bytes_unchecked (bitwriter, trailing_bit);
+  return TRUE;
+}
+
+#ifndef GST_BIT_WRITER_DISABLE_INLINES
+#define gst_bit_writer_get_size(bitwriter) \
+    _gst_bit_writer_get_size_inline(bitwriter)
+#define gst_bit_writer_get_data(bitwriter) \
+    _gst_bit_writer_get_data_inline(bitwriter)
+#define gst_bit_writer_set_pos(bitwriter, pos) \
+    G_LIKELY (_gst_bit_writer_set_pos_inline (bitwriter, pos))
+#define gst_bit_writer_get_space(bitwriter) \
+    _gst_bit_writer_get_space_inline(bitwriter)
+
+#define gst_bit_writer_put_bits_uint8(bitwriter, value, nbits) \
+    G_LIKELY (_gst_bit_writer_put_bits_uint8_inline (bitwriter, value, nbits))
+#define gst_bit_writer_put_bits_uint16(bitwriter, value, nbits) \
+    G_LIKELY (_gst_bit_writer_put_bits_uint16_inline (bitwriter, value, nbits))
+#define gst_bit_writer_put_bits_uint32(bitwriter, value, nbits) \
+    G_LIKELY (_gst_bit_writer_put_bits_uint32_inline (bitwriter, value, nbits))
+#define gst_bit_writer_put_bits_uint64(bitwriter, value, nbits) \
+    G_LIKELY (_gst_bit_writer_put_bits_uint64_inline (bitwriter, value, nbits))
+
+#define gst_bit_writer_put_bytes(bitwriter, data, nbytes) \
+    G_LIKELY (_gst_bit_writer_put_bytes_inline (bitwriter, data, nbytes))
+
+#define gst_bit_writer_align_bytes(bitwriter, trailing_bit) \
+    G_LIKELY (_gst_bit_writer_align_bytes_inline(bitwriter, trailing_bit))
+#endif
+
+G_END_DECLS
+
+#endif /* GST_BIT_WRITER_H */
diff --git a/lib/libv4l-hva/gst/codecparsers/gsth264parser.h b/lib/libv4l-hva/gst/codecparsers/gsth264parser.h
new file mode 100644
index 0000000..8b2ff65
--- /dev/null
+++ b/lib/libv4l-hva/gst/codecparsers/gsth264parser.h
@@ -0,0 +1,807 @@
+/* Gstreamer
+ * Copyright (C) <2011> Intel Corporation
+ * Copyright (C) <2011> Collabora Ltd.
+ * Copyright (C) <2011> Thibault Saunier <thibault.saunier@collabora.com>
+ *
+ * Some bits C-c,C-v'ed and s/4/3 from h264parse and videoparsers/h264parse.c:
+ *    Copyright (C) <2010> Mark Nauwelaerts <mark.nauwelaerts@collabora.co.uk>
+ *    Copyright (C) <2010> Collabora Multimedia
+ *    Copyright (C) <2010> Nokia Corporation
+ *
+ *    (C) 2005 Michal Benes <michal.benes@itonis.tv>
+ *    (C) 2008 Wim Taymans <wim.taymans@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_H264_PARSER_H__
+#define __GST_H264_PARSER_H__
+
+#ifndef GST_USE_UNSTABLE_API
+#warning "The H.264 parsing library is unstable API and may change in future."
+#warning "You can define GST_USE_UNSTABLE_API to avoid this warning."
+#endif
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define GST_H264_MAX_SPS_COUNT   32
+#define GST_H264_MAX_PPS_COUNT   256
+
+#define GST_H264_IS_P_SLICE(slice)  (((slice)->type % 5) == GST_H264_P_SLICE)
+#define GST_H264_IS_B_SLICE(slice)  (((slice)->type % 5) == GST_H264_B_SLICE)
+#define GST_H264_IS_I_SLICE(slice)  (((slice)->type % 5) == GST_H264_I_SLICE)
+#define GST_H264_IS_SP_SLICE(slice) (((slice)->type % 5) == GST_H264_SP_SLICE)
+#define GST_H264_IS_SI_SLICE(slice) (((slice)->type % 5) == GST_H264_SI_SLICE)
+
+/**
+ * GstH264Profile:
+ * @GST_H264_PROFILE_BASELINE: Baseline profile (A.2.1)
+ * @GST_H264_PROFILE_MAIN: Main profile (A.2.2)
+ * @GST_H264_PROFILE_EXTENDED: Extended profile (A.2.3)
+ * @GST_H264_PROFILE_HIGH: High profile (A.2.4)
+ * @GST_H264_PROFILE_HIGH10: High 10 profile (A.2.5) or High 10 Intra
+ *   profile (A.2.8), depending on constraint_set3_flag
+ * @GST_H264_PROFILE_HIGH_422: High 4:2:2 profile (A.2.6) or High
+ *   4:2:2 Intra profile (A.2.9), depending on constraint_set3_flag
+ * @GST_H264_PROFILE_HIGH_444: High 4:4:4 Predictive profile (A.2.7)
+ *   or High 4:4:4 Intra profile (A.2.10), depending on the value of
+ *   constraint_set3_flag
+ * @GST_H264_PROFILE_MULTIVIEW_HIGH: Multiview High profile (H.10.1.1)
+ * @GST_H264_PROFILE_STEREO_HIGH: Stereo High profile (H.10.1.2)
+ * @GST_H264_PROFILE_SCALABLE_BASELINE: Scalable Baseline profile (G.10.1.1)
+ * @GST_H264_PROFILE_SCALABLE_HIGH: Scalable High profile (G.10.1.2)
+ *   or Scalable High Intra profile (G.10.1.3), depending on the value
+ *   of constraint_set3_flag
+ *
+ * H.264 Profiles.
+ *
+ * Since: 1.2
+ */
+typedef enum {
+  GST_H264_PROFILE_BASELINE             = 66,
+  GST_H264_PROFILE_MAIN                 = 77,
+  GST_H264_PROFILE_EXTENDED             = 88,
+  GST_H264_PROFILE_HIGH                 = 100,
+  GST_H264_PROFILE_HIGH10               = 110,
+  GST_H264_PROFILE_HIGH_422             = 122,
+  GST_H264_PROFILE_HIGH_444             = 244,
+  GST_H264_PROFILE_MULTIVIEW_HIGH       = 118,
+  GST_H264_PROFILE_STEREO_HIGH          = 128,
+  GST_H264_PROFILE_SCALABLE_BASELINE    = 83,
+  GST_H264_PROFILE_SCALABLE_HIGH        = 86
+} GstH264Profile;
+
+/**
+ * GstH264NalUnitType:
+ * @GST_H264_NAL_UNKNOWN: Unknown nal type
+ * @GST_H264_NAL_SLICE: Slice nal
+ * @GST_H264_NAL_SLICE_DPA: DPA slice nal
+ * @GST_H264_NAL_SLICE_DPB: DPB slice nal
+ * @GST_H264_NAL_SLICE_DPC: DPC slice nal
+ * @GST_H264_NAL_SLICE_IDR: DPR slice nal
+ * @GST_H264_NAL_SEI: Supplemental enhancement information (SEI) nal unit
+ * @GST_H264_NAL_SPS: Sequence parameter set (SPS) nal unit
+ * @GST_H264_NAL_PPS: Picture parameter set (PPS) nal unit
+ * @GST_H264_NAL_AU_DELIMITER: Access unit (AU) delimiter nal unit
+ * @GST_H264_NAL_SEQ_END: End of sequence nal unit
+ * @GST_H264_NAL_STREAM_END: End of stream nal unit
+ * @GST_H264_NAL_FILLER_DATA: Filler data nal lunit
+ * @GST_H264_NAL_SPS_EXT: Sequence parameter set (SPS) extension NAL unit
+ * @GST_H264_NAL_PREFIX_UNIT: Prefix NAL unit
+ * @GST_H264_NAL_SUBSET_SPS: Subset sequence parameter set (SPS) NAL unit
+ * @GST_H264_NAL_SLICE_AUX: Auxiliary coded picture without partitioning NAL unit
+ * @GST_H264_NAL_SLICE_EXT: Coded slice extension NAL unit
+ *
+ * Indicates the type of H264 Nal Units
+ */
+typedef enum
+{
+  GST_H264_NAL_UNKNOWN      = 0,
+  GST_H264_NAL_SLICE        = 1,
+  GST_H264_NAL_SLICE_DPA    = 2,
+  GST_H264_NAL_SLICE_DPB    = 3,
+  GST_H264_NAL_SLICE_DPC    = 4,
+  GST_H264_NAL_SLICE_IDR    = 5,
+  GST_H264_NAL_SEI          = 6,
+  GST_H264_NAL_SPS          = 7,
+  GST_H264_NAL_PPS          = 8,
+  GST_H264_NAL_AU_DELIMITER = 9,
+  GST_H264_NAL_SEQ_END      = 10,
+  GST_H264_NAL_STREAM_END   = 11,
+  GST_H264_NAL_FILLER_DATA  = 12,
+  GST_H264_NAL_SPS_EXT      = 13,
+  GST_H264_NAL_PREFIX_UNIT  = 14,
+  GST_H264_NAL_SUBSET_SPS   = 15,
+  GST_H264_NAL_SLICE_AUX    = 19,
+  GST_H264_NAL_SLICE_EXT    = 20
+} GstH264NalUnitType;
+
+/**
+ * GstH264ParserResult:
+ * @GST_H264_PARSER_OK: The parsing succeded
+ * @GST_H264_PARSER_BROKEN_DATA: The data to parse is broken
+ * @GST_H264_PARSER_BROKEN_LINK: The link to structure needed for the parsing couldn't be found
+ * @GST_H264_PARSER_ERROR: An error accured when parsing
+ * @GST_H264_PARSER_NO_NAL: No nal found during the parsing
+ * @GST_H264_PARSER_NO_NAL_END: Start of the nal found, but not the end.
+ *
+ * The result of parsing H264 data.
+ */
+typedef enum
+{
+  GST_H264_PARSER_OK,
+  GST_H264_PARSER_BROKEN_DATA,
+  GST_H264_PARSER_BROKEN_LINK,
+  GST_H264_PARSER_ERROR,
+  GST_H264_PARSER_NO_NAL,
+  GST_H264_PARSER_NO_NAL_END
+} GstH264ParserResult;
+
+/**
+ * GstH264SEIPayloadType:
+ * @GST_H264_SEI_BUF_PERIOD: Buffering Period SEI Message
+ * @GST_H264_SEI_PIC_TIMING: Picture Timing SEI Message
+ * @GST_H264_SEI_RECOVERY_POINT: Recovery Point SEI Message (D.2.7)
+ * ...
+ *
+ * The type of SEI message.
+ */
+typedef enum
+{
+  GST_H264_SEI_BUF_PERIOD = 0,
+  GST_H264_SEI_PIC_TIMING = 1,
+  GST_H264_SEI_RECOVERY_POINT = 6,
+      /* and more...  */
+} GstH264SEIPayloadType;
+
+/**
+ * GstH264SEIPicStructType:
+ * @GST_H264_SEI_PIC_STRUCT_FRAME: Picture is a frame
+ * @GST_H264_SEI_PIC_STRUCT_TOP_FIELD: Top field of frame
+ * @GST_H264_SEI_PIC_STRUCT_BOTTOM_FIELD: Botom field of frame
+ * @GST_H264_SEI_PIC_STRUCT_TOP_BOTTOM: Top bottom field of frame
+ * @GST_H264_SEI_PIC_STRUCT_BOTTOM_TOP: bottom top field of frame
+ * @GST_H264_SEI_PIC_STRUCT_TOP_BOTTOM_TOP: top bottom top field of frame
+ * @GST_H264_SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM: bottom top bottom field of frame
+ * @GST_H264_SEI_PIC_STRUCT_FRAME_DOUBLING: indicates that the frame should
+ *  be displayed two times consecutively
+ * @GST_H264_SEI_PIC_STRUCT_FRAME_TRIPLING: indicates that the frame should be
+ *  displayed three times consecutively
+ *
+ * SEI pic_struct type
+ */
+typedef enum
+{
+  GST_H264_SEI_PIC_STRUCT_FRAME             = 0,
+  GST_H264_SEI_PIC_STRUCT_TOP_FIELD         = 1,
+  GST_H264_SEI_PIC_STRUCT_BOTTOM_FIELD      = 2,
+  GST_H264_SEI_PIC_STRUCT_TOP_BOTTOM        = 3,
+  GST_H264_SEI_PIC_STRUCT_BOTTOM_TOP        = 4,
+  GST_H264_SEI_PIC_STRUCT_TOP_BOTTOM_TOP    = 5,
+  GST_H264_SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM = 6,
+  GST_H264_SEI_PIC_STRUCT_FRAME_DOUBLING    = 7,
+  GST_H264_SEI_PIC_STRUCT_FRAME_TRIPLING    = 8
+} GstH264SEIPicStructType;
+
+/**
+ * GstH264SliceType:
+ *
+ * Type of Picture slice
+ */
+
+typedef enum
+{
+  GST_H264_P_SLICE    = 0,
+  GST_H264_B_SLICE    = 1,
+  GST_H264_I_SLICE    = 2,
+  GST_H264_SP_SLICE   = 3,
+  GST_H264_SI_SLICE   = 4,
+  GST_H264_S_P_SLICE  = 5,
+  GST_H264_S_B_SLICE  = 6,
+  GST_H264_S_I_SLICE  = 7,
+  GST_H264_S_SP_SLICE = 8,
+  GST_H264_S_SI_SLICE = 9
+} GstH264SliceType;
+
+typedef struct _GstH264NalParser              GstH264NalParser;
+
+typedef struct _GstH264NalUnit                GstH264NalUnit;
+
+typedef struct _GstH264SPS                    GstH264SPS;
+typedef struct _GstH264PPS                    GstH264PPS;
+typedef struct _GstH264HRDParams              GstH264HRDParams;
+typedef struct _GstH264VUIParams              GstH264VUIParams;
+
+typedef struct _GstH264RefPicListModification GstH264RefPicListModification;
+typedef struct _GstH264DecRefPicMarking       GstH264DecRefPicMarking;
+typedef struct _GstH264RefPicMarking          GstH264RefPicMarking;
+typedef struct _GstH264PredWeightTable        GstH264PredWeightTable;
+typedef struct _GstH264SliceHdr               GstH264SliceHdr;
+
+typedef struct _GstH264ClockTimestamp         GstH264ClockTimestamp;
+typedef struct _GstH264PicTiming              GstH264PicTiming;
+typedef struct _GstH264BufferingPeriod        GstH264BufferingPeriod;
+typedef struct _GstH264RecoveryPoint          GstH264RecoveryPoint;
+typedef struct _GstH264SEIMessage             GstH264SEIMessage;
+
+/**
+ * GstH264NalUnit:
+ * @ref_idc: not equal to 0 specifies that the content of the NAL unit
+ *  contains a sequence parameter set, a sequence parameter set
+ *  extension, a subset sequence parameter set, a picture parameter
+ *  set, a slice of a reference picture, a slice data partition of a
+ *  reference picture, or a prefix NAL unit preceding a slice of a
+ *  reference picture.
+ * @type: A #GstH264NalUnitType
+ * @idr_pic_flag: calculated idr_pic_flag
+ * @size: The size of the nal unit starting from @offset, thus
+ *  including the header bytes. e.g. @type (nal_unit_type)
+ * @offset: The offset of the actual start of the nal unit, thus
+ *  including the header bytes
+ * @sc_offset: The offset of the start code of the nal unit
+ * @valid: If the nal unit is valid, which means it has
+ * already been parsed
+ * @data: The data from which the Nalu has been parsed
+ *
+ * Structure defining the Nal unit headers
+ */
+struct _GstH264NalUnit
+{
+  guint16 ref_idc;
+  guint16 type;
+
+  /* calculated values */
+  guint8 idr_pic_flag;
+  guint size;
+  guint offset;
+  guint sc_offset;
+  gboolean valid;
+
+  guint8 *data;
+};
+
+/**
+ * GstH264HRDParams:
+ * @cpb_cnt_minus1: plus 1 specifies the number of alternative
+ *    CPB specifications in the bitstream
+ * @bit_rate_scale: specifies the maximum input bit rate of the
+ * SchedSelIdx-th CPB
+ * @cpb_size_scale: specifies the CPB size of the SchedSelIdx-th CPB
+ * @guint32 bit_rate_value_minus1: specifies the maximum input bit rate for the
+ * SchedSelIdx-th CPB
+ * @cpb_size_value_minus1: is used together with cpb_size_scale to specify the
+ * SchedSelIdx-th CPB size
+ * @cbr_flag: Specifies if running in itermediate bitrate mode or constant
+ * @initial_cpb_removal_delay_length_minus1: specifies the length in bits of
+ * the cpb_removal_delay syntax element
+ * @cpb_removal_delay_length_minus1: specifies the length in bits of the
+ * dpb_output_delay syntax element
+ * @dpb_output_delay_length_minus1: >0 specifies the length in bits of the time_offset syntax element.
+ * =0 specifies that the time_offset syntax element is not present
+ * @time_offset_length: Length of the time offset
+ *
+ * Defines the HRD parameters
+ */
+struct _GstH264HRDParams
+{
+  guint8 cpb_cnt_minus1;
+  guint8 bit_rate_scale;
+  guint8 cpb_size_scale;
+
+  guint32 bit_rate_value_minus1[32];
+  guint32 cpb_size_value_minus1[32];
+  guint8 cbr_flag[32];
+
+  guint8 initial_cpb_removal_delay_length_minus1;
+  guint8 cpb_removal_delay_length_minus1;
+  guint8 dpb_output_delay_length_minus1;
+  guint8 time_offset_length;
+};
+
+/**
+ * GstH264VUIParams:
+ * @aspect_ratio_info_present_flag: %TRUE specifies that aspect_ratio_idc is present.
+ *  %FALSE specifies that aspect_ratio_idc is not present
+ * @aspect_ratio_idc specifies the value of the sample aspect ratio of the luma samples
+ * @sar_width indicates the horizontal size of the sample aspect ratio
+ * @sar_height indicates the vertical size of the sample aspect ratio
+ * @overscan_info_present_flag: %TRUE overscan_appropriate_flag is present %FALSE otherwize
+ * @overscan_appropriate_flag: %TRUE indicates that the cropped decoded pictures
+ *  output are suitable for display using overscan. %FALSE the cropped decoded pictures
+ *  output contain visually important information
+ * @video_signal_type_present_flag: %TRUE specifies that video_format, video_full_range_flag and
+ *  colour_description_present_flag are present.
+ * @video_format: indicates the representation of the picture
+ * @video_full_range_flag: indicates the black level and range of the luma and chroma signals
+ * @colour_description_present_flag: %TRUE specifies that colour_primaries,
+ *  transfer_characteristics and matrix_coefficients are present
+ * @colour_primaries: indicates the chromaticity coordinates of the source primaries
+ * @transfer_characteristics: indicates the opto-electronic transfer characteristic
+ * @matrix_coefficients: describes the matrix coefficients used in deriving luma and chroma signals
+ * @chroma_loc_info_present_flag: %TRUE specifies that chroma_sample_loc_type_top_field and
+ *  chroma_sample_loc_type_bottom_field are present, %FALSE otherwize
+ * @chroma_sample_loc_type_top_field: specify the location of chroma for top field
+ * @chroma_sample_loc_type_bottom_field specify the location of chroma for bottom field
+ * @timing_info_present_flag: %TRUE specifies that num_units_in_tick,
+ *  time_scale and fixed_frame_rate_flag are present in the bitstream
+ * @num_units_in_tick: is the number of time units of a clock operating at the frequency time_scale Hz
+ * time_scale: is the number of time units that pass in one second
+ * @fixed_frame_rate_flag: %TRUE indicates that the temporal distance between the HRD output times
+ *  of any two consecutive pictures in output order is constrained as specified in the spec, %FALSE
+ *  otherwize.
+ * @nal_hrd_parameters_present_flag: %TRUE if nal hrd parameters present in the bitstream
+ * @vcl_hrd_parameters_present_flag: %TRUE if nal vlc hrd parameters present in the bitstream
+ * @low_delay_hrd_flag: specifies the HRD operational mode
+ * @pic_struct_present_flag: %TRUE specifies that picture timing SEI messages are present or not
+ * @bitstream_restriction_flag: %TRUE specifies that the following coded video sequence bitstream restriction
+ * parameters are present
+ * @motion_vectors_over_pic_boundaries_flag: %FALSE indicates that no sample outside the
+ *  picture boundaries and no sample at a fractional sample position, %TRUE indicates that one or more
+ *  samples outside picture boundaries may be used in inter prediction
+ * @max_bytes_per_pic_denom: indicates a number of bytes not exceeded by the sum of the sizes of
+ *  the VCL NAL units associated with any coded picture in the coded video sequence.
+ * @max_bits_per_mb_denom: indicates the maximum number of coded bits of macroblock_layer
+ * @log2_max_mv_length_horizontal: indicate the maximum absolute value of a decoded horizontal
+ * motion vector component
+ * @log2_max_mv_length_vertical: indicate the maximum absolute value of a decoded vertical
+ *  motion vector component
+ * @num_reorder_frames: indicates the maximum number of frames, complementary field pairs,
+ *  or non-paired fields that precede any frame,
+ * @max_dec_frame_buffering: specifies the required size of the HRD decoded picture buffer in
+ *  units of frame buffers.
+ *
+ * The structure representing the VUI parameters.
+ */
+struct _GstH264VUIParams
+{
+  guint8 aspect_ratio_info_present_flag;
+  guint8 aspect_ratio_idc;
+  /* if aspect_ratio_idc == 255 */
+  guint16 sar_width;
+  guint16 sar_height;
+
+  guint8 overscan_info_present_flag;
+  /* if overscan_info_present_flag */
+  guint8 overscan_appropriate_flag;
+
+  guint8 video_signal_type_present_flag;
+  guint8 video_format;
+  guint8 video_full_range_flag;
+  guint8 colour_description_present_flag;
+  guint8 colour_primaries;
+  guint8 transfer_characteristics;
+  guint8 matrix_coefficients;
+
+  guint8 chroma_loc_info_present_flag;
+  guint8 chroma_sample_loc_type_top_field;
+  guint8 chroma_sample_loc_type_bottom_field;
+
+  guint8 timing_info_present_flag;
+  /* if timing_info_present_flag */
+  guint32 num_units_in_tick;
+  guint32 time_scale;
+  guint8 fixed_frame_rate_flag;
+
+  guint8 nal_hrd_parameters_present_flag;
+  /* if nal_hrd_parameters_present_flag */
+  GstH264HRDParams nal_hrd_parameters;
+
+  guint8 vcl_hrd_parameters_present_flag;
+  /* if vcl_hrd_parameters_present_flag */
+  GstH264HRDParams vcl_hrd_parameters;
+
+  guint8 low_delay_hrd_flag;
+  guint8 pic_struct_present_flag;
+
+  guint8 bitstream_restriction_flag;
+  /*  if bitstream_restriction_flag */
+  guint8 motion_vectors_over_pic_boundaries_flag;
+  guint32 max_bytes_per_pic_denom;
+  guint32 max_bits_per_mb_denom;
+  guint32 log2_max_mv_length_horizontal;
+  guint32 log2_max_mv_length_vertical;
+  guint32 num_reorder_frames;
+  guint32 max_dec_frame_buffering;
+
+  /* calculated values */
+  guint par_n;
+  guint par_d;
+};
+
+/**
+ * GstH264SPS:
+ * @id: The ID of the sequence parameter set
+ * @profile_idc: indicate the profile to which the coded video sequence conforms
+ *
+ * H264 Sequence Parameter Set (SPS)
+ */
+struct _GstH264SPS
+{
+  gint id;
+
+  guint8 profile_idc;
+  guint8 constraint_set0_flag;
+  guint8 constraint_set1_flag;
+  guint8 constraint_set2_flag;
+  guint8 constraint_set3_flag;
+  guint8 level_idc;
+
+  guint8 chroma_format_idc;
+  guint8 separate_colour_plane_flag;
+  guint8 bit_depth_luma_minus8;
+  guint8 bit_depth_chroma_minus8;
+  guint8 qpprime_y_zero_transform_bypass_flag;
+
+  guint8 scaling_matrix_present_flag;
+  guint8 scaling_lists_4x4[6][16];
+  guint8 scaling_lists_8x8[6][64];
+
+  guint8 log2_max_frame_num_minus4;
+  guint8 pic_order_cnt_type;
+
+  /* if pic_order_cnt_type == 0 */
+  guint8 log2_max_pic_order_cnt_lsb_minus4;
+
+  /* else if pic_order_cnt_type == 1 */
+  guint8 delta_pic_order_always_zero_flag;
+  gint32 offset_for_non_ref_pic;
+  gint32 offset_for_top_to_bottom_field;
+  guint8 num_ref_frames_in_pic_order_cnt_cycle;
+  gint32 offset_for_ref_frame[255];
+
+  guint32 num_ref_frames;
+  guint8 gaps_in_frame_num_value_allowed_flag;
+  guint32 pic_width_in_mbs_minus1;
+  guint32 pic_height_in_map_units_minus1;
+  guint8 frame_mbs_only_flag;
+
+  guint8 mb_adaptive_frame_field_flag;
+
+  guint8 direct_8x8_inference_flag;
+
+  guint8 frame_cropping_flag;
+
+  /* if frame_cropping_flag */
+  guint32 frame_crop_left_offset;
+  guint32 frame_crop_right_offset;
+  guint32 frame_crop_top_offset;
+  guint32 frame_crop_bottom_offset;
+
+  guint8 vui_parameters_present_flag;
+  /* if vui_parameters_present_flag */
+  GstH264VUIParams vui_parameters;
+
+  /* calculated values */
+  guint8 chroma_array_type;
+  guint32 max_frame_num;
+  gint width, height;
+  gint crop_rect_width, crop_rect_height;
+  gint crop_rect_x, crop_rect_y;
+  gint fps_num, fps_den;
+  gboolean valid;
+};
+
+/**
+ * GstH264PPS:
+ *
+ * H264 Picture Parameter Set
+ */
+struct _GstH264PPS
+{
+  gint id;
+
+  GstH264SPS *sequence;
+
+  guint8 entropy_coding_mode_flag;
+  guint8 pic_order_present_flag;
+
+  guint32 num_slice_groups_minus1;
+
+  /* if num_slice_groups_minus1 > 0 */
+  guint8 slice_group_map_type;
+  /* and if slice_group_map_type == 0 */
+  guint32 run_length_minus1[8];
+  /* or if slice_group_map_type == 2 */
+  guint32 top_left[8];
+  guint32 bottom_right[8];
+  /* or if slice_group_map_type == (3, 4, 5) */
+  guint8 slice_group_change_direction_flag;
+  guint32 slice_group_change_rate_minus1;
+  /* or if slice_group_map_type == 6 */
+  guint32 pic_size_in_map_units_minus1;
+  guint8 *slice_group_id;
+
+  guint8 num_ref_idx_l0_active_minus1;
+  guint8 num_ref_idx_l1_active_minus1;
+  guint8 weighted_pred_flag;
+  guint8 weighted_bipred_idc;
+  gint8 pic_init_qp_minus26;
+  gint8 pic_init_qs_minus26;
+  gint8 chroma_qp_index_offset;
+  guint8 deblocking_filter_control_present_flag;
+  guint8 constrained_intra_pred_flag;
+  guint8 redundant_pic_cnt_present_flag;
+
+  guint8 transform_8x8_mode_flag;
+
+  guint8 scaling_lists_4x4[6][16];
+  guint8 scaling_lists_8x8[6][64];
+
+  guint8 second_chroma_qp_index_offset;
+
+  gboolean valid;
+};
+
+struct _GstH264RefPicListModification
+{
+  guint8 modification_of_pic_nums_idc;
+  union
+  {
+    /* if modification_of_pic_nums_idc == 0 || 1 */
+    guint32 abs_diff_pic_num_minus1;
+    /* if modification_of_pic_nums_idc == 2 */
+    guint32 long_term_pic_num;
+  } value;
+};
+
+struct _GstH264PredWeightTable
+{
+  guint8 luma_log2_weight_denom;
+  guint8 chroma_log2_weight_denom;
+
+  gint16 luma_weight_l0[32];
+  gint8 luma_offset_l0[32];
+
+  /* if seq->ChromaArrayType != 0 */
+  gint16 chroma_weight_l0[32][2];
+  gint8 chroma_offset_l0[32][2];
+
+  /* if slice->slice_type % 5 == 1 */
+  gint16 luma_weight_l1[32];
+  gint8 luma_offset_l1[32];
+
+  /* and if seq->ChromaArrayType != 0 */
+  gint16 chroma_weight_l1[32][2];
+  gint8 chroma_offset_l1[32][2];
+};
+
+struct _GstH264RefPicMarking
+{
+  guint8 memory_management_control_operation;
+
+  guint32 difference_of_pic_nums_minus1;
+  guint32 long_term_pic_num;
+  guint32 long_term_frame_idx;
+  guint32 max_long_term_frame_idx_plus1;
+};
+
+struct _GstH264DecRefPicMarking
+{
+  /* if slice->nal_unit.IdrPicFlag */
+  guint8 no_output_of_prior_pics_flag;
+  guint8 long_term_reference_flag;
+
+  guint8 adaptive_ref_pic_marking_mode_flag;
+  GstH264RefPicMarking ref_pic_marking[10];
+  guint8 n_ref_pic_marking;
+};
+
+
+struct _GstH264SliceHdr
+{
+  guint32 first_mb_in_slice;
+  guint32 type;
+  GstH264PPS *pps;
+
+  /* if seq->separate_colour_plane_flag */
+  guint8 colour_plane_id;
+
+  guint16 frame_num;
+
+  guint8 field_pic_flag;
+  guint8 bottom_field_flag;
+
+  /* if nal_unit.type == 5 */
+  guint16 idr_pic_id;
+
+  /* if seq->pic_order_cnt_type == 0 */
+  guint16 pic_order_cnt_lsb;
+  /* if seq->pic_order_present_flag && !field_pic_flag */
+  gint32 delta_pic_order_cnt_bottom;
+
+  gint32 delta_pic_order_cnt[2];
+  guint8 redundant_pic_cnt;
+
+  /* if slice_type == B_SLICE */
+  guint8 direct_spatial_mv_pred_flag;
+
+  guint8 num_ref_idx_l0_active_minus1;
+  guint8 num_ref_idx_l1_active_minus1;
+
+  guint8 ref_pic_list_modification_flag_l0;
+  guint8 n_ref_pic_list_modification_l0;
+  GstH264RefPicListModification ref_pic_list_modification_l0[32];
+  guint8 ref_pic_list_modification_flag_l1;
+  guint8 n_ref_pic_list_modification_l1;
+  GstH264RefPicListModification ref_pic_list_modification_l1[32];
+
+  GstH264PredWeightTable pred_weight_table;
+  /* if nal_unit.ref_idc != 0 */
+  GstH264DecRefPicMarking dec_ref_pic_marking;
+
+  guint8 cabac_init_idc;
+  gint8 slice_qp_delta;
+  gint8 slice_qs_delta;
+
+  guint8 disable_deblocking_filter_idc;
+  gint8 slice_alpha_c0_offset_div2;
+  gint8 slice_beta_offset_div2;
+
+  guint16 slice_group_change_cycle;
+
+  /* calculated values */
+  guint32 max_pic_num;
+  gboolean valid;
+
+  /* Size of the slice_header() in bits */
+  guint header_size;
+
+  /* Number of emulation prevention bytes (EPB) in this slice_header() */
+  guint n_emulation_prevention_bytes;
+};
+
+
+struct _GstH264ClockTimestamp
+{
+  guint8 ct_type;
+  guint8 nuit_field_based_flag;
+  guint8 counting_type;
+  guint8 discontinuity_flag;
+  guint8 cnt_dropped_flag;
+  guint8 n_frames;
+
+  guint8 seconds_flag;
+  guint8 seconds_value;
+
+  guint8 minutes_flag;
+  guint8 minutes_value;
+
+  guint8 hours_flag;
+  guint8 hours_value;
+
+  guint32 time_offset;
+};
+
+struct _GstH264PicTiming
+{
+  guint32 cpb_removal_delay;
+  guint32 dpb_output_delay;
+
+  guint8 pic_struct_present_flag;
+  /* if pic_struct_present_flag */
+  guint8 pic_struct;
+
+  guint8 clock_timestamp_flag[3];
+  GstH264ClockTimestamp clock_timestamp[3];
+};
+
+struct _GstH264BufferingPeriod
+{
+  GstH264SPS *sps;
+
+  /* seq->vui_parameters->nal_hrd_parameters_present_flag */
+  guint8 nal_initial_cpb_removal_delay[32];
+  guint8 nal_initial_cpb_removal_delay_offset[32];
+
+  /* seq->vui_parameters->vcl_hrd_parameters_present_flag */
+  guint8 vcl_initial_cpb_removal_delay[32];
+  guint8 vcl_initial_cpb_removal_delay_offset[32];
+};
+
+struct _GstH264RecoveryPoint
+{
+  guint32 recovery_frame_cnt;
+  guint8 exact_match_flag;
+  guint8 broken_link_flag;
+  guint8 changing_slice_group_idc;
+};
+
+struct _GstH264SEIMessage
+{
+  GstH264SEIPayloadType payloadType;
+
+  union {
+    GstH264BufferingPeriod buffering_period;
+    GstH264PicTiming pic_timing;
+    GstH264RecoveryPoint recovery_point;
+    /* ... could implement more */
+  } payload;
+};
+
+/**
+ * GstH264NalParser:
+ *
+ * H264 NAL Parser (opaque structure).
+ */
+struct _GstH264NalParser
+{
+  /*< private >*/
+  GstH264SPS sps[GST_H264_MAX_SPS_COUNT];
+  GstH264PPS pps[GST_H264_MAX_PPS_COUNT];
+  GstH264SPS *last_sps;
+  GstH264PPS *last_pps;
+};
+
+GstH264NalParser *gst_h264_nal_parser_new             (void);
+
+GstH264ParserResult gst_h264_parser_identify_nalu     (GstH264NalParser *nalparser,
+                                                       const guint8 *data, guint offset,
+                                                       gsize size, GstH264NalUnit *nalu);
+
+GstH264ParserResult gst_h264_parser_identify_nalu_unchecked (GstH264NalParser *nalparser,
+                                                       const guint8 *data, guint offset,
+                                                       gsize size, GstH264NalUnit *nalu);
+
+GstH264ParserResult gst_h264_parser_identify_nalu_avc (GstH264NalParser *nalparser, const guint8 *data,
+                                                       guint offset, gsize size, guint8 nal_length_size,
+                                                       GstH264NalUnit *nalu);
+
+GstH264ParserResult gst_h264_parser_parse_nal         (GstH264NalParser *nalparser,
+                                                       GstH264NalUnit *nalu);
+
+GstH264ParserResult gst_h264_parser_parse_slice_hdr   (GstH264NalParser *nalparser, GstH264NalUnit *nalu,
+                                                       GstH264SliceHdr *slice, gboolean parse_pred_weight_table,
+                                                       gboolean parse_dec_ref_pic_marking);
+
+GstH264ParserResult gst_h264_parser_parse_sps         (GstH264NalParser *nalparser, GstH264NalUnit *nalu,
+                                                       GstH264SPS *sps, gboolean parse_vui_params);
+
+GstH264ParserResult gst_h264_parser_parse_pps         (GstH264NalParser *nalparser,
+                                                       GstH264NalUnit *nalu, GstH264PPS *pps);
+
+GstH264ParserResult gst_h264_parser_parse_sei         (GstH264NalParser *nalparser,
+                                                       GstH264NalUnit *nalu, GArray ** messages);
+
+void gst_h264_nal_parser_free                         (GstH264NalParser *nalparser);
+
+GstH264ParserResult gst_h264_parse_sps                (GstH264NalUnit *nalu,
+                                                       GstH264SPS *sps, gboolean parse_vui_params);
+
+GstH264ParserResult gst_h264_parse_pps                (GstH264NalParser *nalparser,
+                                                       GstH264NalUnit *nalu, GstH264PPS *pps);
+
+void                gst_h264_pps_clear                (GstH264PPS *pps);
+
+void    gst_h264_quant_matrix_8x8_get_zigzag_from_raster (guint8 out_quant[64],
+                                                          const guint8 quant[64]);
+
+void    gst_h264_quant_matrix_8x8_get_raster_from_zigzag (guint8 out_quant[64],
+                                                          const guint8 quant[64]);
+
+void    gst_h264_quant_matrix_4x4_get_zigzag_from_raster (guint8 out_quant[16],
+                                                          const guint8 quant[16]);
+
+void    gst_h264_quant_matrix_4x4_get_raster_from_zigzag (guint8 out_quant[16],
+                                                          const guint8 quant[16]);
+
+void gst_h264_video_calculate_framerate (const GstH264SPS * sps, guint field_pic_flag,
+    guint pic_struct, gint * fps_num, gint * fps_den);
+
+G_END_DECLS
+
+#endif
diff --git a/lib/libv4l-hva/gst/vaapi/glibcompat.h b/lib/libv4l-hva/gst/vaapi/glibcompat.h
new file mode 100644
index 0000000..734d6e4
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/glibcompat.h
@@ -0,0 +1,164 @@
+/*
+ *  glibcompat.h - System-dependent definitions
+ *
+ *  Copyright (C) 2012-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GLIB_COMPAT_H
+#define GLIB_COMPAT_H
+
+#include <glib.h>
+#include <glib-object.h>
+
+#define G_COMPAT_DEFINE(new_api, new_args, old_api, old_args)   \
+static inline void                                              \
+new_api new_args                                                \
+{                                                               \
+    old_api old_args;                                           \
+}
+
+#if !GLIB_CHECK_VERSION(2,27,2)
+static inline void
+g_list_free_full(GList *list, GDestroyNotify free_func)
+{
+    g_list_foreach(list, (GFunc)free_func, NULL);
+    g_list_free(list);
+}
+#endif
+
+#if !GLIB_CHECK_VERSION(2,28,0)
+static inline void
+g_clear_object_inline(volatile GObject **object_ptr)
+{
+    gpointer * const ptr = (gpointer)object_ptr;
+    gpointer old;
+
+    do {
+        old = g_atomic_pointer_get(ptr);
+    } while G_UNLIKELY(!g_atomic_pointer_compare_and_exchange(ptr, old, NULL));
+
+    if (old)
+        g_object_unref(old);
+}
+#undef  g_clear_object
+#define g_clear_object(obj) g_clear_object_inline((volatile GObject **)(obj))
+#endif
+
+#if !GLIB_CHECK_VERSION(2,31,2)
+typedef GStaticMutex GCompatMutex;
+G_COMPAT_DEFINE(g_compat_mutex_init, (GCompatMutex *mutex),
+                g_static_mutex_init, (mutex))
+G_COMPAT_DEFINE(g_compat_mutex_clear, (GCompatMutex *mutex),
+                g_static_mutex_free, (mutex))
+G_COMPAT_DEFINE(g_compat_mutex_lock, (GCompatMutex *mutex),
+                g_static_mutex_lock, (mutex))
+G_COMPAT_DEFINE(g_compat_mutex_unlock, (GCompatMutex *mutex),
+                g_static_mutex_unlock, (mutex))
+
+typedef GStaticRecMutex GCompatRecMutex;
+G_COMPAT_DEFINE(g_compat_rec_mutex_init, (GCompatRecMutex *mutex),
+                g_static_rec_mutex_init, (mutex))
+G_COMPAT_DEFINE(g_compat_rec_mutex_clear, (GCompatRecMutex *mutex),
+                g_static_rec_mutex_free, (mutex))
+G_COMPAT_DEFINE(g_compat_rec_mutex_lock, (GCompatRecMutex *mutex),
+                g_static_rec_mutex_lock, (mutex))
+G_COMPAT_DEFINE(g_compat_rec_mutex_unlock, (GCompatRecMutex *mutex),
+                g_static_rec_mutex_unlock, (mutex))
+
+typedef GCond *GCompatCond;
+G_COMPAT_DEFINE(g_compat_cond_init, (GCompatCond *cond),
+                *cond = g_cond_new, ())
+G_COMPAT_DEFINE(g_compat_cond_clear, (GCompatCond *cond),
+                if (*cond) g_cond_free, (*cond))
+G_COMPAT_DEFINE(g_compat_cond_signal, (GCompatCond *cond),
+                g_cond_signal, (*cond))
+G_COMPAT_DEFINE(g_compat_cond_broadcast, (GCompatCond *cond),
+                g_cond_broadcast, (*cond))
+G_COMPAT_DEFINE(g_compat_cond_wait, (GCompatCond *cond, GCompatMutex *mutex),
+                g_cond_wait, (*cond, g_static_mutex_get_mutex(mutex)))
+
+static inline gboolean
+g_cond_wait_until(GCompatCond *cond, GStaticMutex *mutex, gint64 end_time)
+{
+    gint64 diff_time;
+    GTimeVal timeout;
+
+    diff_time = end_time - g_get_monotonic_time();
+    g_get_current_time(&timeout);
+    g_time_val_add(&timeout, diff_time > 0 ? diff_time : 0);
+    return g_cond_timed_wait(*cond, g_static_mutex_get_mutex(mutex), &timeout);
+}
+
+#define GMutex                          GCompatMutex
+#undef  g_mutex_init
+#define g_mutex_init(mutex)             g_compat_mutex_init(mutex)
+#undef  g_mutex_clear
+#define g_mutex_clear(mutex)            g_compat_mutex_clear(mutex)
+#undef  g_mutex_lock
+#define g_mutex_lock(mutex)             g_compat_mutex_lock(mutex)
+#undef  g_mutex_unlock
+#define g_mutex_unlock(mutex)           g_compat_mutex_unlock(mutex)
+
+#define GRecMutex                       GCompatRecMutex
+#undef  g_rec_mutex_init
+#define g_rec_mutex_init(mutex)         g_compat_rec_mutex_init(mutex)
+#undef  g_rec_mutex_clear
+#define g_rec_mutex_clear(mutex)        g_compat_rec_mutex_clear(mutex)
+#undef  g_rec_mutex_lock
+#define g_rec_mutex_lock(mutex)         g_compat_rec_mutex_lock(mutex)
+#undef  g_rec_mutex_unlock
+#define g_rec_mutex_unlock(mutex)       g_compat_rec_mutex_unlock(mutex)
+
+#define GCond                           GCompatCond
+#undef  g_cond_init
+#define g_cond_init(cond)               g_compat_cond_init(cond)
+#undef  g_cond_clear
+#define g_cond_clear(cond)              g_compat_cond_clear(cond)
+#undef  g_cond_signal
+#define g_cond_signal(cond)             g_compat_cond_signal(cond)
+#undef  g_cond_wait
+#define g_cond_wait(cond, mutex)        g_compat_cond_wait(cond, mutex)
+
+#undef  g_thread_try_new
+#define g_thread_try_new(name, func, data, error) \
+    g_compat_thread_try_new(name, func, data, error)
+
+static inline GThread *
+g_compat_thread_try_new(const gchar *name, GThreadFunc func, gpointer data,
+    GError **error)
+{
+    return g_thread_create(func, data, TRUE, error);
+}
+#endif
+
+#if !GLIB_CHECK_VERSION(2,31,18)
+static inline gpointer
+g_async_queue_timeout_pop(GAsyncQueue *queue, guint64 timeout)
+{
+    GTimeVal end_time;
+
+    g_get_current_time(&end_time);
+    g_time_val_add(&end_time, timeout);
+    return g_async_queue_timed_pop(queue, &end_time);
+}
+#endif
+
+#undef G_COMPAT_DEFINE
+
+#endif /* GLIB_COMPAT_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstcompat.h b/lib/libv4l-hva/gst/vaapi/gstcompat.h
new file mode 100644
index 0000000..9abc2fd
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstcompat.h
@@ -0,0 +1,351 @@
+/*
+ *  gstcompat.h - Compatibility glue for GStreamer
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_COMPAT_H
+#define GST_COMPAT_H
+
+#include <gst/gst.h>
+
+/* ------------------------------------------------------------------------ */
+/* --- GStreamer >= 1.0                                                 --- */
+/* ------------------------------------------------------------------------ */
+
+#if GST_CHECK_VERSION(1,0,0)
+#include <gst/video/gstvideometa.h>
+
+/* GstStructure */
+#undef  gst_structure_get_fourcc
+#define gst_structure_get_fourcc(structure, fieldname, value) \
+    gst_compat_structure_get_fourcc(structure, fieldname, value)
+
+static inline gboolean
+gst_compat_structure_get_fourcc(const GstStructure *structure,
+    const gchar *fieldname, guint32 *value)
+{
+    const gchar *s = gst_structure_get_string(structure, fieldname);
+
+    if (!s || strlen(s) != 4)
+        return FALSE;
+
+    *value = GST_MAKE_FOURCC(s[0], s[1], s[2], s[3]);
+    return TRUE;
+}
+
+/* GstTypeFind */
+#undef  GstTypeFindPeekFunction
+#define GstTypeFindPeekFunction         GstCompatTypeFindPeekFunction
+#undef  GstTypeFindSuggestFunction
+#define GstTypeFindSuggestFunction      GstCompatTypeFindSuggestFunction
+
+typedef const guint8 *(*GstCompatTypeFindPeekFunction)(gpointer, gint64, guint);
+typedef void (*GstCompatTypeFindSuggestFunction)(gpointer, guint, GstCaps *);
+
+/* GstPad */
+#define GST_PAD_CHAIN_FUNCTION_ARGS \
+    GstPad *pad, GstObject *parent, GstBuffer *buffer
+#define GST_PAD_EVENT_FUNCTION_ARGS \
+    GstPad *pad, GstObject *parent, GstEvent *event
+#define GST_PAD_QUERY_FUNCTION_ARGS \
+    GstPad *pad, GstObject *parent, GstQuery *query
+#define GST_PAD_QUERY_FUNCTION_CALL(func, pad, parent, query) \
+    (func)(pad, parent, query)
+
+/* Misc helpers */
+#define GST_MAKE_FORMAT_STRING(FORMAT) \
+    "format=(string)" G_STRINGIFY(FORMAT)
+
+/* ------------------------------------------------------------------------ */
+/* --- GStreamer = 0.10                                                 --- */
+/* ------------------------------------------------------------------------ */
+
+#else
+
+/* GstMemory */
+typedef enum {
+    GST_MEMORY_FLAG_READONLY = GST_MINI_OBJECT_FLAG_READONLY
+} GstMemoryFlags;
+
+typedef enum {
+    GST_BUFFER_COPY_META        = GST_BUFFER_COPY_QDATA,
+    GST_BUFFER_COPY_MEMORY      = 0,
+} GstBufferCopyFlags1_0;
+
+typedef enum {
+    GST_MAP_READ        = 1 << 0,
+    GST_MAP_WRITE       = 1 << 1
+} GstMapFlags;
+
+typedef struct {
+    GstMapFlags         flags;
+    guint8             *data;
+    gsize               size;
+} GstMapInfo;
+
+/* GstBuffer */
+#undef  gst_buffer_new_wrapped
+#define gst_buffer_new_wrapped(data, size) \
+    gst_compat_buffer_new_wrapped_full(0, data, size, 0, size, data, g_free)
+#undef  gst_buffer_new_wrapped_full
+#define gst_buffer_new_wrapped_full(flags, data, maxsize, ofs, size, ud, udd) \
+    gst_compat_buffer_new_wrapped_full(flags, data, maxsize, ofs, size, ud, udd)
+#undef  gst_buffer_new_allocate
+#define gst_buffer_new_allocate(allocator, size, params) \
+    gst_compat_buffer_new_allocate((allocator), (size), (params))
+#undef  gst_buffer_get_size
+#define gst_buffer_get_size(buffer)     gst_compat_buffer_get_size(buffer)
+#undef  gst_buffer_map
+#define gst_buffer_map(buffer, mip, f)  gst_compat_buffer_map(buffer, mip, f)
+#undef  gst_buffer_unmap
+#define gst_buffer_unmap(buffer, mip)   gst_compat_buffer_unmap(buffer, mip)
+#undef  gst_buffer_extract
+#define gst_buffer_extract(buffer, offset, dest, size) \
+    gst_compat_buffer_extract(buffer, offset, dest, size)
+#undef  gst_buffer_fill
+#define gst_buffer_fill(buffer, offset, src, size) \
+    gst_compat_buffer_fill((buffer), (offset), (src), (size))
+#undef  gst_buffer_copy_into
+#define gst_buffer_copy_into(dest, src, flags, offset, size) \
+    gst_compat_buffer_copy_into(dest, src, flags, offset, size)
+
+static inline GstBuffer *
+gst_compat_buffer_new_wrapped_full(GstMemoryFlags flags, gpointer data,
+    gsize maxsize, gsize offset, gsize size, gpointer user_data,
+    GDestroyNotify notify)
+{
+    GstBuffer *buffer;
+
+    /* XXX: unsupported */
+    g_return_val_if_fail(maxsize >= size, NULL);
+
+    buffer = gst_buffer_new();
+    if (!buffer)
+        return NULL;
+
+    GST_BUFFER_DATA(buffer) = data + offset;
+    GST_BUFFER_SIZE(buffer) = size;
+
+    if (notify)
+        gst_mini_object_weak_ref(GST_MINI_OBJECT_CAST(buffer),
+            (GstMiniObjectWeakNotify)notify, user_data);
+    return buffer;
+}
+
+static inline GstBuffer *
+gst_compat_buffer_new_allocate(gpointer allocator, gsize size, gpointer params)
+{
+    /* XXX: unsupported */
+    g_return_val_if_fail(allocator == NULL, NULL);
+    g_return_val_if_fail(params == NULL, NULL);
+
+    return gst_buffer_new_and_alloc(size);
+}
+
+static inline gsize
+gst_compat_buffer_get_size(GstBuffer *buffer)
+{
+    return GST_BUFFER_SIZE(buffer);
+}
+
+static inline gboolean
+gst_compat_buffer_map(GstBuffer *buffer, GstMapInfo *mip, GstMapFlags flags)
+{
+    mip->flags = flags;
+    mip->data  = GST_BUFFER_DATA(buffer);
+    mip->size  = GST_BUFFER_SIZE(buffer);
+    return TRUE;
+}
+
+static inline void
+gst_compat_buffer_unmap(GstBuffer *buffer, GstMapInfo *mip)
+{
+}
+
+static inline gsize
+gst_compat_buffer_extract(GstBuffer *buffer, gsize offset, gpointer dest,
+    gsize size)
+{
+    gsize esize;
+
+    if (!buffer || !dest || offset >= GST_BUFFER_SIZE(buffer))
+        return 0;
+
+    esize = MIN(size, GST_BUFFER_SIZE(buffer) - offset);
+    memcpy(dest, GST_BUFFER_DATA(buffer) + offset, esize);
+    return esize;
+}
+
+static inline gsize
+gst_compat_buffer_fill(GstBuffer *buffer, gsize offset, gconstpointer src,
+    gsize size)
+{
+    gsize fsize;
+
+    if (!buffer || !src || offset >= GST_BUFFER_SIZE(buffer))
+        return 0;
+
+    fsize = MIN(size, GST_BUFFER_SIZE(buffer) - offset);
+    memcpy(GST_BUFFER_DATA(buffer) + offset, src, fsize);
+    return fsize;
+}
+
+static inline void
+gst_compat_buffer_copy_into(GstBuffer *dest, GstBuffer *src,
+    GstBufferCopyFlags flags, gsize offset, gsize size)
+{
+    g_return_if_fail(offset == 0);
+    g_return_if_fail(size == (gsize)-1);
+
+    gst_buffer_copy_metadata(dest, src, flags);
+}
+
+/* GstAdapter */
+#include <gst/base/gstadapter.h>
+
+#undef  gst_adapter_map
+#define gst_adapter_map(adapter, size)  gst_compat_adapter_map(adapter, size)
+#undef  gst_adapter_unmap
+#define gst_adapter_unmap(adapter)      gst_compat_adapter_unmap(adapter)
+
+static inline gconstpointer
+gst_compat_adapter_map(GstAdapter *adapter, gsize size)
+{
+    return gst_adapter_peek(adapter, size);
+}
+
+static inline void
+gst_compat_adapter_unmap(GstAdapter *adapter)
+{
+}
+
+/* GstCaps */
+#undef  gst_caps_merge
+#define gst_caps_merge(caps1, caps2)    gst_compat_caps_merge(caps1, caps2)
+#undef  gst_caps_merge_structure
+#define gst_caps_merge_structure(caps, structure) \
+    gst_compat_caps_merge_structure(caps, structure)
+
+static inline GstCaps *
+gst_compat_caps_merge(GstCaps *caps1, GstCaps *caps2)
+{
+    (gst_caps_merge)(caps1, caps2);
+    return caps1;
+}
+
+static inline GstCaps *
+gst_compat_caps_merge_structure(GstCaps *caps, GstStructure *structure)
+{
+    (gst_caps_merge_structure)(caps, structure);
+    return caps;
+}
+
+/* GstVideoOverlayComposition */
+#include <gst/video/video-overlay-composition.h>
+
+#undef  gst_video_overlay_rectangle_get_pixels_unscaled_raw
+#define gst_video_overlay_rectangle_get_pixels_unscaled_raw(rect, flags) \
+    gst_compat_video_overlay_rectangle_get_pixels_unscaled_raw(rect, flags)
+
+#ifndef HAVE_GST_VIDEO_OVERLAY_HWCAPS
+#define gst_video_overlay_rectangle_get_flags(rect) (0)
+#define gst_video_overlay_rectangle_get_global_alpha(rect) (1.0f)
+#endif
+
+static inline GstBuffer *
+gst_compat_video_overlay_rectangle_get_pixels_unscaled_raw(
+    GstVideoOverlayRectangle *rect, GstVideoOverlayFormatFlags flags)
+{
+    guint width, height, stride;
+
+    /* Try to retrieve the original buffer that was passed to
+       gst_video_overlay_rectangle_new_argb(). This will only work if
+       there was no previous user that required pixels with non native
+       alpha type */
+    return gst_video_overlay_rectangle_get_pixels_unscaled_argb(rect,
+        &width, &height, &stride, flags);
+}
+
+typedef enum {
+    GST_VIDEO_BUFFER_FLAG_TFF           = GST_VIDEO_BUFFER_TFF,
+    GST_VIDEO_BUFFER_FLAG_RFF           = GST_VIDEO_BUFFER_RFF,
+    GST_VIDEO_BUFFER_FLAG_ONEFIELD      = GST_VIDEO_BUFFER_ONEFIELD
+} GstVideoBufferFlags;
+
+/* GstPad */
+#undef  GST_FLOW_EOS
+#define GST_FLOW_EOS GST_FLOW_UNEXPECTED
+#undef  GST_FLOW_FLUSHING
+#define GST_FLOW_FLUSHING GST_FLOW_WRONG_STATE
+
+#define GST_PAD_CHAIN_FUNCTION_ARGS \
+    GstPad *pad, GstBuffer *buffer
+#define GST_PAD_EVENT_FUNCTION_ARGS \
+    GstPad *pad, GstEvent *event
+
+static inline gboolean
+gst_compat_pad_start_task(GstPad *pad, GstTaskFunction func, gpointer user_data,
+    GDestroyNotify notify)
+{
+    g_return_val_if_fail(notify == NULL, FALSE);
+
+    return gst_pad_start_task(pad, func, user_data);
+}
+
+#undef  gst_pad_start_task
+#define gst_pad_start_task(pad, func, user_data, notify) \
+    gst_compat_pad_start_task(pad, func, user_data, notify)
+
+/* GstElement */
+#undef  GST_ELEMENT_FLAG_SINK
+#define GST_ELEMENT_FLAG_SINK GST_ELEMENT_IS_SINK
+#undef  gst_element_class_set_static_metadata
+#define gst_element_class_set_static_metadata(klass, name, path, desc, author) \
+    gst_compat_element_class_set_static_metadata(klass, name, path, desc, author)
+
+static inline void
+gst_compat_element_class_set_static_metadata(GstElementClass *klass,
+    const gchar *name, const char *path, const gchar *desc, const gchar *author)
+{
+    gst_element_class_set_details_simple(klass, name, path, desc, author);
+}
+
+/* GstTypeFind */
+#undef  GstTypeFindPeekFunction
+#define GstTypeFindPeekFunction         GstCompatTypeFindPeekFunction
+#undef  GstTypeFindSuggestFunction
+#define GstTypeFindSuggestFunction      GstCompatTypeFindSuggestFunction
+
+typedef guint8 *(*GstCompatTypeFindPeekFunction)(gpointer, gint64, guint);
+typedef void (*GstCompatTypeFindSuggestFunction)(gpointer, guint, const GstCaps *);
+
+/* GstQuery */
+#define GST_PAD_QUERY_FUNCTION_ARGS \
+    GstPad *pad, GstQuery *query
+#define GST_PAD_QUERY_FUNCTION_CALL(func, pad, parent, query) \
+    (func)(pad, query)
+
+/* Misc helpers */
+#define GST_MAKE_FORMAT_STRING(FORMAT) \
+    "format=(fourcc)" G_STRINGIFY(FORMAT)
+
+#endif
+
+#endif /* GST_COMPAT_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapicodec_objects.h b/lib/libv4l-hva/gst/vaapi/gstvaapicodec_objects.h
new file mode 100644
index 0000000..163ebf7
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapicodec_objects.h
@@ -0,0 +1,270 @@
+/*
+ *  gstvaapicodec_objects.h - VA codec objects abstraction
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_CODEC_COMMON_H
+#define GST_VAAPI_CODEC_COMMON_H
+
+#include <gst/vaapi/gstvaapiminiobject.h>
+#include <gst/vaapi/gstvaapidecoder.h>
+#if USE_VP8_DECODER
+#include <va/va_dec_vp8.h>
+#endif
+
+G_BEGIN_DECLS
+
+typedef gpointer                                GstVaapiCodecBase;
+typedef struct _GstVaapiCodecObject             GstVaapiCodecObject;
+typedef struct _GstVaapiCodecObjectClass        GstVaapiCodecObjectClass;
+typedef struct _GstVaapiIqMatrix                GstVaapiIqMatrix;
+typedef struct _GstVaapiBitPlane                GstVaapiBitPlane;
+typedef struct _GstVaapiHuffmanTable            GstVaapiHuffmanTable;
+typedef struct _GstVaapiProbabilityTable        GstVaapiProbabilityTable;
+
+/* ------------------------------------------------------------------------- */
+/* --- Base Codec Object                                                 --- */
+/* ------------------------------------------------------------------------- */
+
+/* XXX: remove when a common base class for decoder and encoder is available */
+#define GST_VAAPI_CODEC_BASE(obj) \
+  ((GstVaapiCodecBase *) (obj))
+
+#define GST_VAAPI_CODEC_OBJECT(obj) \
+  ((GstVaapiCodecObject *) (obj))
+
+enum
+{
+  GST_VAAPI_CODEC_OBJECT_FLAG_CONSTRUCTED = (1 << 0),
+  GST_VAAPI_CODEC_OBJECT_FLAG_LAST        = (1 << 1)
+};
+
+typedef struct
+{
+  gconstpointer param;
+  guint param_size;
+  gconstpointer data;
+  guint data_size;
+  guint flags;
+} GstVaapiCodecObjectConstructorArgs;
+
+typedef gboolean
+(*GstVaapiCodecObjectCreateFunc)(GstVaapiCodecObject * object,
+    const GstVaapiCodecObjectConstructorArgs * args);
+
+typedef GDestroyNotify GstVaapiCodecObjectDestroyFunc;
+
+/**
+ * GstVaapiCodecObject:
+ *
+ * A #GstVaapiMiniObject holding the base codec object data
+ */
+struct _GstVaapiCodecObject
+{
+  /*< private >*/
+  GstVaapiMiniObject parent_instance;
+  GstVaapiCodecBase *codec;
+};
+
+/**
+ * GstVaapiCodecObjectClass:
+ *
+ * The #GstVaapiCodecObject base class.
+ */
+struct _GstVaapiCodecObjectClass
+{
+  /*< private >*/
+  GstVaapiMiniObjectClass parent_class;
+
+  GstVaapiCodecObjectCreateFunc create;
+};
+
+G_GNUC_INTERNAL
+const GstVaapiCodecObjectClass *
+gst_vaapi_codec_object_get_class (GstVaapiCodecObject * object) G_GNUC_CONST;
+
+G_GNUC_INTERNAL
+GstVaapiCodecObject *
+gst_vaapi_codec_object_new (const GstVaapiCodecObjectClass * object_class,
+    GstVaapiCodecBase * codec, gconstpointer param, guint param_size,
+    gconstpointer data, guint data_size, guint flags);
+
+#define gst_vaapi_codec_object_ref(object) \
+  ((gpointer) gst_vaapi_mini_object_ref (GST_VAAPI_MINI_OBJECT (object)))
+
+#define gst_vaapi_codec_object_unref(object) \
+  gst_vaapi_mini_object_unref (GST_VAAPI_MINI_OBJECT (object))
+
+#define gst_vaapi_codec_object_replace(old_object_ptr, new_object) \
+  gst_vaapi_mini_object_replace ((GstVaapiMiniObject **) (old_object_ptr), \
+      GST_VAAPI_MINI_OBJECT (new_object))
+
+/* ------------------------------------------------------------------------- */
+/* --- Inverse Quantization Matrices                                     --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_IQ_MATRIX_CAST(obj) \
+  ((GstVaapiIqMatrix *) (obj))
+
+/**
+ * GstVaapiIqMatrix:
+ *
+ * A #GstVaapiCodecObject holding an inverse quantization matrix parameter.
+ */
+struct _GstVaapiIqMatrix
+{
+  /*< private >*/
+  GstVaapiCodecObject parent_instance;
+  VABufferID param_id;
+
+  /*< public >*/
+  gpointer param;
+};
+
+G_GNUC_INTERNAL
+GstVaapiIqMatrix *
+gst_vaapi_iq_matrix_new (GstVaapiDecoder * decoder, gconstpointer param,
+    guint param_size);
+
+/* ------------------------------------------------------------------------- */
+/* --- VC-1 Bit Planes                                                   --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_BITPLANE_CAST(obj) \
+  ((GstVaapiBitPlane *) (obj))
+
+/**
+ * GstVaapiBitPlane:
+ *
+ * A #GstVaapiCodecObject holding a VC-1 bit plane parameter.
+ */
+struct _GstVaapiBitPlane
+{
+  /*< private >*/
+  GstVaapiCodecObject parent_instance;
+  VABufferID data_id;
+
+  /*< public >*/
+  guint8 *data;
+};
+
+G_GNUC_INTERNAL
+GstVaapiBitPlane *
+gst_vaapi_bitplane_new (GstVaapiDecoder * decoder, guint8 * data,
+    guint data_size);
+
+/* ------------------------------------------------------------------------- */
+/* --- JPEG Huffman Tables                                               --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_HUFFMAN_TABLE_CAST(obj) \
+  ((GstVaapiHuffmanTable *) (obj))
+
+/**
+ * GstVaapiHuffmanTable:
+ *
+ * A #GstVaapiCodecObject holding huffman table.
+ */
+struct _GstVaapiHuffmanTable
+{
+  /*< private >*/
+  GstVaapiCodecObject parent_instance;
+  VABufferID param_id;
+
+  /*< public >*/
+  gpointer param;
+};
+
+G_GNUC_INTERNAL
+GstVaapiHuffmanTable *
+gst_vaapi_huffman_table_new (GstVaapiDecoder * decoder, guint8 * data,
+    guint data_size);
+
+/* ------------------------------------------------------------------------- */
+/* ---                   Probability (Update) Table                      --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_PROBABILITY_TABLE_CAST(obj) \
+    ((GstVaapiProbabilityTable *)(obj))
+
+/**
+ * GstVaapiProbabilityTable:
+ *
+ * A #GstVaapiCodecObject holding an Probability (Update) Table for RAC decoding
+ */
+struct _GstVaapiProbabilityTable
+{
+  /*< private > */
+  GstVaapiCodecObject parent_instance;
+  VABufferID param_id;
+
+  /*< public > */
+  gpointer param;
+};
+
+G_GNUC_INTERNAL
+GstVaapiProbabilityTable *
+gst_vaapi_probability_table_new (GstVaapiDecoder * decoder,
+    gconstpointer param, guint param_size);
+
+/* ------------------------------------------------------------------------- */
+/* --- Helpers to create codec-dependent objects                         --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_CODEC_DEFINE_TYPE(type, prefix)                       \
+G_GNUC_INTERNAL                                                         \
+void                                                                    \
+G_PASTE (prefix, _destroy) (type *);                                    \
+                                                                        \
+G_GNUC_INTERNAL                                                         \
+gboolean                                                                \
+G_PASTE (prefix, _create) (type *,                                      \
+    const GstVaapiCodecObjectConstructorArgs * args);                   \
+                                                                        \
+static const GstVaapiCodecObjectClass G_PASTE (type, Class) = {         \
+  .parent_class = {                                                     \
+    .size = sizeof (type),                                              \
+    .finalize = (GstVaapiCodecObjectDestroyFunc)                        \
+        G_PASTE (prefix, _destroy)                                      \
+  },                                                                    \
+  .create = (GstVaapiCodecObjectCreateFunc)                             \
+      G_PASTE (prefix, _create),                                        \
+}
+
+#define GST_VAAPI_IQ_MATRIX_NEW(codec, decoder)                         \
+  gst_vaapi_iq_matrix_new (GST_VAAPI_DECODER_CAST (decoder),            \
+      NULL, sizeof (G_PASTE (VAIQMatrixBuffer, codec)))
+
+#define GST_VAAPI_BITPLANE_NEW(decoder, size) \
+  gst_vaapi_bitplane_new (GST_VAAPI_DECODER_CAST (decoder), NULL, size)
+
+#define GST_VAAPI_HUFFMAN_TABLE_NEW(codec, decoder)                     \
+  gst_vaapi_huffman_table_new (GST_VAAPI_DECODER_CAST (decoder),        \
+      NULL, sizeof (G_PASTE (VAHuffmanTableBuffer, codec)))
+
+#define GST_VAAPI_PROBABILITY_TABLE_NEW(codec, decoder)                 \
+  gst_vaapi_probability_table_new (GST_VAAPI_DECODER_CAST (decoder),    \
+      NULL, sizeof (G_PASTE (VAProbabilityDataBuffer, codec)))
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_CODEC_OBJECTS_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapicodedbuffer.h b/lib/libv4l-hva/gst/vaapi/gstvaapicodedbuffer.h
new file mode 100644
index 0000000..4980e9c
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapicodedbuffer.h
@@ -0,0 +1,53 @@
+/*
+ *  gstvaapicodedbuffer.h - VA coded buffer abstraction
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *    Author: Wind Yuan <feng.yuan@intel.com>
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_CODED_BUFFER_H
+#define GST_VAAPI_CODED_BUFFER_H
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_CODED_BUFFER(obj) \
+  ((GstVaapiCodedBuffer *)(obj))
+
+/**
+ * GST_VAAPI_CODED_BUFFER_SIZE:
+ * @buf: a #GstVaapiCodedBuffer
+ *
+ * Macro that evaluates to the size of the underlying VA coded buffer @buf
+ */
+#define GST_VAAPI_CODED_BUFFER_SIZE(buf) \
+  gst_vaapi_coded_buffer_get_size (GST_VAAPI_CODED_BUFFER(buf))
+
+typedef struct _GstVaapiCodedBuffer             GstVaapiCodedBuffer;
+typedef struct _GstVaapiCodedBufferProxy        GstVaapiCodedBufferProxy;
+typedef struct _GstVaapiCodedBufferPool         GstVaapiCodedBufferPool;
+
+gssize
+gst_vaapi_coded_buffer_get_size (GstVaapiCodedBuffer * buf);
+
+gboolean
+gst_vaapi_coded_buffer_copy_into (GstBuffer * dest, GstVaapiCodedBuffer * src);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_CODED_BUFFER_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapicodedbuffer_priv.h b/lib/libv4l-hva/gst/vaapi/gstvaapicodedbuffer_priv.h
new file mode 100644
index 0000000..8d0de4d
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapicodedbuffer_priv.h
@@ -0,0 +1,78 @@
+/*
+ *  gstvaapicodedbuffer_priv.h - VA coded buffer abstraction (private defs)
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *    Author: Wind Yuan <feng.yuan@intel.com>
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_CODED_BUFFER_PRIV_H
+#define GST_VAAPI_CODED_BUFFER_PRIV_H
+
+#include <gst/vaapi/gstvaapicontext.h>
+#include "gstvaapicodedbuffer.h"
+#include "gstvaapiobject_priv.h"
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_CODED_BUFFER_CAST(obj) \
+    ((GstVaapiCodedBuffer *)(obj))
+
+typedef struct _GstVaapiCodedBufferClass        GstVaapiCodedBufferClass;
+
+/**
+ * GstVaapiCodedBuffer:
+ *
+ * A VA coded buffer object wrapper.
+ */
+struct _GstVaapiCodedBuffer
+{
+  /*< private >*/
+  GstVaapiObject parent_instance;
+
+  GstVaapiContext      *context;
+  VACodedBufferSegment *segment_list;
+};
+
+/**
+ * GstVaapiCodedBufferClass:
+ *
+ * A VA coded buffer object wrapper class.
+ */
+struct _GstVaapiCodedBufferClass
+{
+  /*< private >*/
+  GstVaapiObjectClass parent_class;
+};
+
+G_GNUC_INTERNAL
+GstVaapiCodedBuffer *
+gst_vaapi_coded_buffer_new (GstVaapiContext * context, guint buf_size);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_coded_buffer_map (GstVaapiCodedBuffer * buf,
+    VACodedBufferSegment ** out_segment_list_ptr);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_coded_buffer_unmap (GstVaapiCodedBuffer * buf);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_CODED_BUFFER_PRIV_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferpool.h b/lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferpool.h
new file mode 100644
index 0000000..c8b9e1b
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferpool.h
@@ -0,0 +1,45 @@
+/*
+ *  gstvaapicodedbufferpool.h - VA coded buffer pool
+ *
+ *  Copyright (C) 2013-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_CODED_BUFFER_POOL_H
+#define GST_VAAPI_CODED_BUFFER_POOL_H
+
+#include <gst/vaapi/gstvaapivideopool.h>
+#include <gst/vaapi/gstvaapiencoder.h>
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_CODED_BUFFER_POOL(obj) \
+    ((GstVaapiCodedBufferPool *)(obj))
+
+struct _GstVaapiEncoder;
+
+GstVaapiVideoPool *
+gst_vaapi_coded_buffer_pool_new (struct _GstVaapiEncoder * encoder,
+    gsize buf_size);
+
+gsize
+gst_vaapi_coded_buffer_pool_get_buffer_size (GstVaapiCodedBufferPool * pool);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_CODED_BUFFER_POOL_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferproxy.h b/lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferproxy.h
new file mode 100644
index 0000000..4968c63
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferproxy.h
@@ -0,0 +1,82 @@
+/*
+ *  gstvaapicodedbufferproxy_priv.h - VA coded buffer proxy
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_CODED_BUFFER_PROXY_H
+#define GST_VAAPI_CODED_BUFFER_PROXY_H
+
+#include <gst/vaapi/gstvaapicodedbuffer.h>
+#include <gst/vaapi/gstvaapicodedbufferpool.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GST_VAAPI_CODED_BUFFER_PROXY_BUFFER:
+ * @proxy: a #GstVaapiCodedBufferProxy
+ *
+ * Macro that evaluated to the underlying #GstVaapiCodedBuffer of @proxy.
+ */
+#define GST_VAAPI_CODED_BUFFER_PROXY_BUFFER(proxy) \
+  gst_vaapi_coded_buffer_proxy_get_buffer(proxy)
+
+/**
+ * GST_VAAPI_CODED_BUFFER_PROXY_BUFFER_SIZE:
+ * @proxy: a #GstVaapiCodedBufferProxy
+ *
+ * Macro that evaluated to the underlying #GstVaapiCodedBuffer size of
+ * @proxy.
+ */
+#define GST_VAAPI_CODED_BUFFER_PROXY_BUFFER_SIZE(proxy) \
+  gst_vaapi_coded_buffer_proxy_get_buffer_size(proxy)
+
+GstVaapiCodedBufferProxy *
+gst_vaapi_coded_buffer_proxy_new_from_pool (GstVaapiCodedBufferPool * pool);
+
+GstVaapiCodedBufferProxy *
+gst_vaapi_coded_buffer_proxy_ref (GstVaapiCodedBufferProxy * proxy);
+
+void
+gst_vaapi_coded_buffer_proxy_unref (GstVaapiCodedBufferProxy * proxy);
+
+void
+gst_vaapi_coded_buffer_proxy_replace (GstVaapiCodedBufferProxy ** old_proxy_ptr,
+    GstVaapiCodedBufferProxy * new_proxy);
+
+GstVaapiCodedBuffer *
+gst_vaapi_coded_buffer_proxy_get_buffer (GstVaapiCodedBufferProxy * proxy);
+
+gssize
+gst_vaapi_coded_buffer_proxy_get_buffer_size (GstVaapiCodedBufferProxy * proxy);
+
+void
+gst_vaapi_coded_buffer_proxy_set_destroy_notify (GstVaapiCodedBufferProxy *
+    proxy, GDestroyNotify destroy_func, gpointer user_data);
+
+gpointer
+gst_vaapi_coded_buffer_proxy_get_user_data (GstVaapiCodedBufferProxy * proxy);
+
+void
+gst_vaapi_coded_buffer_proxy_set_user_data (GstVaapiCodedBufferProxy * proxy,
+    gpointer user_data, GDestroyNotify destroy_func);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_CODED_BUFFER_PROXY_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferproxy_priv.h b/lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferproxy_priv.h
new file mode 100644
index 0000000..6feb8f9
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapicodedbufferproxy_priv.h
@@ -0,0 +1,70 @@
+/*
+ *  gstvaapicodedbufferproxy_priv.h - VA coded buffer proxy (private defs)
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_CODED_BUFFER_PROXY_PRIV_H
+#define GST_VAAPI_CODED_BUFFER_PROXY_PRIV_H
+
+#include "gstvaapicodedbuffer_priv.h"
+#include "gstvaapiminiobject.h"
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_CODED_BUFFER_PROXY(proxy) \
+  ((GstVaapiCodedBufferProxy *)(proxy))
+
+struct _GstVaapiCodedBufferProxy
+{
+  /*< private >*/
+  GstVaapiMiniObject parent_instance;
+
+  GstVaapiVideoPool    *pool;
+  GstVaapiCodedBuffer  *buffer;
+  GDestroyNotify        destroy_func;
+  gpointer              destroy_data;
+  GDestroyNotify        user_data_destroy;
+  gpointer              user_data;
+};
+
+/**
+ * GST_VAAPI_CODED_BUFFER_PROXY_BUFFER:
+ * @proxy: a #GstVaapiCodedBufferProxy
+ *
+ * Macro that evaluated to the underlying #GstVaapiCodedBuffer of @proxy.
+ */
+#undef  GST_VAAPI_CODED_BUFFER_PROXY_BUFFER
+#define GST_VAAPI_CODED_BUFFER_PROXY_BUFFER(proxy) \
+  GST_VAAPI_CODED_BUFFER_PROXY(proxy)->buffer
+
+/**
+ * GST_VAAPI_CODED_BUFFER_PROXY_BUFFER_SIZE:
+ * @proxy: a #GstVaapiCodedBufferProxy
+ *
+ * Macro that evaluated to the underlying #GstVaapiCodedBuffer size of
+ * @proxy.
+ */
+#undef  GST_VAAPI_CODED_BUFFER_PROXY_BUFFER_SIZE
+#define GST_VAAPI_CODED_BUFFER_PROXY_BUFFER_SIZE(proxy) \
+  GST_VAAPI_CODED_BUFFER_SIZE(GST_VAAPI_CODED_BUFFER_PROXY_BUFFER(proxy))
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_CODED_BUFFER_PROXY_PRIV_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapicompat.h b/lib/libv4l-hva/gst/vaapi/gstvaapicompat.h
new file mode 100644
index 0000000..f2d5b92
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapicompat.h
@@ -0,0 +1,57 @@
+/*
+ *  gstvapicompat.h - VA-API compatibility glue
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2012 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_COMPAT_H
+#define GST_VAAPI_COMPAT_H
+
+#include <va/va.h>
+
+#ifdef HAVE_VA_VA_GLX_H
+# define USE_VAAPI_GLX 1
+#else
+# define USE_VAAPI_GLX 0
+#endif
+
+#if USE_VAAPI_GLX
+# include <va/va_glx.h>
+#else
+# define vaGetDisplayGLX(dpy) vaGetDisplay(dpy)
+#endif
+
+/* Compatibility glue with VA-API < 0.31 */
+#if !VA_CHECK_VERSION(0,31,0)
+#undef  vaSyncSurface
+#define vaSyncSurface(dpy, s)   (vaSyncSurface)((dpy), VA_INVALID_ID, (s))
+#undef  vaPutImage
+#define vaPutImage              vaPutImage2
+#undef  vaAssociateSubpicture
+#define vaAssociateSubpicture   vaAssociateSubpicture2
+#endif
+
+/* Compatibility glue with VA-API 0.34 */
+#if VA_CHECK_VERSION(0,34,0)
+# include <va/va_compat.h>
+#endif
+
+#endif /* GST_VAAPI_COMPAT_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapicontext.h b/lib/libv4l-hva/gst/vaapi/gstvaapicontext.h
new file mode 100644
index 0000000..d3010c1
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapicontext.h
@@ -0,0 +1,148 @@
+/*
+ *  gstvaapicontext.h - VA context abstraction (private)
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_CONTEXT_H
+#define GST_VAAPI_CONTEXT_H
+
+#include "gstvaapiobject.h"
+#include "gstvaapiobject_priv.h"
+#include "gstvaapiprofile.h"
+#include "gstvaapidisplay.h"
+#include "gstvaapisurface.h"
+#include "gstvaapivideopool.h"
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_CONTEXT(obj) \
+  ((GstVaapiContext *) (obj))
+
+typedef struct _GstVaapiConfigInfoEncoder GstVaapiConfigInfoEncoder;
+typedef struct _GstVaapiContextInfo GstVaapiContextInfo;
+typedef struct _GstVaapiContext GstVaapiContext;
+typedef struct _GstVaapiContextClass GstVaapiContextClass;
+
+/**
+ * GstVaapiContextUsage:
+ * @GST_VAAPI_CONTEXT_MODE_DECODE: context used for decoding.
+ * @GST_VAAPI_CONTEXT_MODE_ENCODE: context used for encoding.
+ * @GST_VAAPI_CONTEXT_MODE_VPP: context used for video processing.
+ *
+ * The set of supported VA context usages.
+ */
+typedef enum {
+  GST_VAAPI_CONTEXT_USAGE_DECODE = 1,
+  GST_VAAPI_CONTEXT_USAGE_ENCODE,
+  GST_VAAPI_CONTEXT_USAGE_VPP,
+} GstVaapiContextUsage;
+
+/**
+ * GstVaapiConfigInfoEncoder:
+ * @rc_mode: rate-control mode (#GstVaapiRateControl).
+ * @packed_headers: notify encoder that packed headers are submitted (mask).
+ *
+ * Extra configuration for encoding.
+ */
+struct _GstVaapiConfigInfoEncoder
+{
+  GstVaapiRateControl rc_mode;
+  guint packed_headers;
+};
+
+/**
+ * GstVaapiContextInfo:
+ *
+ * Structure holding VA context info like encoded size, decoder
+ * profile and entry-point to use, and maximum number of reference
+ * frames reported by the bitstream.
+ */
+struct _GstVaapiContextInfo
+{
+  GstVaapiContextUsage usage;
+  GstVaapiProfile profile;
+  GstVaapiEntrypoint entrypoint;
+  GstVaapiChromaType chroma_type;
+  guint width;
+  guint height;
+  guint ref_frames;
+  union _GstVaapiConfigInfo {
+    GstVaapiConfigInfoEncoder encoder;
+  } config;
+};
+
+/**
+ * GstVaapiContext:
+ *
+ * A VA context wrapper.
+ */
+struct _GstVaapiContext
+{
+  /*< private >*/
+  GstVaapiObject parent_instance;
+
+  GstVaapiContextInfo info;
+  VAProfile va_profile;
+  VAEntrypoint va_entrypoint;
+  VAConfigID va_config;
+  GPtrArray *surfaces;
+  GstVaapiVideoPool *surfaces_pool;
+  GPtrArray *overlays[2];
+  guint overlay_id;
+};
+
+/**
+ * GstVaapiContextClass:
+ *
+ * A VA context wrapper class.
+ */
+struct _GstVaapiContextClass
+{
+  /*< private >*/
+  GstVaapiObjectClass parent_class;
+};
+
+G_GNUC_INTERNAL
+GstVaapiContext *
+gst_vaapi_context_new (GstVaapiDisplay * display,
+    const GstVaapiContextInfo * cip);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_context_reset (GstVaapiContext * context,
+    const GstVaapiContextInfo * new_cip);
+
+G_GNUC_INTERNAL
+GstVaapiID
+gst_vaapi_context_get_id (GstVaapiContext * context);
+
+G_GNUC_INTERNAL
+GstVaapiSurfaceProxy *
+gst_vaapi_context_get_surface_proxy (GstVaapiContext * context);
+
+G_GNUC_INTERNAL
+guint
+gst_vaapi_context_get_surface_count (GstVaapiContext * context);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_CONTEXT_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapicontext_overlay.h b/lib/libv4l-hva/gst/vaapi/gstvaapicontext_overlay.h
new file mode 100644
index 0000000..85440e9
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapicontext_overlay.h
@@ -0,0 +1,52 @@
+/*
+ *  gstvaapicontext_overlay.h - VA context abstraction (overlay composition)
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_CONTEXT_OVERLAY_H
+#define GST_VAAPI_CONTEXT_OVERLAY_H
+
+#include <gst/video/video-overlay-composition.h>
+#include "gstvaapicontext.h"
+
+G_BEGIN_DECLS
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_context_overlay_init (GstVaapiContext * context);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_context_overlay_finalize (GstVaapiContext * context);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_context_overlay_reset (GstVaapiContext * context);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_context_apply_composition (GstVaapiContext * context,
+    GstVideoOverlayComposition * composition);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_CONTEXT_OVERLAY_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapidebug.h b/lib/libv4l-hva/gst/vaapi/gstvaapidebug.h
new file mode 100644
index 0000000..e386755
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapidebug.h
@@ -0,0 +1,33 @@
+/*
+ *  gstvaapidebug.h - VA-API debugging utilities
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_DEBUG_H
+#define GST_VAAPI_DEBUG_H
+
+#include <gst/gstinfo.h>
+
+#if DEBUG
+GST_DEBUG_CATEGORY_EXTERN(gst_debug_vaapi);
+#define GST_CAT_DEFAULT gst_debug_vaapi
+#endif
+
+#endif /* GST_VAAPI_DEBUG_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapidecoder.h b/lib/libv4l-hva/gst/vaapi/gstvaapidecoder.h
new file mode 100644
index 0000000..f98b345
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapidecoder.h
@@ -0,0 +1,134 @@
+/*
+ *  gstvaapidecoder.h - VA decoder abstraction
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_DECODER_H
+#define GST_VAAPI_DECODER_H
+
+#include <gst/gstbuffer.h>
+#include <gst/base/gstadapter.h>
+#include <gst/vaapi/gstvaapisurfaceproxy.h>
+#include <gst/video/gstvideoutils.h>
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_DECODER(obj) \
+    ((GstVaapiDecoder *)(obj))
+
+typedef struct _GstVaapiDecoder GstVaapiDecoder;
+typedef void (*GstVaapiDecoderStateChangedFunc) (GstVaapiDecoder * decoder,
+    const GstVideoCodecState * codec_state, gpointer user_data);
+
+/**
+ * GstVaapiDecoderStatus:
+ * @GST_VAAPI_DECODER_STATUS_SUCCESS: Success.
+ * @GST_VAAPI_DECODER_STATUS_END_OF_STREAM: End-Of-Stream.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_ALLOCATION_FAILED: No memory left.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_INIT_FAILED: Decoder initialization failure.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_UNSUPPORTED_CODEC: Unsupported codec.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_NO_DATA: Not enough input data to decode.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_NO_SURFACE: No surface left to hold the decoded picture.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_INVALID_SURFACE: Invalid surface.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_BITSTREAM_PARSER: Invalid or unsupported bitstream data.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_UNSUPPORTED_PROFILE: Unsupported codec profile.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_UNSUPPORTED_CHROMA_FORMAT: Unsupported chroma format.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_INVALID_PARAMETER: Unsupported parameter.
+ * @GST_VAAPI_DECODER_STATUS_ERROR_UNKNOWN: Unknown error.
+ *
+ * Decoder status for gst_vaapi_decoder_get_surface().
+ */
+typedef enum {
+  GST_VAAPI_DECODER_STATUS_SUCCESS = 0,
+  GST_VAAPI_DECODER_STATUS_END_OF_STREAM,
+  GST_VAAPI_DECODER_STATUS_ERROR_ALLOCATION_FAILED,
+  GST_VAAPI_DECODER_STATUS_ERROR_INIT_FAILED,
+  GST_VAAPI_DECODER_STATUS_ERROR_UNSUPPORTED_CODEC,
+  GST_VAAPI_DECODER_STATUS_ERROR_NO_DATA,
+  GST_VAAPI_DECODER_STATUS_ERROR_NO_SURFACE,
+  GST_VAAPI_DECODER_STATUS_ERROR_INVALID_SURFACE,
+  GST_VAAPI_DECODER_STATUS_ERROR_BITSTREAM_PARSER,
+  GST_VAAPI_DECODER_STATUS_ERROR_UNSUPPORTED_PROFILE,
+  GST_VAAPI_DECODER_STATUS_ERROR_UNSUPPORTED_CHROMA_FORMAT,
+  GST_VAAPI_DECODER_STATUS_ERROR_INVALID_PARAMETER,
+  GST_VAAPI_DECODER_STATUS_ERROR_UNKNOWN = -1
+} GstVaapiDecoderStatus;
+
+GstVaapiDecoder *
+gst_vaapi_decoder_ref (GstVaapiDecoder * decoder);
+
+void
+gst_vaapi_decoder_unref (GstVaapiDecoder * decoder);
+
+void
+gst_vaapi_decoder_replace (GstVaapiDecoder ** old_decoder_ptr,
+    GstVaapiDecoder * new_decoder);
+
+gpointer
+gst_vaapi_decoder_get_user_data (GstVaapiDecoder * decoder);
+
+void
+gst_vaapi_decoder_set_user_data (GstVaapiDecoder * decoder, gpointer user_data);
+
+GstVaapiCodec
+gst_vaapi_decoder_get_codec (GstVaapiDecoder * decoder);
+
+GstVideoCodecState *
+gst_vaapi_decoder_get_codec_state (GstVaapiDecoder * decoder);
+
+void
+gst_vaapi_decoder_set_codec_state_changed_func (GstVaapiDecoder * decoder,
+    GstVaapiDecoderStateChangedFunc func, gpointer user_data);
+
+GstCaps *
+gst_vaapi_decoder_get_caps (GstVaapiDecoder * decoder);
+
+gboolean
+gst_vaapi_decoder_put_buffer (GstVaapiDecoder * decoder, GstBuffer * buf);
+
+GstVaapiDecoderStatus
+gst_vaapi_decoder_get_surface (GstVaapiDecoder * decoder,
+    GstVaapiSurfaceProxy ** out_proxy_ptr);
+
+GstVaapiDecoderStatus
+gst_vaapi_decoder_get_frame (GstVaapiDecoder * decoder,
+    GstVideoCodecFrame ** out_frame_ptr);
+
+GstVaapiDecoderStatus
+gst_vaapi_decoder_get_frame_with_timeout (GstVaapiDecoder * decoder,
+    GstVideoCodecFrame ** out_frame_ptr, guint64 timeout);
+
+GstVaapiDecoderStatus
+gst_vaapi_decoder_parse (GstVaapiDecoder * decoder,
+    GstVideoCodecFrame * frame, GstAdapter * adapter, gboolean at_eos,
+    guint * got_unit_size_ptr, gboolean * got_frame_ptr);
+
+GstVaapiDecoderStatus
+gst_vaapi_decoder_decode (GstVaapiDecoder * decoder,
+    GstVideoCodecFrame * frame);
+
+GstVaapiDecoderStatus
+gst_vaapi_decoder_flush (GstVaapiDecoder * decoder);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_DECODER_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapidecoder_objects.h b/lib/libv4l-hva/gst/vaapi/gstvaapidecoder_objects.h
new file mode 100644
index 0000000..6499574
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapidecoder_objects.h
@@ -0,0 +1,263 @@
+/*
+ *  gstvaapidecoder_objects.h - VA decoder objects
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_DECODER_OBJECTS_H
+#define GST_VAAPI_DECODER_OBJECTS_H
+
+#include <gst/vaapi/gstvaapicodec_objects.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GstVaapiPicture         GstVaapiPicture;
+typedef struct _GstVaapiSlice           GstVaapiSlice;
+
+/* ------------------------------------------------------------------------- */
+/* --- Pictures                                                          --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_PICTURE_CAST(obj) \
+  ((GstVaapiPicture *) (obj))
+
+#define GST_VAAPI_PICTURE(obj) \
+  GST_VAAPI_PICTURE_CAST (obj)
+
+#define GST_VAAPI_IS_PICTURE(obj) \
+  (GST_VAAPI_PICTURE (obj) != NULL)
+
+typedef enum
+{
+  GST_VAAPI_PICTURE_TYPE_NONE = 0,      // Undefined
+  GST_VAAPI_PICTURE_TYPE_I,             // Intra
+  GST_VAAPI_PICTURE_TYPE_P,             // Predicted
+  GST_VAAPI_PICTURE_TYPE_B,             // Bi-directional predicted
+  GST_VAAPI_PICTURE_TYPE_S,             // S(GMC)-VOP (MPEG-4)
+  GST_VAAPI_PICTURE_TYPE_SI,            // Switching Intra
+  GST_VAAPI_PICTURE_TYPE_SP,            // Switching Predicted
+  GST_VAAPI_PICTURE_TYPE_BI,            // BI type (VC-1)
+} GstVaapiPictureType;
+
+/**
+ * GstVaapiPictureFlags:
+ * @GST_VAAPI_PICTURE_FLAG_SKIPPED: skipped frame
+ * @GST_VAAPI_PICTURE_FLAG_REFERENCE: reference frame
+ * @GST_VAAPI_PICTURE_FLAG_OUTPUT: frame was output
+ * @GST_VAAPI_PICTURE_FLAG_INTERLACED: interlaced frame
+ * @GST_VAAPI_PICTURE_FLAG_FF: first-field
+ * @GST_VAAPI_PICTURE_FLAG_TFF: top-field-first
+ * @GST_VAAPI_PICTURE_FLAG_ONEFIELD: only one field is valid
+ * @GST_VAAPI_PICTURE_FLAG_MVC: multiview component
+ * @GST_VAAPI_PICTURE_FLAG_LAST: first flag that can be used by subclasses
+ *
+ * Enum values used for #GstVaapiPicture flags.
+ */
+typedef enum
+{
+  GST_VAAPI_PICTURE_FLAG_SKIPPED    = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 0),
+  GST_VAAPI_PICTURE_FLAG_REFERENCE  = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 1),
+  GST_VAAPI_PICTURE_FLAG_OUTPUT     = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 2),
+  GST_VAAPI_PICTURE_FLAG_INTERLACED = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 3),
+  GST_VAAPI_PICTURE_FLAG_FF         = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 4),
+  GST_VAAPI_PICTURE_FLAG_TFF        = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 5),
+  GST_VAAPI_PICTURE_FLAG_ONEFIELD   = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 6),
+  GST_VAAPI_PICTURE_FLAG_MVC        = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 7),
+  GST_VAAPI_PICTURE_FLAG_LAST       = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 8),
+} GstVaapiPictureFlags;
+
+#define GST_VAAPI_PICTURE_FLAGS         GST_VAAPI_MINI_OBJECT_FLAGS
+#define GST_VAAPI_PICTURE_FLAG_IS_SET   GST_VAAPI_MINI_OBJECT_FLAG_IS_SET
+#define GST_VAAPI_PICTURE_FLAG_SET      GST_VAAPI_MINI_OBJECT_FLAG_SET
+#define GST_VAAPI_PICTURE_FLAG_UNSET    GST_VAAPI_MINI_OBJECT_FLAG_UNSET
+
+#define GST_VAAPI_PICTURE_IS_SKIPPED(picture) \
+  GST_VAAPI_PICTURE_FLAG_IS_SET (picture, GST_VAAPI_PICTURE_FLAG_SKIPPED)
+
+#define GST_VAAPI_PICTURE_IS_REFERENCE(picture) \
+  GST_VAAPI_PICTURE_FLAG_IS_SET (picture, GST_VAAPI_PICTURE_FLAG_REFERENCE)
+
+#define GST_VAAPI_PICTURE_IS_OUTPUT(picture) \
+  GST_VAAPI_PICTURE_FLAG_IS_SET (picture, GST_VAAPI_PICTURE_FLAG_OUTPUT)
+
+#define GST_VAAPI_PICTURE_IS_INTERLACED(picture) \
+  GST_VAAPI_PICTURE_FLAG_IS_SET (picture, GST_VAAPI_PICTURE_FLAG_INTERLACED)
+
+#define GST_VAAPI_PICTURE_IS_FIRST_FIELD(picture) \
+  GST_VAAPI_PICTURE_FLAG_IS_SET (picture, GST_VAAPI_PICTURE_FLAG_FF)
+
+#define GST_VAAPI_PICTURE_IS_TFF(picture) \
+  GST_VAAPI_PICTURE_FLAG_IS_SET (picture, GST_VAAPI_PICTURE_FLAG_TFF)
+
+#define GST_VAAPI_PICTURE_IS_ONEFIELD(picture) \
+  GST_VAAPI_PICTURE_FLAG_IS_SET (picture, GST_VAAPI_PICTURE_FLAG_ONEFIELD)
+
+#define GST_VAAPI_PICTURE_IS_FRAME(picture) \
+  (GST_VAAPI_PICTURE (picture)->structure == GST_VAAPI_PICTURE_STRUCTURE_FRAME)
+
+#define GST_VAAPI_PICTURE_IS_COMPLETE(picture)          \
+  (GST_VAAPI_PICTURE_IS_FRAME (picture) ||              \
+   GST_VAAPI_PICTURE_IS_ONEFIELD (picture) ||           \
+   !GST_VAAPI_PICTURE_IS_FIRST_FIELD (picture))
+
+#define GST_VAAPI_PICTURE_IS_MVC(picture) \
+  (GST_VAAPI_PICTURE_FLAG_IS_SET (picture, GST_VAAPI_PICTURE_FLAG_MVC))
+
+/**
+ * GstVaapiPicture:
+ *
+ * A #GstVaapiCodecObject holding a picture parameter.
+ */
+struct _GstVaapiPicture
+{
+  /*< private >*/
+  GstVaapiCodecObject parent_instance;
+  GstVaapiPicture *parent_picture;
+  GstVideoCodecFrame *frame;
+  GstVaapiSurface *surface;
+  GstVaapiSurfaceProxy *proxy;
+  VABufferID param_id;
+  guint param_size;
+
+  /*< public >*/
+  GstVaapiPictureType type;
+  VASurfaceID surface_id;
+  gpointer param;
+  GPtrArray *slices;
+  GstVaapiIqMatrix *iq_matrix;
+  GstVaapiHuffmanTable *huf_table;
+  GstVaapiBitPlane *bitplane;
+  GstVaapiProbabilityTable *prob_table;
+  GstClockTime pts;
+  gint32 poc;
+  guint16 voc;
+  guint16 view_id;
+  guint structure;
+  GstVaapiRectangle crop_rect;
+  guint has_crop_rect:1;
+};
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_picture_destroy (GstVaapiPicture * picture);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_picture_create (GstVaapiPicture * picture,
+    const GstVaapiCodecObjectConstructorArgs * args);
+
+G_GNUC_INTERNAL
+GstVaapiPicture *
+gst_vaapi_picture_new (GstVaapiDecoder * decoder,
+    gconstpointer param, guint param_size);
+
+G_GNUC_INTERNAL
+GstVaapiPicture *
+gst_vaapi_picture_new_field (GstVaapiPicture * picture);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_picture_add_slice (GstVaapiPicture * picture, GstVaapiSlice * slice);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_picture_decode (GstVaapiPicture * picture);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_picture_output (GstVaapiPicture * picture);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_picture_set_crop_rect (GstVaapiPicture * picture,
+    const GstVaapiRectangle * crop_rect);
+
+#define gst_vaapi_picture_ref(picture) \
+  gst_vaapi_codec_object_ref (picture)
+
+#define gst_vaapi_picture_unref(picture) \
+  gst_vaapi_codec_object_unref (picture)
+
+#define gst_vaapi_picture_replace(old_picture_ptr, new_picture) \
+  gst_vaapi_codec_object_replace (old_picture_ptr, new_picture)
+
+/* ------------------------------------------------------------------------- */
+/* --- Slices                                                            --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_SLICE_CAST(obj) \
+  ((GstVaapiSlice *) (obj))
+
+#define GST_VAAPI_SLICE(obj) \
+  GST_VAAPI_SLICE_CAST (obj)
+
+#define GST_VAAPI_IS_SLICE(obj) \
+  (GST_VAAPI_SLICE (obj) != NULL)
+
+/**
+ * GstVaapiSlice:
+ *
+ * A #GstVaapiCodecObject holding a slice parameter.
+ */
+struct _GstVaapiSlice
+{
+  /*< private >*/
+  GstVaapiCodecObject parent_instance;
+
+  /*< public >*/
+  VABufferID param_id;
+  VABufferID data_id;
+  gpointer param;
+
+  /* Per-slice overrides */
+  GstVaapiHuffmanTable *huf_table;
+};
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_slice_destroy (GstVaapiSlice * slice);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_slice_create (GstVaapiSlice * slice,
+    const GstVaapiCodecObjectConstructorArgs * args);
+
+G_GNUC_INTERNAL
+GstVaapiSlice *
+gst_vaapi_slice_new (GstVaapiDecoder * decoder, gconstpointer param,
+    guint param_size, const guchar * data, guint data_size);
+
+/* ------------------------------------------------------------------------- */
+/* --- Helpers to create codec-dependent objects                         --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_PICTURE_NEW(codec, decoder)                   \
+  gst_vaapi_picture_new (GST_VAAPI_DECODER_CAST (decoder),      \
+      NULL, sizeof (G_PASTE (VAPictureParameterBuffer, codec)))
+
+#define GST_VAAPI_SLICE_NEW(codec, decoder, buf, buf_size)      \
+  gst_vaapi_slice_new (GST_VAAPI_DECODER_CAST (decoder),        \
+      NULL, sizeof (G_PASTE (VASliceParameterBuffer, codec)),   \
+      buf, buf_size)
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_DECODER_OBJECTS_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapidisplay.h b/lib/libv4l-hva/gst/vaapi/gstvaapidisplay.h
new file mode 100644
index 0000000..e7e1935
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapidisplay.h
@@ -0,0 +1,209 @@
+/*
+ *  gstvaapidisplay.h - VA display abstraction
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_DISPLAY_H
+#define GST_VAAPI_DISPLAY_H
+
+#include <va/va.h>
+#include <gst/gst.h>
+#include <gst/vaapi/gstvaapitypes.h>
+#include <gst/vaapi/gstvaapiprofile.h>
+#include <gst/vaapi/video-format.h>
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_DISPLAY(obj) \
+    ((GstVaapiDisplay *)(obj))
+
+typedef struct _GstVaapiDisplayInfo             GstVaapiDisplayInfo;
+typedef struct _GstVaapiDisplay                 GstVaapiDisplay;
+
+/**
+ * GstVaapiDisplayType:
+ * @GST_VAAPI_DISPLAY_TYPE_ANY: Automatic detection of the display type.
+ * @GST_VAAPI_DISPLAY_TYPE_X11: VA/X11 display.
+ * @GST_VAAPI_DISPLAY_TYPE_GLX: VA/GLX display.
+ * @GST_VAAPI_DISPLAY_TYPE_WAYLAND: VA/Wayland display.
+ * @GST_VAAPI_DISPLAY_TYPE_DRM: VA/DRM display.
+ */
+typedef enum
+{
+  GST_VAAPI_DISPLAY_TYPE_ANY = 0,
+  GST_VAAPI_DISPLAY_TYPE_X11,
+  GST_VAAPI_DISPLAY_TYPE_GLX,
+  GST_VAAPI_DISPLAY_TYPE_WAYLAND,
+  GST_VAAPI_DISPLAY_TYPE_DRM,
+} GstVaapiDisplayType;
+
+#define GST_VAAPI_TYPE_DISPLAY_TYPE \
+    (gst_vaapi_display_type_get_type())
+
+GType
+gst_vaapi_display_type_get_type (void) G_GNUC_CONST;
+
+gboolean
+gst_vaapi_display_type_is_compatible (GstVaapiDisplayType type1,
+    GstVaapiDisplayType type2);
+
+/**
+ * GstVaapiDisplayInfo:
+ *
+ * Generic class to retrieve VA display info
+ */
+struct _GstVaapiDisplayInfo
+{
+  GstVaapiDisplay *display;
+  GstVaapiDisplayType display_type;
+  gchar *display_name;
+  VADisplay va_display;
+  gpointer native_display;
+};
+
+/**
+ * GstVaapiDisplayProperties:
+ * @GST_VAAPI_DISPLAY_PROP_RENDER_MODE: rendering mode (#GstVaapiRenderMode).
+ * @GST_VAAPI_DISPLAY_PROP_ROTATION: rotation angle (#GstVaapiRotation).
+ * @GST_VAAPI_DISPLAY_PROP_HUE: hue (float: [-180 ; 180], default: 0).
+ * @GST_VAAPI_DISPLAY_PROP_SATURATION: saturation (float: [0 ; 2], default: 1).
+ * @GST_VAAPI_DISPLAY_PROP_BRIGHTNESS: brightness (float: [-1 ; 1], default: 0).
+ * @GST_VAAPI_DISPLAY_PROP_CONTRAST: contrast (float: [0 ; 2], default: 1).
+ */
+#define GST_VAAPI_DISPLAY_PROP_RENDER_MODE      "render-mode"
+#define GST_VAAPI_DISPLAY_PROP_ROTATION         "rotation"
+#define GST_VAAPI_DISPLAY_PROP_HUE              "hue"
+#define GST_VAAPI_DISPLAY_PROP_SATURATION       "saturation"
+#define GST_VAAPI_DISPLAY_PROP_BRIGHTNESS       "brightness"
+#define GST_VAAPI_DISPLAY_PROP_CONTRAST         "contrast"
+
+GstVaapiDisplay *
+gst_vaapi_display_new_with_display (VADisplay va_display);
+
+GstVaapiDisplay *
+gst_vaapi_display_ref (GstVaapiDisplay * display);
+
+void
+gst_vaapi_display_unref (GstVaapiDisplay * display);
+
+void
+gst_vaapi_display_replace (GstVaapiDisplay ** old_display_ptr,
+    GstVaapiDisplay * new_display);
+
+void
+gst_vaapi_display_lock (GstVaapiDisplay * display);
+
+void
+gst_vaapi_display_unlock (GstVaapiDisplay * display);
+
+void
+gst_vaapi_display_sync (GstVaapiDisplay * display);
+
+void
+gst_vaapi_display_flush (GstVaapiDisplay * display);
+
+GstVaapiDisplayType
+gst_vaapi_display_get_display_type (GstVaapiDisplay * display);
+
+const gchar *
+gst_vaapi_display_get_display_name (GstVaapiDisplay * display);
+
+VADisplay
+gst_vaapi_display_get_display (GstVaapiDisplay * display);
+
+guint
+gst_vaapi_display_get_width (GstVaapiDisplay * display);
+
+guint
+gst_vaapi_display_get_height (GstVaapiDisplay * display);
+
+void
+gst_vaapi_display_get_size (GstVaapiDisplay * display, guint * pwidth,
+    guint * pheight);
+
+void
+gst_vaapi_display_get_pixel_aspect_ratio (GstVaapiDisplay * display,
+    guint * par_n, guint * par_d);
+
+gboolean
+gst_vaapi_display_has_video_processing (GstVaapiDisplay * display);
+
+GArray *
+gst_vaapi_display_get_decode_profiles (GstVaapiDisplay * display);
+
+gboolean
+gst_vaapi_display_has_decoder (GstVaapiDisplay * display,
+    GstVaapiProfile profile, GstVaapiEntrypoint entrypoint);
+
+GArray *
+gst_vaapi_display_get_encode_profiles (GstVaapiDisplay * display);
+
+gboolean
+gst_vaapi_display_has_encoder (GstVaapiDisplay * display,
+    GstVaapiProfile profile, GstVaapiEntrypoint entrypoint);
+
+GArray *
+gst_vaapi_display_get_image_formats (GstVaapiDisplay * display);
+
+gboolean
+gst_vaapi_display_has_image_format (GstVaapiDisplay * display,
+    GstVideoFormat format);
+
+GArray *
+gst_vaapi_display_get_subpicture_formats (GstVaapiDisplay * display);
+
+gboolean
+gst_vaapi_display_has_subpicture_format (GstVaapiDisplay * display,
+    GstVideoFormat format, guint * flags_ptr);
+
+gboolean
+gst_vaapi_display_has_property (GstVaapiDisplay * display, const gchar * name);
+
+gboolean
+gst_vaapi_display_get_property (GstVaapiDisplay * display, const gchar * name,
+    GValue * out_value);
+
+gboolean
+gst_vaapi_display_set_property (GstVaapiDisplay * display, const gchar * name,
+    const GValue * value);
+
+gboolean
+gst_vaapi_display_get_render_mode (GstVaapiDisplay * display,
+    GstVaapiRenderMode * pmode);
+
+gboolean
+gst_vaapi_display_set_render_mode (GstVaapiDisplay * display,
+    GstVaapiRenderMode mode);
+
+GstVaapiRotation
+gst_vaapi_display_get_rotation (GstVaapiDisplay * display);
+
+gboolean
+gst_vaapi_display_set_rotation (GstVaapiDisplay * display,
+    GstVaapiRotation rotation);
+
+const gchar *
+gst_vaapi_display_get_vendor_string (GstVaapiDisplay * display);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_DISPLAY_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapidisplay_priv.h b/lib/libv4l-hva/gst/vaapi/gstvaapidisplay_priv.h
new file mode 100644
index 0000000..b1e1160
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapidisplay_priv.h
@@ -0,0 +1,266 @@
+/*
+ *  gstvaapidisplay_priv.h - Base VA display (private definitions)
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_DISPLAY_PRIV_H
+#define GST_VAAPI_DISPLAY_PRIV_H
+
+#include <gst/vaapi/gstvaapidisplay.h>
+#include <gst/vaapi/gstvaapidisplaycache.h>
+#include "gstvaapiminiobject.h"
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_DISPLAY_CAST(display) \
+    ((GstVaapiDisplay *)(display))
+
+#define GST_VAAPI_DISPLAY_GET_PRIVATE(display) \
+    (&GST_VAAPI_DISPLAY_CAST(display)->priv)
+
+#define GST_VAAPI_DISPLAY_CLASS(klass) \
+    ((GstVaapiDisplayClass *)(klass))
+
+#define GST_VAAPI_IS_DISPLAY_CLASS(klass) \
+    ((klass) != NULL)
+
+#define GST_VAAPI_DISPLAY_GET_CLASS(obj) \
+    GST_VAAPI_DISPLAY_CLASS(GST_VAAPI_MINI_OBJECT_GET_CLASS(obj))
+
+typedef struct _GstVaapiDisplayPrivate          GstVaapiDisplayPrivate;
+typedef struct _GstVaapiDisplayClass            GstVaapiDisplayClass;
+typedef enum _GstVaapiDisplayInitType           GstVaapiDisplayInitType;
+
+typedef void (*GstVaapiDisplayInitFunc) (GstVaapiDisplay * display);
+typedef gboolean (*GstVaapiDisplayBindFunc) (GstVaapiDisplay * display,
+    gpointer native_dpy);
+typedef gboolean (*GstVaapiDisplayOpenFunc) (GstVaapiDisplay * display,
+    const gchar * name);
+typedef void (*GstVaapiDisplayCloseFunc) (GstVaapiDisplay * display);
+typedef void (*GstVaapiDisplayLockFunc) (GstVaapiDisplay * display);
+typedef void (*GstVaapiDisplayUnlockFunc) (GstVaapiDisplay * display);
+typedef void (*GstVaapiDisplaySyncFunc) (GstVaapiDisplay * display);
+typedef void (*GstVaapiDisplayFlushFunc) (GstVaapiDisplay * display);
+typedef gboolean (*GstVaapiDisplayGetInfoFunc) (GstVaapiDisplay * display,
+    GstVaapiDisplayInfo * info);
+typedef void (*GstVaapiDisplayGetSizeFunc) (GstVaapiDisplay * display,
+    guint * pwidth, guint * pheight);
+typedef void (*GstVaapiDisplayGetSizeMFunc) (GstVaapiDisplay * display,
+    guint * pwidth, guint * pheight);
+
+/**
+ * GST_VAAPI_DISPLAY_VADISPLAY:
+ * @display_: a #GstVaapiDisplay
+ *
+ * Macro that evaluates to the #VADisplay of @display.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_DISPLAY_VADISPLAY
+#define GST_VAAPI_DISPLAY_VADISPLAY(display_) \
+    GST_VAAPI_DISPLAY_GET_PRIVATE(display_)->display
+
+/**
+ * GST_VAAPI_DISPLAY_LOCK:
+ * @display: a #GstVaapiDisplay
+ *
+ * Locks @display
+ */
+#undef  GST_VAAPI_DISPLAY_LOCK
+#define GST_VAAPI_DISPLAY_LOCK(display) \
+    gst_vaapi_display_lock(GST_VAAPI_DISPLAY_CAST(display))
+
+/**
+ * GST_VAAPI_DISPLAY_UNLOCK:
+ * @display: a #GstVaapiDisplay
+ *
+ * Unlocks @display
+ */
+#undef  GST_VAAPI_DISPLAY_UNLOCK
+#define GST_VAAPI_DISPLAY_UNLOCK(display) \
+    gst_vaapi_display_unlock(GST_VAAPI_DISPLAY_CAST(display))
+
+/**
+ * GST_VAAPI_DISPLAY_TYPE:
+ * @display: a #GstVaapiDisplay
+ *
+ * Returns the @display type
+ */
+#undef  GST_VAAPI_DISPLAY_TYPE
+#define GST_VAAPI_DISPLAY_TYPE(display) \
+    GST_VAAPI_DISPLAY_GET_PRIVATE(display)->display_type
+
+/**
+ * GST_VAAPI_DISPLAY_TYPES:
+ * @display: a #GstVaapiDisplay
+ *
+ * Returns compatible @display types as a set of flags
+ */
+#undef  GST_VAAPI_DISPLAY_TYPES
+#define GST_VAAPI_DISPLAY_TYPES(display) \
+    gst_vaapi_display_get_display_types(GST_VAAPI_DISPLAY_CAST(display))
+
+/**
+ * GST_VAAPI_DISPLAY_HAS_VPP:
+ * @display: a @GstVaapiDisplay
+ *
+ * Returns whether the @display supports video processing (VA/VPP)
+ */
+#undef  GST_VAAPI_DISPLAY_HAS_VPP
+#define GST_VAAPI_DISPLAY_HAS_VPP(display) \
+    gst_vaapi_display_has_video_processing(GST_VAAPI_DISPLAY_CAST(display))
+
+/**
+ * GST_VAAPI_DISPLAY_CACHE:
+ * @display: a @GstVaapiDisplay
+ *
+ * Returns the #GstVaapiDisplayCache attached to the supplied @display object.
+ */
+#undef  GST_VAAPI_DISPLAY_GET_CACHE
+#define GST_VAAPI_DISPLAY_GET_CACHE(display) \
+    (GST_VAAPI_DISPLAY_GET_PRIVATE (display)->cache)
+
+struct _GstVaapiDisplayPrivate
+{
+  GstVaapiDisplay *parent;
+  GstVaapiDisplayCache *cache;
+  GRecMutex mutex;
+  GstVaapiDisplayType display_type;
+  gchar *display_name;
+  VADisplay display;
+  guint width;
+  guint height;
+  guint width_mm;
+  guint height_mm;
+  guint par_n;
+  guint par_d;
+  GArray *decoders;
+  GArray *encoders;
+  GArray *image_formats;
+  GArray *subpicture_formats;
+  GArray *properties;
+  gchar *vendor_string;
+  guint use_foreign_display:1;
+  guint has_vpp:1;
+  guint has_profiles:1;
+};
+
+/**
+ * GstVaapiDisplay:
+ *
+ * Base class for VA displays.
+ */
+struct _GstVaapiDisplay
+{
+  /*< private >*/
+  GstVaapiMiniObject parent_instance;
+
+  GstVaapiDisplayPrivate priv;
+};
+
+/**
+ * GstVaapiDisplayClass:
+ * @open_display: virtual function to open a display
+ * @close_display: virtual function to close a display
+ * @lock: (optional) virtual function to lock a display
+ * @unlock: (optional) virtual function to unlock a display
+ * @sync: (optional) virtual function to sync a display
+ * @flush: (optional) virtual function to flush pending requests of a display
+ * @get_display: virtual function to retrieve the #GstVaapiDisplayInfo
+ * @get_size: virtual function to retrieve the display dimensions, in pixels
+ * @get_size_mm: virtual function to retrieve the display dimensions, in millimeters
+ *
+ * Base class for VA displays.
+ */
+struct _GstVaapiDisplayClass
+{
+  /*< private >*/
+  GstVaapiMiniObjectClass parent_class;
+
+  /*< protected >*/
+  guint display_types;
+
+  /*< public >*/
+  GstVaapiDisplayInitFunc init;
+  GstVaapiDisplayBindFunc bind_display;
+  GstVaapiDisplayOpenFunc open_display;
+  GstVaapiDisplayCloseFunc close_display;
+  GstVaapiDisplayLockFunc lock;
+  GstVaapiDisplayUnlockFunc unlock;
+  GstVaapiDisplaySyncFunc sync;
+  GstVaapiDisplayFlushFunc flush;
+  GstVaapiDisplayGetInfoFunc get_display;
+  GstVaapiDisplayGetSizeFunc get_size;
+  GstVaapiDisplayGetSizeMFunc get_size_mm;
+};
+
+/* Initialization types */
+enum _GstVaapiDisplayInitType
+{
+  GST_VAAPI_DISPLAY_INIT_FROM_DISPLAY_NAME = 1,
+  GST_VAAPI_DISPLAY_INIT_FROM_NATIVE_DISPLAY,
+  GST_VAAPI_DISPLAY_INIT_FROM_VA_DISPLAY
+};
+
+void
+gst_vaapi_display_class_init (GstVaapiDisplayClass * klass);
+
+GstVaapiDisplay *
+gst_vaapi_display_new (const GstVaapiDisplayClass * klass,
+    GstVaapiDisplayInitType init_type, gpointer init_value);
+
+static inline guint
+gst_vaapi_display_get_display_types (GstVaapiDisplay * display)
+{
+  const GstVaapiDisplayClass *const dpy_class =
+      GST_VAAPI_DISPLAY_GET_CLASS (display);
+
+  return dpy_class->display_types;
+}
+
+/* Inline reference counting for core libgstvaapi library */
+#ifdef IN_LIBGSTVAAPI_CORE
+#define gst_vaapi_display_ref_internal(display) \
+    ((gpointer)gst_vaapi_mini_object_ref(GST_VAAPI_MINI_OBJECT(display)))
+
+#define gst_vaapi_display_unref_internal(display) \
+    gst_vaapi_mini_object_unref(GST_VAAPI_MINI_OBJECT(display))
+
+#define gst_vaapi_display_replace_internal(old_display_ptr, new_display) \
+    gst_vaapi_mini_object_replace((GstVaapiMiniObject **)(old_display_ptr), \
+        GST_VAAPI_MINI_OBJECT(new_display))
+
+#undef  gst_vaapi_display_ref
+#define gst_vaapi_display_ref(display) \
+    gst_vaapi_display_ref_internal((display))
+
+#undef  gst_vaapi_display_unref
+#define gst_vaapi_display_unref(display) \
+    gst_vaapi_display_unref_internal((display))
+
+#undef  gst_vaapi_display_replace
+#define gst_vaapi_display_replace(old_display_ptr, new_display) \
+    gst_vaapi_display_replace_internal((old_display_ptr), (new_display))
+#endif
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_DISPLAY_PRIV_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapidisplaycache.h b/lib/libv4l-hva/gst/vaapi/gstvaapidisplaycache.h
new file mode 100644
index 0000000..f727432
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapidisplaycache.h
@@ -0,0 +1,79 @@
+/*
+ *  gstvaapidisplaycache.h - VA display cache
+ *
+ *  Copyright (C) 2012-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GSTVAAPIDISPLAYCACHE_H
+#define GSTVAAPIDISPLAYCACHE_H
+
+#include "libgstvaapi_priv_check.h"
+#include <gst/vaapi/gstvaapidisplay.h>
+#include "gstvaapiminiobject.h"
+
+typedef struct _GstVaapiDisplayCache            GstVaapiDisplayCache;
+
+G_GNUC_INTERNAL
+GstVaapiDisplayCache *
+gst_vaapi_display_cache_new (void);
+
+#define gst_vaapi_display_cache_ref(cache) \
+    ((GstVaapiDisplayCache *) gst_vaapi_mini_object_ref ( \
+        GST_VAAPI_MINI_OBJECT (cache)))
+#define gst_vaapi_display_cache_unref(cache) \
+    gst_vaapi_mini_object_unref (GST_VAAPI_MINI_OBJECT (cache))
+#define gst_vaapi_display_cache_replace(old_cache_ptr, new_cache) \
+    gst_vaapi_mini_object_replace ((GstVaapiMiniObject **) (old_cache_ptr), \
+        GST_VAAPI_MINI_OBJECT (new_cache))
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_display_cache_is_empty (GstVaapiDisplayCache * cache);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_display_cache_add (GstVaapiDisplayCache * cache,
+    GstVaapiDisplayInfo * info);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_display_cache_remove (GstVaapiDisplayCache * cache,
+    GstVaapiDisplay * display);
+
+const GstVaapiDisplayInfo *
+gst_vaapi_display_cache_lookup (GstVaapiDisplayCache
+    * cache, GstVaapiDisplay * display);
+
+const GstVaapiDisplayInfo *
+gst_vaapi_display_cache_lookup_custom (GstVaapiDisplayCache * cache,
+    GCompareFunc func, gconstpointer data, guint display_types);
+
+const GstVaapiDisplayInfo *
+gst_vaapi_display_cache_lookup_by_va_display (GstVaapiDisplayCache * cache,
+    VADisplay va_display);
+
+const GstVaapiDisplayInfo *
+gst_vaapi_display_cache_lookup_by_native_display (GstVaapiDisplayCache *
+    cache, gpointer native_display, guint display_types);
+
+const GstVaapiDisplayInfo *
+gst_vaapi_display_cache_lookup_by_name (GstVaapiDisplayCache * cache,
+    const gchar * display_name, guint display_types);
+
+#endif /* GSTVAAPIDISPLAYCACHE_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiencoder.h b/lib/libv4l-hva/gst/vaapi/gstvaapiencoder.h
new file mode 100644
index 0000000..0ae80b6
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiencoder.h
@@ -0,0 +1,178 @@
+/*
+ *  gstvaapiencoder.h - VA encoder abstraction
+ *
+ *  Copyright (C) 2013-2014 Intel Corporation
+ *    Author: Wind Yuan <feng.yuan@intel.com>
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_ENCODER_H
+#define GST_VAAPI_ENCODER_H
+
+#include <gst/video/gstvideoutils.h>
+#include <gst/vaapi/gstvaapicodedbufferproxy.h>
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_ENCODER(encoder) \
+    ((GstVaapiEncoder *) (encoder))
+
+typedef struct _GstVaapiEncoder GstVaapiEncoder;
+
+/**
+ * GstVaapiEncoderStatus:
+ * @GST_VAAPI_ENCODER_STATUS_SUCCESS: Success.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_NO_SURFACE: No surface left to encode.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_NO_BUFFER: No coded buffer left to
+ *   hold the encoded picture.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_UNKNOWN: Unknown error.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_ALLOCATION_FAILED: No memory left.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_OPERATION_FAILED: The requested
+ *   operation failed to execute properly. e.g. invalid point in time to
+ *   execute the operation.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_UNSUPPORTED_RATE_CONTROL:
+ *   Unsupported rate control value.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_UNSUPPORTED_PROFILE: Unsupported profile.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_PARAMETER: Invalid parameter.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_BUFFER: Invalid buffer.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_SURFACE: Invalid surface.
+ * @GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_HEADER: Invalid header.
+ *
+ * Set of #GstVaapiEncoder status codes.
+ */
+typedef enum
+{
+  GST_VAAPI_ENCODER_STATUS_SUCCESS = 0,
+  GST_VAAPI_ENCODER_STATUS_NO_SURFACE = 1,
+  GST_VAAPI_ENCODER_STATUS_NO_BUFFER = 2,
+
+  GST_VAAPI_ENCODER_STATUS_ERROR_UNKNOWN = -1,
+  GST_VAAPI_ENCODER_STATUS_ERROR_ALLOCATION_FAILED = -2,
+  GST_VAAPI_ENCODER_STATUS_ERROR_OPERATION_FAILED = -3,
+  GST_VAAPI_ENCODER_STATUS_ERROR_UNSUPPORTED_RATE_CONTROL = -4,
+  GST_VAAPI_ENCODER_STATUS_ERROR_UNSUPPORTED_PROFILE = -5,
+  GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_PARAMETER = -100,
+  GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_BUFFER = -101,
+  GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_SURFACE = -102,
+  GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_HEADER = -103,
+} GstVaapiEncoderStatus;
+
+/**
+ * GstVaapiEncoderTune:
+ * @GST_VAAPI_ENCODER_TUNE_NONE: No tuning option set.
+ * @GST_VAAPI_ENCODER_TUNE_HIGH_COMPRESSION: Tune for higher compression
+ *   ratios, at the expense of lower compatibility at decoding time.
+ * @GST_VAAPI_ENCODER_TUNE_LOW_LATENCY: Tune for low latency decoding.
+ * @GST_VAAPI_ENCODER_TUNE_LOW_POWER: Tune encoder for low power /
+ *   resources conditions. This can affect compression ratio or visual
+ *   quality to match low power conditions.
+ *
+ * The set of tuning options for a #GstVaapiEncoder. By default,
+ * maximum compatibility for decoding is preferred, so the lowest
+ * coding tools are enabled.
+ */
+typedef enum {
+  GST_VAAPI_ENCODER_TUNE_NONE = 0,
+  GST_VAAPI_ENCODER_TUNE_HIGH_COMPRESSION,
+  GST_VAAPI_ENCODER_TUNE_LOW_LATENCY,
+  GST_VAAPI_ENCODER_TUNE_LOW_POWER,
+} GstVaapiEncoderTune;
+
+/**
+ * GstVaapiEncoderProp:
+ * @GST_VAAPI_ENCODER_PROP_RATECONTROL: Rate control (#GstVaapiRateControl).
+ * @GST_VAAPI_ENCODER_PROP_BITRATE: Bitrate expressed in kbps (uint).
+ * @GST_VAAPI_ENCODER_PROP_KEYFRAME_PERIOD: The maximal distance
+ *   between two keyframes (uint).
+ * @GST_VAAPI_ENCODER_PROP_TUNE: The tuning options (#GstVaapiEncoderTune).
+ *
+ * The set of configurable properties for the encoder.
+ */
+typedef enum {
+  GST_VAAPI_ENCODER_PROP_RATECONTROL = 1,
+  GST_VAAPI_ENCODER_PROP_BITRATE,
+  GST_VAAPI_ENCODER_PROP_KEYFRAME_PERIOD,
+  GST_VAAPI_ENCODER_PROP_TUNE,
+} GstVaapiEncoderProp;
+
+/**
+ * GstVaapiEncoderPropInfo:
+ * @prop: the #GstVaapiEncoderProp
+ * @pspec: the #GParamSpec describing the associated configurable value
+ *
+ * A #GstVaapiEncoderProp descriptor.
+ */
+typedef struct {
+  const gint prop;
+  GParamSpec *const pspec;
+} GstVaapiEncoderPropInfo;
+
+GType
+gst_vaapi_encoder_tune_get_type (void) G_GNUC_CONST;
+
+GstVaapiEncoder *
+gst_vaapi_encoder_ref (GstVaapiEncoder * encoder);
+
+void
+gst_vaapi_encoder_unref (GstVaapiEncoder * encoder);
+
+void
+gst_vaapi_encoder_replace (GstVaapiEncoder ** old_encoder_ptr,
+    GstVaapiEncoder * new_encoder);
+
+GstVaapiEncoderStatus
+gst_vaapi_encoder_get_codec_data (GstVaapiEncoder * encoder,
+    GstBuffer ** out_codec_data_ptr);
+
+GstVaapiEncoderStatus
+gst_vaapi_encoder_set_codec_state (GstVaapiEncoder * encoder,
+    GstVideoCodecState * state);
+
+GstVaapiEncoderStatus
+gst_vaapi_encoder_set_property (GstVaapiEncoder * encoder, gint prop_id,
+    const GValue * value);
+
+GstVaapiEncoderStatus
+gst_vaapi_encoder_set_rate_control (GstVaapiEncoder * encoder,
+    GstVaapiRateControl rate_control);
+
+GstVaapiEncoderStatus
+gst_vaapi_encoder_set_bitrate (GstVaapiEncoder * encoder, guint bitrate);
+
+GstVaapiEncoderStatus
+gst_vaapi_encoder_put_frame (GstVaapiEncoder * encoder,
+    GstVideoCodecFrame * frame);
+
+GstVaapiEncoderStatus
+gst_vaapi_encoder_set_keyframe_period (GstVaapiEncoder * encoder,
+    guint keyframe_period);
+
+GstVaapiEncoderStatus
+gst_vaapi_encoder_set_tuning (GstVaapiEncoder * encoder,
+    GstVaapiEncoderTune tuning);
+
+GstVaapiEncoderStatus
+gst_vaapi_encoder_get_buffer_with_timeout (GstVaapiEncoder * encoder,
+    GstVaapiCodedBufferProxy ** out_codedbuf_proxy_ptr, guint64 timeout);
+
+GstVaapiEncoderStatus
+gst_vaapi_encoder_flush (GstVaapiEncoder * encoder);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_ENCODER_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_h264.c b/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_h264.c
new file mode 100644
index 0000000..6ec6441
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_h264.c
@@ -0,0 +1,2922 @@
+/*
+ *  gstvaapiencoder_h264.c - H.264 encoder
+ *
+ *  Copyright (C) 2012-2014 Intel Corporation
+ *    Author: Wind Yuan <feng.yuan@intel.com>
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#include "sysdeps.h"
+#include <va/va.h>
+#include <va/va_enc_h264.h>
+#include <gst/base/gstbitwriter.h>
+#include <gst/codecparsers/gsth264parser.h>
+#include "gstvaapicompat.h"
+#include "gstvaapiencoder_priv.h"
+#include "gstvaapiencoder_h264.h"
+#include "gstvaapiutils_h264.h"
+#include "gstvaapiutils_h264_priv.h"
+#include "gstvaapicodedbufferproxy_priv.h"
+#include "gstvaapisurface.h"
+
+/* don't activate vaapi debug to avoid undefinded symbol */
+/* #define DEBUG 1 */
+#include "gstvaapidebug.h"
+
+/* Define the maximum number of views supported */
+#define MAX_NUM_VIEWS 2
+
+/* Define the maximum IDR period */
+#define MAX_IDR_PERIOD 512
+
+/* Default CPB length (in milliseconds) */
+#define DEFAULT_CPB_LENGTH 1500
+
+/* Scale factor for CPB size (HRD cpb_size_scale: min = 4) */
+#define SX_CPB_SIZE 4
+
+/* Scale factor for bitrate (HRD bit_rate_scale: min = 6) */
+#define SX_BITRATE 6
+
+/* Define default rate control mode ("constant-qp") */
+#define DEFAULT_RATECONTROL GST_VAAPI_RATECONTROL_CQP
+
+/* Supported set of VA rate controls, within this implementation */
+#define SUPPORTED_RATECONTROLS                          \
+  (GST_VAAPI_RATECONTROL_MASK (CQP)  |                  \
+   GST_VAAPI_RATECONTROL_MASK (CBR)  |                  \
+   GST_VAAPI_RATECONTROL_MASK (VBR)  |                  \
+   GST_VAAPI_RATECONTROL_MASK (VBR_CONSTRAINED))
+
+/* Supported set of tuning options, within this implementation */
+#define SUPPORTED_TUNE_OPTIONS                          \
+  (GST_VAAPI_ENCODER_TUNE_MASK (NONE) |                 \
+   GST_VAAPI_ENCODER_TUNE_MASK (HIGH_COMPRESSION))
+
+/* Supported set of VA packed headers, within this implementation */
+#define SUPPORTED_PACKED_HEADERS                \
+  (VA_ENC_PACKED_HEADER_SEQUENCE |              \
+   VA_ENC_PACKED_HEADER_PICTURE  |              \
+   VA_ENC_PACKED_HEADER_SLICE    |              \
+   VA_ENC_PACKED_HEADER_RAW_DATA)
+
+#define GST_H264_NAL_REF_IDC_NONE        0
+#define GST_H264_NAL_REF_IDC_LOW         1
+#define GST_H264_NAL_REF_IDC_MEDIUM      2
+#define GST_H264_NAL_REF_IDC_HIGH        3
+
+typedef struct
+{
+  GstVaapiSurfaceProxy *pic;
+  guint poc;
+  guint frame_num;
+} GstVaapiEncoderH264Ref;
+
+typedef enum
+{
+  GST_VAAPI_ENC_H264_REORD_NONE = 0,
+  GST_VAAPI_ENC_H264_REORD_DUMP_FRAMES = 1,
+  GST_VAAPI_ENC_H264_REORD_WAIT_FRAMES = 2
+} GstVaapiEncH264ReorderState;
+
+/* move _GstVaapiH264ViewRefPool & _GstVaapiH264ViewReorderPool to
+ * gstvaapiencoder_h264.h file */
+#if 0
+typedef struct _GstVaapiH264ViewRefPool
+{
+  GQueue ref_list;
+  guint max_ref_frames;
+  guint max_reflist0_count;
+  guint max_reflist1_count;
+} GstVaapiH264ViewRefPool;
+
+typedef struct _GstVaapiH264ViewReorderPool
+{
+  GQueue reorder_frame_list;
+  guint reorder_state;
+  guint frame_index;
+  guint cur_frame_num;
+  guint cur_present_index;
+} GstVaapiH264ViewReorderPool;
+#endif
+
+static inline gboolean
+_poc_greater_than (guint poc1, guint poc2, guint max_poc)
+{
+  return (((poc1 - poc2) & (max_poc - 1)) < max_poc / 2);
+}
+
+/* Get slice_type value for H.264 specification */
+static guint8
+h264_get_slice_type (GstVaapiPictureType type)
+{
+  switch (type) {
+    case GST_VAAPI_PICTURE_TYPE_I:
+      return GST_H264_I_SLICE;
+    case GST_VAAPI_PICTURE_TYPE_P:
+      return GST_H264_P_SLICE;
+    case GST_VAAPI_PICTURE_TYPE_B:
+      return GST_H264_B_SLICE;
+    default:
+      break;
+  }
+  return -1;
+}
+
+/* Get log2_max_frame_num value for H.264 specification */
+static guint
+h264_get_log2_max_frame_num (guint num)
+{
+  guint ret = 0;
+
+  while (num) {
+    ++ret;
+    num >>= 1;
+  }
+  if (ret <= 4)
+    ret = 4;
+  else if (ret > 10)
+    ret = 10;
+  /* must be greater than 4 */
+  return ret;
+}
+
+/* Determines the cpbBrNalFactor based on the supplied profile */
+static guint
+h264_get_cpb_nal_factor (GstVaapiProfile profile)
+{
+  guint f;
+
+  /* Table A-2 */
+  switch (profile) {
+    case GST_VAAPI_PROFILE_H264_HIGH:
+      f = 1500;
+      break;
+    case GST_VAAPI_PROFILE_H264_HIGH10:
+      f = 3600;
+      break;
+    case GST_VAAPI_PROFILE_H264_HIGH_422:
+    case GST_VAAPI_PROFILE_H264_HIGH_444:
+      f = 4800;
+      break;
+    case GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH:
+    case GST_VAAPI_PROFILE_H264_STEREO_HIGH:
+      f = 1500;                 /* H.10.2.1 (r) */
+      break;
+    default:
+      f = 1200;
+      break;
+  }
+  return f;
+}
+
+/* ------------------------------------------------------------------------- */
+/* --- H.264 Bitstream Writer                                            --- */
+/* ------------------------------------------------------------------------- */
+
+#define WRITE_UINT32(bs, val, nbits) do {                       \
+    if (!gst_bit_writer_put_bits_uint32 (bs, val, nbits)) {     \
+      GST_WARNING ("failed to write uint32, nbits: %d", nbits); \
+      goto bs_error;                                            \
+    }                                                           \
+  } while (0)
+
+#define WRITE_UE(bs, val) do {                  \
+    if (!bs_write_ue (bs, val)) {               \
+      GST_WARNING ("failed to write ue(v)");    \
+      goto bs_error;                            \
+    }                                           \
+  } while (0)
+
+#define WRITE_SE(bs, val) do {                  \
+    if (!bs_write_se (bs, val)) {               \
+      GST_WARNING ("failed to write se(v)");    \
+      goto bs_error;                            \
+    }                                           \
+  } while (0)
+
+/* Write an unsigned integer Exp-Golomb-coded syntax element. i.e. ue(v) */
+static gboolean
+bs_write_ue (GstBitWriter * bs, guint32 value)
+{
+  guint32 size_in_bits = 0;
+  guint32 tmp_value = ++value;
+
+  while (tmp_value) {
+    ++size_in_bits;
+    tmp_value >>= 1;
+  }
+  if (size_in_bits > 1
+      && !gst_bit_writer_put_bits_uint32 (bs, 0, size_in_bits - 1))
+    return FALSE;
+  if (!gst_bit_writer_put_bits_uint32 (bs, value, size_in_bits))
+    return FALSE;
+  return TRUE;
+}
+
+/* Write a signed integer Exp-Golomb-coded syntax element. i.e. se(v) */
+static gboolean
+bs_write_se (GstBitWriter * bs, gint32 value)
+{
+  guint32 new_val;
+
+  if (value <= 0)
+    new_val = -(value << 1);
+  else
+    new_val = (value << 1) - 1;
+
+  if (!bs_write_ue (bs, new_val))
+    return FALSE;
+  return TRUE;
+}
+
+/* Write the NAL unit header */
+static gboolean
+bs_write_nal_header (GstBitWriter * bs, guint32 nal_ref_idc,
+    guint32 nal_unit_type)
+{
+  WRITE_UINT32 (bs, 0, 1);
+  WRITE_UINT32 (bs, nal_ref_idc, 2);
+  WRITE_UINT32 (bs, nal_unit_type, 5);
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write NAL unit header");
+    return FALSE;
+  }
+}
+
+/* Write the MVC NAL unit header extension */
+static gboolean
+bs_write_nal_header_mvc_extension (GstBitWriter * bs,
+    GstVaapiEncPicture * picture, guint32 view_id)
+{
+  guint32 svc_extension_flag = 0;
+  guint32 non_idr_flag = 1;
+  guint32 priority_id = 0;
+  guint32 temporal_id = 0;
+  guint32 anchor_pic_flag = 0;
+  guint32 inter_view_flag = 0;
+
+  if (GST_VAAPI_ENC_PICTURE_IS_IDR (picture))
+    non_idr_flag = 0;
+
+  if (picture->type == GST_VAAPI_PICTURE_TYPE_I)
+    anchor_pic_flag = 1;
+  /* svc_extension_flag == 0 for mvc stream */
+  WRITE_UINT32 (bs, svc_extension_flag, 1);
+
+  WRITE_UINT32 (bs, non_idr_flag, 1);
+  WRITE_UINT32 (bs, priority_id, 6);
+  WRITE_UINT32 (bs, view_id, 10);
+  WRITE_UINT32 (bs, temporal_id, 3);
+  WRITE_UINT32 (bs, anchor_pic_flag, 1);
+  WRITE_UINT32 (bs, inter_view_flag, 1);
+  WRITE_UINT32 (bs, 1, 1);
+
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write NAL unit header");
+    return FALSE;
+  }
+}
+
+/* Write the NAL unit trailing bits */
+static gboolean
+bs_write_trailing_bits (GstBitWriter * bs)
+{
+  if (!gst_bit_writer_put_bits_uint32 (bs, 1, 1))
+    goto bs_error;
+  gst_bit_writer_align_bytes_unchecked (bs, 0);
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write NAL unit trailing bits");
+    return FALSE;
+  }
+}
+
+/* Write an SPS NAL unit */
+static gboolean
+bs_write_sps_data (GstBitWriter * bs,
+    const VAEncSequenceParameterBufferH264 * seq_param, GstVaapiProfile profile,
+    const VAEncMiscParameterHRD * hrd_params)
+{
+  guint8 profile_idc;
+  guint32 constraint_set0_flag, constraint_set1_flag;
+  guint32 constraint_set2_flag, constraint_set3_flag;
+  guint32 gaps_in_frame_num_value_allowed_flag = 0;     // ??
+  gboolean nal_hrd_parameters_present_flag;
+
+  guint32 b_qpprime_y_zero_transform_bypass = 0;
+  guint32 residual_color_transform_flag = 0;
+  guint32 pic_height_in_map_units =
+      (seq_param->seq_fields.bits.frame_mbs_only_flag ?
+      seq_param->picture_height_in_mbs : seq_param->picture_height_in_mbs / 2);
+  guint32 mb_adaptive_frame_field =
+      !seq_param->seq_fields.bits.frame_mbs_only_flag;
+  guint32 i = 0;
+
+  profile_idc = gst_vaapi_utils_h264_get_profile_idc (profile);
+  constraint_set0_flag =        /* A.2.1 (baseline profile constraints) */
+      profile == GST_VAAPI_PROFILE_H264_BASELINE ||
+      profile == GST_VAAPI_PROFILE_H264_CONSTRAINED_BASELINE;
+  constraint_set1_flag =        /* A.2.2 (main profile constraints) */
+      profile == GST_VAAPI_PROFILE_H264_MAIN ||
+      profile == GST_VAAPI_PROFILE_H264_CONSTRAINED_BASELINE;
+  constraint_set2_flag = 0;
+  constraint_set3_flag = 0;
+
+  /* profile_idc */
+  WRITE_UINT32 (bs, profile_idc, 8);
+  /* constraint_set0_flag */
+  WRITE_UINT32 (bs, constraint_set0_flag, 1);
+  /* constraint_set1_flag */
+  WRITE_UINT32 (bs, constraint_set1_flag, 1);
+  /* constraint_set2_flag */
+  WRITE_UINT32 (bs, constraint_set2_flag, 1);
+  /* constraint_set3_flag */
+  WRITE_UINT32 (bs, constraint_set3_flag, 1);
+  /* reserved_zero_4bits */
+  WRITE_UINT32 (bs, 0, 4);
+  /* level_idc */
+  WRITE_UINT32 (bs, seq_param->level_idc, 8);
+  /* seq_parameter_set_id */
+  WRITE_UE (bs, seq_param->seq_parameter_set_id);
+
+  if (profile == GST_VAAPI_PROFILE_H264_HIGH ||
+      profile == GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH ||
+      profile == GST_VAAPI_PROFILE_H264_STEREO_HIGH) {
+    /* for high profile */
+    /* chroma_format_idc  = 1, 4:2:0 */
+    WRITE_UE (bs, seq_param->seq_fields.bits.chroma_format_idc);
+    if (3 == seq_param->seq_fields.bits.chroma_format_idc) {
+      WRITE_UINT32 (bs, residual_color_transform_flag, 1);
+    }
+    /* bit_depth_luma_minus8 */
+    WRITE_UE (bs, seq_param->bit_depth_luma_minus8);
+    /* bit_depth_chroma_minus8 */
+    WRITE_UE (bs, seq_param->bit_depth_chroma_minus8);
+    /* b_qpprime_y_zero_transform_bypass */
+    WRITE_UINT32 (bs, b_qpprime_y_zero_transform_bypass, 1);
+
+    /* seq_scaling_matrix_present_flag  */
+    g_assert (seq_param->seq_fields.bits.seq_scaling_matrix_present_flag == 0);
+    WRITE_UINT32 (bs,
+        seq_param->seq_fields.bits.seq_scaling_matrix_present_flag, 1);
+
+#if 0
+    if (seq_param->seq_fields.bits.seq_scaling_matrix_present_flag) {
+      for (i = 0;
+          i < (seq_param->seq_fields.bits.chroma_format_idc != 3 ? 8 : 12);
+          i++) {
+        gst_bit_writer_put_bits_uint8 (bs,
+            seq_param->seq_fields.bits.seq_scaling_list_present_flag, 1);
+        if (seq_param->seq_fields.bits.seq_scaling_list_present_flag) {
+          g_assert (0);
+          /* FIXME, need write scaling list if seq_scaling_matrix_present_flag ==1 */
+        }
+      }
+    }
+#endif
+  }
+
+  /* log2_max_frame_num_minus4 */
+  WRITE_UE (bs, seq_param->seq_fields.bits.log2_max_frame_num_minus4);
+  /* pic_order_cnt_type */
+  WRITE_UE (bs, seq_param->seq_fields.bits.pic_order_cnt_type);
+
+  if (seq_param->seq_fields.bits.pic_order_cnt_type == 0) {
+    /* log2_max_pic_order_cnt_lsb_minus4 */
+    WRITE_UE (bs, seq_param->seq_fields.bits.log2_max_pic_order_cnt_lsb_minus4);
+  } else if (seq_param->seq_fields.bits.pic_order_cnt_type == 1) {
+    g_assert (0 && "only POC type 0 is supported");
+    WRITE_UINT32 (bs,
+        seq_param->seq_fields.bits.delta_pic_order_always_zero_flag, 1);
+    WRITE_SE (bs, seq_param->offset_for_non_ref_pic);
+    WRITE_SE (bs, seq_param->offset_for_top_to_bottom_field);
+    WRITE_UE (bs, seq_param->num_ref_frames_in_pic_order_cnt_cycle);
+    for (i = 0; i < seq_param->num_ref_frames_in_pic_order_cnt_cycle; i++) {
+      WRITE_SE (bs, seq_param->offset_for_ref_frame[i]);
+    }
+  }
+
+  /* num_ref_frames */
+  WRITE_UE (bs, seq_param->max_num_ref_frames);
+  /* gaps_in_frame_num_value_allowed_flag */
+  WRITE_UINT32 (bs, gaps_in_frame_num_value_allowed_flag, 1);
+
+  /* pic_width_in_mbs_minus1 */
+  WRITE_UE (bs, seq_param->picture_width_in_mbs - 1);
+  /* pic_height_in_map_units_minus1 */
+  WRITE_UE (bs, pic_height_in_map_units - 1);
+  /* frame_mbs_only_flag */
+  WRITE_UINT32 (bs, seq_param->seq_fields.bits.frame_mbs_only_flag, 1);
+
+  if (!seq_param->seq_fields.bits.frame_mbs_only_flag) {        //ONLY mbs
+    g_assert (0 && "only progressive frames encoding is supported");
+    WRITE_UINT32 (bs, mb_adaptive_frame_field, 1);
+  }
+
+  /* direct_8x8_inference_flag, need to be activate (solve issue on decode)*/
+  WRITE_UINT32 (bs, 1, 1);
+
+  /* frame_cropping_flag */
+  WRITE_UINT32 (bs, seq_param->frame_cropping_flag, 1);
+
+  if (seq_param->frame_cropping_flag) {
+    /* frame_crop_left_offset */
+    WRITE_UE (bs, seq_param->frame_crop_left_offset);
+    /* frame_crop_right_offset */
+    WRITE_UE (bs, seq_param->frame_crop_right_offset);
+    /* frame_crop_top_offset */
+    WRITE_UE (bs, seq_param->frame_crop_top_offset);
+    /* frame_crop_bottom_offset */
+    WRITE_UE (bs, seq_param->frame_crop_bottom_offset);
+  }
+
+  /* vui_parameters_present_flag */
+  WRITE_UINT32 (bs, seq_param->vui_parameters_present_flag, 1);
+  if (seq_param->vui_parameters_present_flag) {
+    /* aspect_ratio_info_present_flag */
+    WRITE_UINT32 (bs,
+        seq_param->vui_fields.bits.aspect_ratio_info_present_flag, 1);
+    if (seq_param->vui_fields.bits.aspect_ratio_info_present_flag) {
+      WRITE_UINT32 (bs, seq_param->aspect_ratio_idc, 8);
+      if (seq_param->aspect_ratio_idc == 0xFF) {
+        WRITE_UINT32 (bs, seq_param->sar_width, 16);
+        WRITE_UINT32 (bs, seq_param->sar_height, 16);
+      }
+    }
+
+    /* overscan_info_present_flag */
+    WRITE_UINT32 (bs, 0, 1);
+    /* video_signal_type_present_flag */
+    WRITE_UINT32 (bs, 0, 1);
+    /* chroma_loc_info_present_flag */
+    WRITE_UINT32 (bs, 0, 1);
+
+    /* timing_info_present_flag */
+    WRITE_UINT32 (bs, seq_param->vui_fields.bits.timing_info_present_flag, 1);
+    if (seq_param->vui_fields.bits.timing_info_present_flag) {
+      WRITE_UINT32 (bs, seq_param->num_units_in_tick, 32);
+      WRITE_UINT32 (bs, seq_param->time_scale, 32);
+      WRITE_UINT32 (bs, 1, 1);  /* fixed_frame_rate_flag */
+    }
+
+    /* nal_hrd_parameters_present_flag */
+    nal_hrd_parameters_present_flag = seq_param->bits_per_second > 0;
+    nal_hrd_parameters_present_flag = FALSE;    /* XXX: disabled for now */
+    WRITE_UINT32 (bs, nal_hrd_parameters_present_flag, 1);
+    if (nal_hrd_parameters_present_flag) {
+      /* hrd_parameters */
+      /* cpb_cnt_minus1 */
+      WRITE_UE (bs, 0);
+      WRITE_UINT32 (bs, SX_BITRATE - 6, 4);     /* bit_rate_scale */
+      WRITE_UINT32 (bs, SX_CPB_SIZE - 4, 4);    /* cpb_size_scale */
+
+      for (i = 0; i < 1; ++i) {
+        /* bit_rate_value_minus1[0] */
+        WRITE_UE (bs, (seq_param->bits_per_second >> SX_BITRATE) - 1);
+        /* cpb_size_value_minus1[0] */
+        WRITE_UE (bs, (hrd_params->buffer_size >> SX_CPB_SIZE) - 1);
+        /* cbr_flag[0] */
+        WRITE_UINT32 (bs, 1, 1);
+      }
+      /* initial_cpb_removal_delay_length_minus1 */
+      WRITE_UINT32 (bs, 23, 5);
+      /* cpb_removal_delay_length_minus1 */
+      WRITE_UINT32 (bs, 23, 5);
+      /* dpb_output_delay_length_minus1 */
+      WRITE_UINT32 (bs, 23, 5);
+      /* time_offset_length  */
+      WRITE_UINT32 (bs, 23, 5);
+    }
+
+    /* vcl_hrd_parameters_present_flag */
+    WRITE_UINT32 (bs, 0, 1);
+
+    if (nal_hrd_parameters_present_flag
+        || 0 /*vcl_hrd_parameters_present_flag */ ) {
+      /* low_delay_hrd_flag */
+      WRITE_UINT32 (bs, 0, 1);
+    }
+    /* pic_struct_present_flag */
+    WRITE_UINT32 (bs, 0, 1);
+    /* bs_restriction_flag */
+    WRITE_UINT32 (bs, 0, 1);
+  }
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write SPS NAL unit");
+    return FALSE;
+  }
+}
+
+static gboolean
+bs_write_sps (GstBitWriter * bs,
+    const VAEncSequenceParameterBufferH264 * seq_param, GstVaapiProfile profile,
+    const VAEncMiscParameterHRD * hrd_params)
+{
+  if (!bs_write_sps_data (bs, seq_param, profile, hrd_params))
+    return FALSE;
+
+  /* rbsp_trailing_bits */
+  bs_write_trailing_bits (bs);
+
+  return FALSE;
+}
+
+static gboolean
+bs_write_subset_sps (GstBitWriter * bs,
+    const VAEncSequenceParameterBufferH264 * seq_param, GstVaapiProfile profile,
+    guint num_views, const VAEncMiscParameterHRD * hrd_params)
+{
+  guint32 i, j, k;
+
+  if (!bs_write_sps_data (bs, seq_param, profile, hrd_params))
+    return FALSE;
+
+  if (profile == GST_VAAPI_PROFILE_H264_STEREO_HIGH ||
+      profile == GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH) {
+    guint32 num_views_minus1, num_level_values_signalled_minus1;
+
+    num_views_minus1 = num_views - 1;
+    g_assert (num_views_minus1 < 1024);
+
+    /* bit equal to one */
+    WRITE_UINT32 (bs, 1, 1);
+
+    WRITE_UE (bs, num_views_minus1);
+
+    for (i = 0; i <= num_views_minus1; i++)
+      WRITE_UE (bs, i);
+
+    for (i = 1; i <= num_views_minus1; i++) {
+      guint32 num_anchor_refs_l0 = 0;
+      WRITE_UE (bs, num_anchor_refs_l0);
+      for (j = 0; j < num_anchor_refs_l0; j++)
+        WRITE_UE (bs, 0);
+
+      guint32 num_anchor_refs_l1 = 0;
+      WRITE_UE (bs, num_anchor_refs_l1);
+      for (j = 0; j < num_anchor_refs_l1; j++)
+        WRITE_UE (bs, 0);
+    }
+
+    for (i = 1; i <= num_views_minus1; i++) {
+      guint32 num_non_anchor_refs_l0 = 0;
+      WRITE_UE (bs, num_non_anchor_refs_l0);
+      for (j = 0; j < num_non_anchor_refs_l0; j++)
+        WRITE_UE (bs, 0);
+
+      guint32 num_non_anchor_refs_l1 = 0;
+      WRITE_UE (bs, num_non_anchor_refs_l1);
+      for (j = 0; j < num_non_anchor_refs_l1; j++)
+        WRITE_UE (bs, 0);
+    }
+
+    /* num level values signalled minus1 */
+    num_level_values_signalled_minus1 = 0;
+    g_assert (num_level_values_signalled_minus1 < 64);
+    WRITE_UE (bs, num_level_values_signalled_minus1);
+
+    for (i = 0; i <= num_level_values_signalled_minus1; i++) {
+      guint16 num_applicable_ops_minus1 = 0;
+      g_assert (num_applicable_ops_minus1 < 1024);
+
+      WRITE_UINT32 (bs, seq_param->level_idc, 8);
+      WRITE_UE (bs, num_applicable_ops_minus1);
+
+      for (j = 0; j <= num_applicable_ops_minus1; j++) {
+        guint8 temporal_id = 0;
+        guint16 num_target_views_minus1 = 1;
+
+        WRITE_UINT32 (bs, temporal_id, 3);
+        WRITE_UE (bs, num_target_views_minus1);
+
+        for (k = 0; k <= num_target_views_minus1; k++)
+          WRITE_UE (bs, k);
+
+        WRITE_UE (bs, num_views_minus1);
+      }
+    }
+
+    /* mvc_vui_parameters_present_flag */
+    WRITE_UINT32 (bs, 0, 1);
+  }
+
+  /* additional_extension2_flag */
+  WRITE_UINT32 (bs, 0, 1);
+
+  /* rbsp_trailing_bits */
+  bs_write_trailing_bits (bs);
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write subset SPS NAL unit");
+    return FALSE;
+  }
+  return FALSE;
+}
+
+/* Write a PPS NAL unit */
+static gboolean
+bs_write_pps (GstBitWriter * bs,
+    const VAEncPictureParameterBufferH264 * pic_param, GstVaapiProfile profile)
+{
+  guint32 num_slice_groups_minus1 = 0;
+  guint32 pic_init_qs_minus26 = 0;
+  guint32 redundant_pic_cnt_present_flag = 0;
+
+  /* pic_parameter_set_id */
+  WRITE_UE (bs, pic_param->pic_parameter_set_id);
+  /* seq_parameter_set_id */
+  WRITE_UE (bs, pic_param->seq_parameter_set_id);
+  /* entropy_coding_mode_flag */
+  WRITE_UINT32 (bs, pic_param->pic_fields.bits.entropy_coding_mode_flag, 1);
+  /* pic_order_present_flag */
+  WRITE_UINT32 (bs, pic_param->pic_fields.bits.pic_order_present_flag, 1);
+  /* slice_groups-1 */
+  WRITE_UE (bs, num_slice_groups_minus1);
+
+  if (num_slice_groups_minus1 > 0) {
+     /*FIXME*/ g_assert (0 && "unsupported arbitrary slice ordering (ASO)");
+  }
+  WRITE_UE (bs, pic_param->num_ref_idx_l0_active_minus1);
+  WRITE_UE (bs, pic_param->num_ref_idx_l1_active_minus1);
+  WRITE_UINT32 (bs, pic_param->pic_fields.bits.weighted_pred_flag, 1);
+  WRITE_UINT32 (bs, pic_param->pic_fields.bits.weighted_bipred_idc, 2);
+  /* pic_init_qp_minus26 */
+  WRITE_SE (bs, pic_param->pic_init_qp - 26);
+  /* pic_init_qs_minus26 */
+  WRITE_SE (bs, pic_init_qs_minus26);
+  /* chroma_qp_index_offset */
+  WRITE_SE (bs, pic_param->chroma_qp_index_offset);
+
+  WRITE_UINT32 (bs,
+      pic_param->pic_fields.bits.deblocking_filter_control_present_flag, 1);
+  WRITE_UINT32 (bs, pic_param->pic_fields.bits.constrained_intra_pred_flag, 1);
+  WRITE_UINT32 (bs, redundant_pic_cnt_present_flag, 1);
+
+  /* more_rbsp_data */
+  if (profile == GST_VAAPI_PROFILE_H264_HIGH) {
+    WRITE_UINT32 (bs, pic_param->pic_fields.bits.transform_8x8_mode_flag, 1);
+    WRITE_UINT32 (bs,
+        pic_param->pic_fields.bits.pic_scaling_matrix_present_flag, 1);
+    if (pic_param->pic_fields.bits.pic_scaling_matrix_present_flag) {
+      g_assert (0 && "unsupported scaling lists");
+      /* FIXME */
+      /*
+         for (i = 0; i <
+         (6+(-( (chroma_format_idc ! = 3) ? 2 : 6) * -pic_param->pic_fields.bits.transform_8x8_mode_flag));
+         i++) {
+         gst_bit_writer_put_bits_uint8(bs, pic_param->pic_fields.bits.pic_scaling_list_present_flag, 1);
+         }
+       */
+    }
+    WRITE_SE (bs, pic_param->second_chroma_qp_index_offset);
+  }
+
+  /* rbsp_trailing_bits */
+  bs_write_trailing_bits (bs);
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write PPS NAL unit");
+    return FALSE;
+  }
+}
+
+/* ------------------------------------------------------------------------- */
+/* --- H.264 Encoder                                                     --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_ENCODER_H264_CAST(encoder) \
+    ((GstVaapiEncoderH264 *)(encoder))
+
+/* move _GstVaapiEncoderH264 to gstvaapiencoder_h264.h file */
+#if 0
+struct _GstVaapiEncoderH264
+{
+  GstVaapiEncoder parent_instance;
+
+  GstVaapiProfile profile;
+  GstVaapiLevelH264 level;
+  guint8 profile_idc;
+  guint8 max_profile_idc;
+  guint8 hw_max_profile_idc;
+  guint8 level_idc;
+  guint32 idr_period;
+  guint32 init_qp;
+  guint32 min_qp;
+  guint32 num_slices;
+  guint32 num_bframes;
+  guint32 mb_width;
+  guint32 mb_height;
+  gboolean use_cabac;
+  gboolean use_dct8x8;
+  GstClockTime cts_offset;
+  gboolean config_changed;
+
+  /* frame, poc */
+  guint32 max_frame_num;
+  guint32 log2_max_frame_num;
+  guint32 max_pic_order_cnt;
+  guint32 log2_max_pic_order_cnt;
+  guint32 idr_num;
+  guint8 pic_order_cnt_type;
+  guint8 delta_pic_order_always_zero_flag;
+
+  GstBuffer *sps_data;
+  GstBuffer *subset_sps_data;
+  GstBuffer *pps_data;
+
+  guint bitrate_bits;           // bitrate (bits)
+  guint cpb_length;             // length of CPB buffer (ms)
+  guint cpb_length_bits;        // length of CPB buffer (bits)
+
+  /* MVC */
+  gboolean is_mvc;
+  guint32 view_idx;
+  guint32 num_views;
+  GstVaapiH264ViewRefPool ref_pools[MAX_NUM_VIEWS];
+  GstVaapiH264ViewReorderPool reorder_pools[MAX_NUM_VIEWS];
+};
+#endif
+
+/* Write a Slice NAL unit */
+static gboolean
+bs_write_slice (GstBitWriter * bs,
+    const VAEncSliceParameterBufferH264 * slice_param,
+    GstVaapiEncoderH264 * encoder, GstVaapiEncPicture * picture)
+{
+  const VAEncPictureParameterBufferH264 *const pic_param = picture->param;
+  guint32 field_pic_flag = 0;
+  guint32 ref_pic_list_modification_flag_l0 = 0;
+  guint32 ref_pic_list_modification_flag_l1 = 0;
+  guint32 no_output_of_prior_pics_flag = 0;
+  guint32 long_term_reference_flag = 0;
+  guint32 adaptive_ref_pic_marking_mode_flag = 0;
+
+  /* first_mb_in_slice */
+  WRITE_UE (bs, slice_param->macroblock_address);
+  /* slice_type */
+  WRITE_UE (bs, slice_param->slice_type);
+  /* pic_parameter_set_id */
+  WRITE_UE (bs, slice_param->pic_parameter_set_id);
+  /* frame_num */
+  WRITE_UINT32 (bs, picture->frame_num, encoder->log2_max_frame_num);
+
+  /* XXX: only frames (i.e. non-interlaced) are supported for now */
+  /* frame_mbs_only_flag == 0 */
+
+  /* idr_pic_id */
+  if (GST_VAAPI_ENC_PICTURE_IS_IDR (picture))
+    WRITE_UE (bs, slice_param->idr_pic_id);
+
+  /* XXX: only POC type 0 is supported */
+  if (!encoder->pic_order_cnt_type) {
+    WRITE_UINT32 (bs, slice_param->pic_order_cnt_lsb,
+        encoder->log2_max_pic_order_cnt);
+    /* bottom_field_pic_order_in_frame_present_flag is FALSE */
+    if (pic_param->pic_fields.bits.pic_order_present_flag && !field_pic_flag)
+      WRITE_SE (bs, slice_param->delta_pic_order_cnt_bottom);
+  } else if (encoder->pic_order_cnt_type == 1 &&
+      !encoder->delta_pic_order_always_zero_flag) {
+    WRITE_SE (bs, slice_param->delta_pic_order_cnt[0]);
+    if (pic_param->pic_fields.bits.pic_order_present_flag && !field_pic_flag)
+      WRITE_SE (bs, slice_param->delta_pic_order_cnt[1]);
+  }
+  /* redundant_pic_cnt_present_flag is FALSE, no redundant coded pictures */
+
+  /* only works for B-frames */
+  if (slice_param->slice_type == 1)
+    WRITE_UINT32 (bs, slice_param->direct_spatial_mv_pred_flag, 1);
+
+  /* not supporting SP slices */
+  if (slice_param->slice_type == 0 || slice_param->slice_type == 1) {
+    WRITE_UINT32 (bs, slice_param->num_ref_idx_active_override_flag, 1);
+    if (slice_param->num_ref_idx_active_override_flag) {
+      WRITE_UE (bs, slice_param->num_ref_idx_l0_active_minus1);
+      if (slice_param->slice_type == 1)
+        WRITE_UE (bs, slice_param->num_ref_idx_l1_active_minus1);
+    }
+  }
+  /* XXX: not supporting custom reference picture list modifications */
+  if ((slice_param->slice_type != 2) && (slice_param->slice_type != 4))
+    WRITE_UINT32 (bs, ref_pic_list_modification_flag_l0, 1);
+  if (slice_param->slice_type == 1)
+    WRITE_UINT32 (bs, ref_pic_list_modification_flag_l1, 1);
+
+  /* we have: weighted_pred_flag == FALSE and */
+  /*        : weighted_bipred_idc == FALSE */
+  if ((pic_param->pic_fields.bits.weighted_pred_flag &&
+          (slice_param->slice_type == 0)) ||
+      ((pic_param->pic_fields.bits.weighted_bipred_idc == 1) &&
+          (slice_param->slice_type == 1))) {
+    /* XXXX: add pred_weight_table() */
+  }
+
+  /* dec_ref_pic_marking() */
+  if (slice_param->slice_type == 0 || slice_param->slice_type == 2) {
+    if (GST_VAAPI_ENC_PICTURE_IS_IDR (picture)) {
+      /* no_output_of_prior_pics_flag = 0 */
+      WRITE_UINT32 (bs, no_output_of_prior_pics_flag, 1);
+      /* long_term_reference_flag = 0 */
+      WRITE_UINT32 (bs, long_term_reference_flag, 1);
+    } else {
+      /* only sliding_window reference picture marking mode is supported */
+      /* adpative_ref_pic_marking_mode_flag = 0 */
+      WRITE_UINT32 (bs, adaptive_ref_pic_marking_mode_flag, 1);
+    }
+  }
+
+  /* cabac_init_idc */
+  if (pic_param->pic_fields.bits.entropy_coding_mode_flag &&
+      slice_param->slice_type != 2)
+    WRITE_UE (bs, slice_param->cabac_init_idc);
+  /*slice_qp_delta */
+  WRITE_SE (bs, slice_param->slice_qp_delta);
+
+  /* XXX: only supporting I, P and B type slices */
+  /* no sp_for_switch_flag and no slice_qs_delta */
+
+  if (pic_param->pic_fields.bits.deblocking_filter_control_present_flag) {
+    /* disable_deblocking_filter_idc */
+    WRITE_UE (bs, slice_param->disable_deblocking_filter_idc);
+    if (slice_param->disable_deblocking_filter_idc != 1) {
+      WRITE_SE (bs, slice_param->slice_alpha_c0_offset_div2);
+      WRITE_SE (bs, slice_param->slice_beta_offset_div2);
+    }
+  }
+
+  /* XXX: unsupported arbitrary slice ordering (ASO) */
+  /* num_slic_groups_minus1 should be zero */
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write Slice NAL unit");
+    return FALSE;
+  }
+}
+
+static inline void
+_check_sps_pps_status (GstVaapiEncoderH264 * encoder,
+    const guint8 * nal, guint32 size)
+{
+  guint8 nal_type;
+  gsize ret;
+  gboolean has_subset_sps;
+
+  g_assert (size);
+
+  has_subset_sps = !encoder->is_mvc || (encoder->subset_sps_data != NULL);
+  if (encoder->sps_data && encoder->pps_data && has_subset_sps)
+    return;
+
+  nal_type = nal[0] & 0x1F;
+  switch (nal_type) {
+    case GST_H264_NAL_SPS:
+      encoder->sps_data = gst_buffer_new_allocate (NULL, size, NULL);
+      ret = gst_buffer_fill (encoder->sps_data, 0, nal, size);
+      g_assert (ret == size);
+      break;
+    case GST_H264_NAL_SUBSET_SPS:
+      encoder->subset_sps_data = gst_buffer_new_allocate (NULL, size, NULL);
+      ret = gst_buffer_fill (encoder->subset_sps_data, 0, nal, size);
+      g_assert (ret == size);
+      break;
+    case GST_H264_NAL_PPS:
+      encoder->pps_data = gst_buffer_new_allocate (NULL, size, NULL);
+      ret = gst_buffer_fill (encoder->pps_data, 0, nal, size);
+      g_assert (ret == size);
+      break;
+    default:
+      break;
+  }
+}
+
+/* Determines the largest supported profile by the underlying hardware */
+static gboolean
+ensure_hw_profile_limits (GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiDisplay *const display = GST_VAAPI_ENCODER_DISPLAY (encoder);
+  GArray *profiles;
+  guint i, profile_idc, max_profile_idc;
+
+  if (encoder->hw_max_profile_idc)
+    return TRUE;
+
+  profiles = gst_vaapi_display_get_encode_profiles (display);
+  if (!profiles)
+    return FALSE;
+
+  max_profile_idc = 0;
+  for (i = 0; i < profiles->len; i++) {
+    const GstVaapiProfile profile =
+        g_array_index (profiles, GstVaapiProfile, i);
+    profile_idc = gst_vaapi_utils_h264_get_profile_idc (profile);
+    if (!profile_idc)
+      continue;
+    if (max_profile_idc < profile_idc)
+      max_profile_idc = profile_idc;
+  }
+  g_array_unref (profiles);
+
+  encoder->hw_max_profile_idc = max_profile_idc;
+  return TRUE;
+}
+
+/* Derives the profile supported by the underlying hardware */
+static gboolean
+ensure_hw_profile (GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiDisplay *const display = GST_VAAPI_ENCODER_DISPLAY (encoder);
+  GstVaapiEntrypoint entrypoint = GST_VAAPI_ENTRYPOINT_SLICE_ENCODE;
+  GstVaapiProfile profile, profiles[4];
+  guint i, num_profiles = 0;
+
+  profiles[num_profiles++] = encoder->profile;
+  switch (encoder->profile) {
+    case GST_VAAPI_PROFILE_H264_CONSTRAINED_BASELINE:
+      profiles[num_profiles++] = GST_VAAPI_PROFILE_H264_BASELINE;
+      profiles[num_profiles++] = GST_VAAPI_PROFILE_H264_MAIN;
+      // fall-through
+    case GST_VAAPI_PROFILE_H264_MAIN:
+      profiles[num_profiles++] = GST_VAAPI_PROFILE_H264_HIGH;
+      break;
+    default:
+      break;
+  }
+
+  profile = GST_VAAPI_PROFILE_UNKNOWN;
+  for (i = 0; i < num_profiles; i++) {
+    if (gst_vaapi_display_has_encoder (display, profiles[i], entrypoint)) {
+      profile = profiles[i];
+      break;
+    }
+  }
+  if (profile == GST_VAAPI_PROFILE_UNKNOWN)
+    goto error_unsupported_profile;
+
+  GST_VAAPI_ENCODER_CAST (encoder)->profile = profile;
+  return TRUE;
+
+  /* ERRORS */
+error_unsupported_profile:
+  {
+    GST_ERROR ("unsupported HW profile (0x%08x)", encoder->profile);
+    return FALSE;
+  }
+}
+
+/* Check target decoder constraints */
+static gboolean
+ensure_profile_limits (GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiProfile profile;
+
+  if (!encoder->max_profile_idc
+      || encoder->profile_idc <= encoder->max_profile_idc)
+    return TRUE;
+
+  GST_WARNING ("lowering coding tools to meet target decoder constraints");
+
+  /* Try Main profile coding tools */
+  if (encoder->max_profile_idc < 100) {
+    encoder->use_dct8x8 = FALSE;
+    profile = GST_VAAPI_PROFILE_H264_MAIN;
+  }
+
+  /* Try Constrained Baseline profile coding tools */
+  if (encoder->max_profile_idc < 77) {
+    encoder->num_bframes = 0;
+    encoder->use_cabac = FALSE;
+    profile = GST_VAAPI_PROFILE_H264_CONSTRAINED_BASELINE;
+  }
+
+  encoder->profile = profile;
+  encoder->profile_idc = encoder->max_profile_idc;
+  return TRUE;
+}
+
+/* Derives the minimum profile from the active coding tools */
+static gboolean
+ensure_profile (GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiProfile profile;
+
+  /* Always start from "constrained-baseline" profile for maximum
+     compatibility */
+  profile = GST_VAAPI_PROFILE_H264_CONSTRAINED_BASELINE;
+
+  /* Main profile coding tools */
+  if (encoder->num_bframes > 0 || encoder->use_cabac)
+    profile = GST_VAAPI_PROFILE_H264_MAIN;
+
+  /* High profile coding tools */
+  if (encoder->use_dct8x8)
+    profile = GST_VAAPI_PROFILE_H264_HIGH;
+
+  /* MVC profiles coding tools */
+  if (encoder->num_views == 2)
+    profile = GST_VAAPI_PROFILE_H264_STEREO_HIGH;
+  else if (encoder->num_views > 2)
+    profile = GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH;
+
+  encoder->profile = profile;
+  encoder->profile_idc = gst_vaapi_utils_h264_get_profile_idc (profile);
+  return TRUE;
+}
+
+/* Derives the level from the currently set limits */
+static gboolean
+ensure_level (GstVaapiEncoderH264 * encoder)
+{
+  const guint cpb_factor = h264_get_cpb_nal_factor (encoder->profile);
+  const GstVaapiH264LevelLimits *limits_table;
+  guint i, num_limits, PicSizeMbs, MaxDpbMbs, MaxMBPS;
+
+  PicSizeMbs = encoder->mb_width * encoder->mb_height;
+  MaxDpbMbs = PicSizeMbs * ((encoder->num_bframes) ? 2 : 1);
+  MaxMBPS = gst_util_uint64_scale_int_ceil (PicSizeMbs,
+      GST_VAAPI_ENCODER_FPS_N (encoder), GST_VAAPI_ENCODER_FPS_D (encoder));
+
+  limits_table = gst_vaapi_utils_h264_get_level_limits_table (&num_limits);
+  for (i = 0; i < num_limits; i++) {
+    const GstVaapiH264LevelLimits *const limits = &limits_table[i];
+    if (PicSizeMbs <= limits->MaxFS &&
+        MaxDpbMbs <= limits->MaxDpbMbs &&
+        MaxMBPS <= limits->MaxMBPS && (!encoder->bitrate_bits
+            || encoder->bitrate_bits <= (limits->MaxBR * cpb_factor)) &&
+        (!encoder->cpb_length_bits ||
+            encoder->cpb_length_bits <= (limits->MaxCPB * cpb_factor)))
+      break;
+  }
+  if (i == num_limits)
+    goto error_unsupported_level;
+
+  encoder->level = limits_table[i].level;
+  encoder->level_idc = limits_table[i].level_idc;
+  return TRUE;
+
+  /* ERRORS */
+error_unsupported_level:
+  {
+    GST_ERROR ("failed to find a suitable level matching codec config");
+    return FALSE;
+  }
+}
+
+/* Enable "high-compression" tuning options */
+static gboolean
+ensure_tuning_high_compression (GstVaapiEncoderH264 * encoder)
+{
+  guint8 profile_idc;
+
+  if (!ensure_hw_profile_limits (encoder))
+    return FALSE;
+
+  profile_idc = encoder->hw_max_profile_idc;
+  if (encoder->max_profile_idc && encoder->max_profile_idc < profile_idc)
+    profile_idc = encoder->max_profile_idc;
+
+  /* Tuning options to enable Main profile */
+  if (profile_idc >= 77 && profile_idc != 88) {
+    encoder->use_cabac = TRUE;
+    if (!encoder->num_bframes)
+      encoder->num_bframes = 1;
+  }
+
+  /* Tuning options to enable High profile */
+  if (profile_idc >= 100) {
+    encoder->use_dct8x8 = TRUE;
+  }
+  return TRUE;
+}
+
+/* Ensure tuning options */
+static gboolean
+ensure_tuning (GstVaapiEncoderH264 * encoder)
+{
+  gboolean success;
+
+  switch (GST_VAAPI_ENCODER_TUNE (encoder)) {
+    case GST_VAAPI_ENCODER_TUNE_HIGH_COMPRESSION:
+      success = ensure_tuning_high_compression (encoder);
+      break;
+    default:
+      success = TRUE;
+      break;
+  }
+  return success;
+}
+
+/* Handle new GOP starts */
+static void
+reset_gop_start (GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiH264ViewReorderPool *const reorder_pool =
+      &encoder->reorder_pools[encoder->view_idx];
+
+  reorder_pool->frame_index = 1;
+  reorder_pool->cur_frame_num = 0;
+  reorder_pool->cur_present_index = 0;
+  ++encoder->idr_num;
+}
+
+/* Marks the supplied picture as a B-frame */
+static void
+set_b_frame (GstVaapiEncPicture * pic, GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiH264ViewReorderPool *const reorder_pool =
+      &encoder->reorder_pools[encoder->view_idx];
+
+  g_assert (pic && encoder);
+  g_return_if_fail (pic->type == GST_VAAPI_PICTURE_TYPE_NONE);
+  pic->type = GST_VAAPI_PICTURE_TYPE_B;
+  pic->frame_num = (reorder_pool->cur_frame_num % encoder->max_frame_num);
+}
+
+/* Marks the supplied picture as a P-frame */
+static void
+set_p_frame (GstVaapiEncPicture * pic, GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiH264ViewReorderPool *const reorder_pool =
+      &encoder->reorder_pools[encoder->view_idx];
+
+  g_return_if_fail (pic->type == GST_VAAPI_PICTURE_TYPE_NONE);
+  pic->type = GST_VAAPI_PICTURE_TYPE_P;
+  pic->frame_num = (reorder_pool->cur_frame_num % encoder->max_frame_num);
+}
+
+/* Marks the supplied picture as an I-frame */
+static void
+set_i_frame (GstVaapiEncPicture * pic, GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiH264ViewReorderPool *const reorder_pool =
+      &encoder->reorder_pools[encoder->view_idx];
+
+  g_return_if_fail (pic->type == GST_VAAPI_PICTURE_TYPE_NONE);
+  pic->type = GST_VAAPI_PICTURE_TYPE_I;
+  pic->frame_num = (reorder_pool->cur_frame_num % encoder->max_frame_num);
+
+  g_assert (pic->frame);
+  GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (pic->frame);
+}
+
+/* Marks the supplied picture as an IDR frame */
+static void
+set_idr_frame (GstVaapiEncPicture * pic, GstVaapiEncoderH264 * encoder)
+{
+  g_return_if_fail (pic->type == GST_VAAPI_PICTURE_TYPE_NONE);
+  pic->type = GST_VAAPI_PICTURE_TYPE_I;
+  pic->frame_num = 0;
+  pic->poc = 0;
+  GST_VAAPI_ENC_PICTURE_FLAG_SET (pic, GST_VAAPI_ENC_PICTURE_FLAG_IDR);
+
+  g_assert (pic->frame);
+  GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (pic->frame);
+}
+
+/* Marks the supplied picture a a key-frame */
+static void
+set_key_frame (GstVaapiEncPicture * picture,
+    GstVaapiEncoderH264 * encoder, gboolean is_idr)
+{
+  if (is_idr) {
+    reset_gop_start (encoder);
+    set_idr_frame (picture, encoder);
+  } else
+    set_i_frame (picture, encoder);
+}
+
+/* Fills in VA HRD parameters */
+static void
+fill_hrd_params (GstVaapiEncoderH264 * encoder, VAEncMiscParameterHRD * hrd)
+{
+  if (encoder->bitrate_bits > 0) {
+    hrd->buffer_size = encoder->cpb_length_bits;
+    hrd->initial_buffer_fullness = hrd->buffer_size / 2;
+  } else {
+    hrd->buffer_size = 0;
+    hrd->initial_buffer_fullness = 0;
+  }
+}
+
+/* Adds the supplied sequence header (SPS) to the list of packed
+   headers to pass down as-is to the encoder */
+/* add_packed_sequence_header will be called by libv4l-hva plugin */
+#if 0
+static gboolean
+#endif
+gboolean
+add_packed_sequence_header (GstVaapiEncoderH264 * encoder,
+    GstVaapiEncPicture * picture, GstVaapiEncSequence * sequence)
+{
+  GstVaapiEncPackedHeader *packed_seq;
+  GstBitWriter bs;
+  VAEncPackedHeaderParameterBuffer packed_seq_param = { 0 };
+  const VAEncSequenceParameterBufferH264 *const seq_param = sequence->param;
+  GstVaapiProfile profile = encoder->profile;
+
+  VAEncMiscParameterHRD hrd_params;
+  guint32 data_bit_size;
+  guint8 *data;
+
+  fill_hrd_params (encoder, &hrd_params);
+
+  gst_bit_writer_init (&bs, 128 * 8);
+  WRITE_UINT32 (&bs, 0x00000001, 32);   /* start code */
+  bs_write_nal_header (&bs, GST_H264_NAL_REF_IDC_HIGH, GST_H264_NAL_SPS);
+
+  /* Set High profile for encoding the MVC base view. Otherwise, some
+     traditional decoder cannot recognize MVC profile streams with
+     only the base view in there */
+  if (profile == GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH ||
+      profile == GST_VAAPI_PROFILE_H264_STEREO_HIGH)
+    profile = GST_VAAPI_PROFILE_H264_HIGH;
+
+  bs_write_sps (&bs, seq_param, profile, &hrd_params);
+
+  g_assert (GST_BIT_WRITER_BIT_SIZE (&bs) % 8 == 0);
+  data_bit_size = GST_BIT_WRITER_BIT_SIZE (&bs);
+  data = GST_BIT_WRITER_DATA (&bs);
+
+/* deactivate this part of code to reduce included files */
+#if 0
+  packed_seq_param.type = VAEncPackedHeaderSequence;
+  packed_seq_param.bit_length = data_bit_size;
+  packed_seq_param.has_emulation_bytes = 0;
+
+  packed_seq = gst_vaapi_enc_packed_header_new (GST_VAAPI_ENCODER (encoder),
+      &packed_seq_param, sizeof (packed_seq_param),
+      data, (data_bit_size + 7) / 8);
+  g_assert (packed_seq);
+
+  gst_vaapi_enc_picture_add_packed_header (picture, packed_seq);
+  gst_vaapi_codec_object_replace (&packed_seq, NULL);
+#endif
+
+  /* store sps data */
+  _check_sps_pps_status (encoder, data + 4, data_bit_size / 8 - 4);
+  gst_bit_writer_clear (&bs, TRUE);
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write SPS NAL unit");
+    gst_bit_writer_clear (&bs, TRUE);
+    return FALSE;
+  }
+}
+
+static gboolean
+add_packed_sequence_header_mvc (GstVaapiEncoderH264 * encoder,
+    GstVaapiEncPicture * picture, GstVaapiEncSequence * sequence)
+{
+  GstVaapiEncPackedHeader *packed_seq;
+  GstBitWriter bs;
+  VAEncPackedHeaderParameterBuffer packed_header_param_buffer = { 0 };
+  const VAEncSequenceParameterBufferH264 *const seq_param = sequence->param;
+  VAEncMiscParameterHRD hrd_params;
+  guint32 data_bit_size;
+  guint8 *data;
+
+  fill_hrd_params (encoder, &hrd_params);
+
+  /* non-base layer, pack one subset sps */
+  gst_bit_writer_init (&bs, 128 * 8);
+  WRITE_UINT32 (&bs, 0x00000001, 32);   /* start code */
+  bs_write_nal_header (&bs, GST_H264_NAL_REF_IDC_HIGH, GST_H264_NAL_SUBSET_SPS);
+
+  bs_write_subset_sps (&bs, seq_param, encoder->profile, encoder->num_views,
+      &hrd_params);
+
+  g_assert (GST_BIT_WRITER_BIT_SIZE (&bs) % 8 == 0);
+  data_bit_size = GST_BIT_WRITER_BIT_SIZE (&bs);
+  data = GST_BIT_WRITER_DATA (&bs);
+
+  packed_header_param_buffer.type = VAEncPackedHeaderSequence;
+  packed_header_param_buffer.bit_length = data_bit_size;
+  packed_header_param_buffer.has_emulation_bytes = 0;
+
+  packed_seq = gst_vaapi_enc_packed_header_new (GST_VAAPI_ENCODER (encoder),
+      &packed_header_param_buffer, sizeof (packed_header_param_buffer),
+      data, (data_bit_size + 7) / 8);
+  g_assert (packed_seq);
+
+  gst_vaapi_enc_picture_add_packed_header (picture, packed_seq);
+  gst_vaapi_mini_object_replace ((GstVaapiMiniObject **) & packed_seq, NULL);
+
+  /* store subset sps data */
+  _check_sps_pps_status (encoder, data + 4, data_bit_size / 8 - 4);
+  gst_bit_writer_clear (&bs, TRUE);
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write SPS NAL unit");
+    gst_bit_writer_clear (&bs, TRUE);
+    return FALSE;
+  }
+}
+
+/* Adds the supplied picture header (PPS) to the list of packed
+   headers to pass down as-is to the encoder */
+/* add_packed_picture_header will be called by libv4l-hva plugin */
+#if 0
+static gboolean
+#endif
+gboolean
+add_packed_picture_header (GstVaapiEncoderH264 * encoder,
+    GstVaapiEncPicture * picture)
+{
+  GstVaapiEncPackedHeader *packed_pic;
+  GstBitWriter bs;
+  VAEncPackedHeaderParameterBuffer packed_pic_param = { 0 };
+  const VAEncPictureParameterBufferH264 *const pic_param = picture->param;
+  guint32 data_bit_size;
+  guint8 *data;
+  GstVaapiProfile profile = encoder->profile;
+
+  /* Set High profile for encoding the MVC base view. Otherwise, some
+     traditional decoder cannot recognize MVC profile streams with
+     only the base view in there */
+  if (profile == GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH ||
+      profile == GST_VAAPI_PROFILE_H264_STEREO_HIGH)
+    profile = GST_VAAPI_PROFILE_H264_HIGH;
+
+  gst_bit_writer_init (&bs, 128 * 8);
+  WRITE_UINT32 (&bs, 0x00000001, 32);   /* start code */
+  bs_write_nal_header (&bs, GST_H264_NAL_REF_IDC_HIGH, GST_H264_NAL_PPS);
+  bs_write_pps (&bs, pic_param, profile);
+  g_assert (GST_BIT_WRITER_BIT_SIZE (&bs) % 8 == 0);
+  data_bit_size = GST_BIT_WRITER_BIT_SIZE (&bs);
+  data = GST_BIT_WRITER_DATA (&bs);
+
+/* deactivate this part of code to reduce included files */
+#if 0
+  packed_pic_param.type = VAEncPackedHeaderPicture;
+  packed_pic_param.bit_length = data_bit_size;
+  packed_pic_param.has_emulation_bytes = 0;
+
+  packed_pic = gst_vaapi_enc_packed_header_new (GST_VAAPI_ENCODER (encoder),
+      &packed_pic_param, sizeof (packed_pic_param),
+      data, (data_bit_size + 7) / 8);
+  g_assert (packed_pic);
+
+  gst_vaapi_enc_picture_add_packed_header (picture, packed_pic);
+  gst_vaapi_codec_object_replace (&packed_pic, NULL);
+#endif
+
+  /* store pps data */
+  _check_sps_pps_status (encoder, data + 4, data_bit_size / 8 - 4);
+  gst_bit_writer_clear (&bs, TRUE);
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write PPS NAL unit");
+    gst_bit_writer_clear (&bs, TRUE);
+    return FALSE;
+  }
+}
+
+static gboolean
+get_nal_hdr_attributes (GstVaapiEncPicture * picture,
+    guint8 * nal_ref_idc, guint8 * nal_unit_type)
+{
+  switch (picture->type) {
+    case GST_VAAPI_PICTURE_TYPE_I:
+      *nal_ref_idc = GST_H264_NAL_REF_IDC_HIGH;
+      if (GST_VAAPI_ENC_PICTURE_IS_IDR (picture))
+        *nal_unit_type = GST_H264_NAL_SLICE_IDR;
+      else
+        *nal_unit_type = GST_H264_NAL_SLICE;
+      break;
+    case GST_VAAPI_PICTURE_TYPE_P:
+      *nal_ref_idc = GST_H264_NAL_REF_IDC_MEDIUM;
+      *nal_unit_type = GST_H264_NAL_SLICE;
+      break;
+    case GST_VAAPI_PICTURE_TYPE_B:
+      *nal_ref_idc = GST_H264_NAL_REF_IDC_NONE;
+      *nal_unit_type = GST_H264_NAL_SLICE;
+      break;
+    default:
+      return FALSE;
+  }
+  return TRUE;
+}
+
+/* Adds the supplied prefix nal header to the list of packed
+   headers to pass down as-is to the encoder */
+static gboolean
+add_packed_prefix_nal_header (GstVaapiEncoderH264 * encoder,
+    GstVaapiEncPicture * picture, GstVaapiEncSlice * slice)
+{
+  GstVaapiEncPackedHeader *packed_prefix_nal;
+  GstBitWriter bs;
+  VAEncPackedHeaderParameterBuffer packed_prefix_nal_param = { 0 };
+  guint32 data_bit_size;
+  guint8 *data;
+  guint8 nal_ref_idc, nal_unit_type;
+
+  gst_bit_writer_init (&bs, 128 * 8);
+  WRITE_UINT32 (&bs, 0x00000001, 32);   /* start code */
+
+  if (!get_nal_hdr_attributes (picture, &nal_ref_idc, &nal_unit_type))
+    goto bs_error;
+  nal_unit_type = GST_H264_NAL_PREFIX_UNIT;
+
+  bs_write_nal_header (&bs, nal_ref_idc, nal_unit_type);
+  bs_write_nal_header_mvc_extension (&bs, picture, encoder->view_idx);
+  g_assert (GST_BIT_WRITER_BIT_SIZE (&bs) % 8 == 0);
+  data_bit_size = GST_BIT_WRITER_BIT_SIZE (&bs);
+  data = GST_BIT_WRITER_DATA (&bs);
+
+  packed_prefix_nal_param.type = VAEncPackedHeaderRawData;
+  packed_prefix_nal_param.bit_length = data_bit_size;
+  packed_prefix_nal_param.has_emulation_bytes = 0;
+
+  packed_prefix_nal =
+      gst_vaapi_enc_packed_header_new (GST_VAAPI_ENCODER (encoder),
+      &packed_prefix_nal_param, sizeof (packed_prefix_nal_param), data,
+      (data_bit_size + 7) / 8);
+  g_assert (packed_prefix_nal);
+
+  gst_vaapi_enc_slice_add_packed_header (slice, packed_prefix_nal);
+  gst_vaapi_codec_object_replace (&packed_prefix_nal, NULL);
+
+  gst_bit_writer_clear (&bs, TRUE);
+
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write Prefix NAL unit header");
+    gst_bit_writer_clear (&bs, TRUE);
+    return FALSE;
+  }
+}
+
+/* Adds the supplied slice header to the list of packed
+   headers to pass down as-is to the encoder */
+static gboolean
+add_packed_slice_header (GstVaapiEncoderH264 * encoder,
+    GstVaapiEncPicture * picture, GstVaapiEncSlice * slice)
+{
+  GstVaapiEncPackedHeader *packed_slice;
+  GstBitWriter bs;
+  VAEncPackedHeaderParameterBuffer packed_slice_param = { 0 };
+  const VAEncSliceParameterBufferH264 *const slice_param = slice->param;
+  guint32 data_bit_size;
+  guint8 *data;
+  guint8 nal_ref_idc, nal_unit_type;
+
+  gst_bit_writer_init (&bs, 128 * 8);
+  WRITE_UINT32 (&bs, 0x00000001, 32);   /* start code */
+
+  if (!get_nal_hdr_attributes (picture, &nal_ref_idc, &nal_unit_type))
+    goto bs_error;
+  /* pack nal_unit_header_mvc_extension() for the non base view */
+  if (encoder->is_mvc && encoder->view_idx) {
+    bs_write_nal_header (&bs, nal_ref_idc, GST_H264_NAL_SLICE_EXT);
+    bs_write_nal_header_mvc_extension (&bs, picture, encoder->view_idx);
+  } else
+    bs_write_nal_header (&bs, nal_ref_idc, nal_unit_type);
+
+  bs_write_slice (&bs, slice_param, encoder, picture);
+  data_bit_size = GST_BIT_WRITER_BIT_SIZE (&bs);
+  data = GST_BIT_WRITER_DATA (&bs);
+
+  packed_slice_param.type = VAEncPackedHeaderSlice;
+  packed_slice_param.bit_length = data_bit_size;
+  packed_slice_param.has_emulation_bytes = 0;
+
+  packed_slice = gst_vaapi_enc_packed_header_new (GST_VAAPI_ENCODER (encoder),
+      &packed_slice_param, sizeof (packed_slice_param),
+      data, (data_bit_size + 7) / 8);
+  g_assert (packed_slice);
+
+  gst_vaapi_enc_slice_add_packed_header (slice, packed_slice);
+  gst_vaapi_codec_object_replace (&packed_slice, NULL);
+
+  gst_bit_writer_clear (&bs, TRUE);
+  return TRUE;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_WARNING ("failed to write Slice NAL unit header");
+    gst_bit_writer_clear (&bs, TRUE);
+    return FALSE;
+  }
+}
+
+/* Reference picture management */
+static void
+reference_pic_free (GstVaapiEncoderH264 * encoder, GstVaapiEncoderH264Ref * ref)
+{
+  if (!ref)
+    return;
+  if (ref->pic)
+    gst_vaapi_encoder_release_surface (GST_VAAPI_ENCODER (encoder), ref->pic);
+  g_slice_free (GstVaapiEncoderH264Ref, ref);
+}
+
+static inline GstVaapiEncoderH264Ref *
+reference_pic_create (GstVaapiEncoderH264 * encoder,
+    GstVaapiEncPicture * picture, GstVaapiSurfaceProxy * surface)
+{
+  GstVaapiEncoderH264Ref *const ref = g_slice_new0 (GstVaapiEncoderH264Ref);
+
+  ref->pic = surface;
+  ref->frame_num = picture->frame_num;
+  ref->poc = picture->poc;
+  return ref;
+}
+
+static gboolean
+reference_list_update (GstVaapiEncoderH264 * encoder,
+    GstVaapiEncPicture * picture, GstVaapiSurfaceProxy * surface)
+{
+  GstVaapiEncoderH264Ref *ref;
+  GstVaapiH264ViewRefPool *const ref_pool =
+      &encoder->ref_pools[encoder->view_idx];
+
+  if (GST_VAAPI_PICTURE_TYPE_B == picture->type) {
+    gst_vaapi_encoder_release_surface (GST_VAAPI_ENCODER (encoder), surface);
+    return TRUE;
+  }
+  if (GST_VAAPI_ENC_PICTURE_IS_IDR (picture)) {
+    while (!g_queue_is_empty (&ref_pool->ref_list))
+      reference_pic_free (encoder, g_queue_pop_head (&ref_pool->ref_list));
+  } else if (g_queue_get_length (&ref_pool->ref_list) >=
+      ref_pool->max_ref_frames) {
+    reference_pic_free (encoder, g_queue_pop_head (&ref_pool->ref_list));
+  }
+  ref = reference_pic_create (encoder, picture, surface);
+  g_queue_push_tail (&ref_pool->ref_list, ref);
+  g_assert (g_queue_get_length (&ref_pool->ref_list) <=
+      ref_pool->max_ref_frames);
+  return TRUE;
+}
+
+static gboolean
+reference_list_init (GstVaapiEncoderH264 * encoder,
+    GstVaapiEncPicture * picture,
+    GstVaapiEncoderH264Ref ** reflist_0,
+    guint * reflist_0_count,
+    GstVaapiEncoderH264Ref ** reflist_1, guint * reflist_1_count)
+{
+  GstVaapiEncoderH264Ref *tmp;
+  GstVaapiH264ViewRefPool *const ref_pool =
+      &encoder->ref_pools[encoder->view_idx];
+  GList *iter, *list_0_start = NULL, *list_1_start = NULL;
+  guint count;
+
+  *reflist_0_count = 0;
+  *reflist_1_count = 0;
+  if (picture->type == GST_VAAPI_PICTURE_TYPE_I)
+    return TRUE;
+
+  iter = g_queue_peek_tail_link (&ref_pool->ref_list);
+  for (; iter; iter = g_list_previous (iter)) {
+    tmp = (GstVaapiEncoderH264Ref *) iter->data;
+    g_assert (tmp && tmp->poc != picture->poc);
+    if (_poc_greater_than (picture->poc, tmp->poc, encoder->max_pic_order_cnt)) {
+      list_0_start = iter;
+      list_1_start = g_list_next (iter);
+      break;
+    }
+  }
+
+  /* order reflist_0 */
+  g_assert (list_0_start);
+  iter = list_0_start;
+  count = 0;
+  for (; iter; iter = g_list_previous (iter)) {
+    reflist_0[count] = (GstVaapiEncoderH264Ref *) iter->data;
+    ++count;
+  }
+  *reflist_0_count = count;
+
+  if (picture->type != GST_VAAPI_PICTURE_TYPE_B)
+    return TRUE;
+
+  /* order reflist_1 */
+  count = 0;
+  iter = list_1_start;
+  for (; iter; iter = g_list_next (iter)) {
+    reflist_1[count] = (GstVaapiEncoderH264Ref *) iter->data;
+    ++count;
+  }
+  *reflist_1_count = count;
+  return TRUE;
+}
+
+/* Fills in VA sequence parameter buffer */
+static gboolean
+fill_sequence (GstVaapiEncoderH264 * encoder, GstVaapiEncSequence * sequence)
+{
+  VAEncSequenceParameterBufferH264 *const seq_param = sequence->param;
+  GstVaapiH264ViewRefPool *const ref_pool =
+      &encoder->ref_pools[encoder->view_idx];
+
+  memset (seq_param, 0, sizeof (VAEncSequenceParameterBufferH264));
+  seq_param->seq_parameter_set_id = encoder->view_idx;
+  seq_param->level_idc = encoder->level_idc;
+  seq_param->intra_period = GST_VAAPI_ENCODER_KEYFRAME_PERIOD (encoder);
+  seq_param->ip_period = 1 + encoder->num_bframes;
+  seq_param->bits_per_second = encoder->bitrate_bits;
+
+  seq_param->max_num_ref_frames = ref_pool->max_ref_frames;
+  seq_param->picture_width_in_mbs = encoder->mb_width;
+  seq_param->picture_height_in_mbs = encoder->mb_height;
+
+  /*sequence field values */
+  seq_param->seq_fields.value = 0;
+  seq_param->seq_fields.bits.chroma_format_idc = 1;
+  seq_param->seq_fields.bits.frame_mbs_only_flag = 1;
+  seq_param->seq_fields.bits.mb_adaptive_frame_field_flag = FALSE;
+  seq_param->seq_fields.bits.seq_scaling_matrix_present_flag = FALSE;
+  /* direct_8x8_inference_flag default false */
+  seq_param->seq_fields.bits.direct_8x8_inference_flag = FALSE;
+  g_assert (encoder->log2_max_frame_num >= 4);
+  seq_param->seq_fields.bits.log2_max_frame_num_minus4 =
+      encoder->log2_max_frame_num - 4;
+  /* picture order count */
+  encoder->pic_order_cnt_type = seq_param->seq_fields.bits.pic_order_cnt_type =
+      0;
+  g_assert (encoder->log2_max_pic_order_cnt >= 4);
+  seq_param->seq_fields.bits.log2_max_pic_order_cnt_lsb_minus4 =
+      encoder->log2_max_pic_order_cnt - 4;
+
+  seq_param->bit_depth_luma_minus8 = 0;
+  seq_param->bit_depth_chroma_minus8 = 0;
+
+  /* not used if pic_order_cnt_type == 0 */
+  if (seq_param->seq_fields.bits.pic_order_cnt_type == 1) {
+    encoder->delta_pic_order_always_zero_flag =
+        seq_param->seq_fields.bits.delta_pic_order_always_zero_flag = TRUE;
+    seq_param->num_ref_frames_in_pic_order_cnt_cycle = 0;
+    seq_param->offset_for_non_ref_pic = 0;
+    seq_param->offset_for_top_to_bottom_field = 0;
+    memset (seq_param->offset_for_ref_frame, 0,
+        sizeof (seq_param->offset_for_ref_frame));
+  }
+
+  /* frame_cropping_flag */
+  if ((GST_VAAPI_ENCODER_WIDTH (encoder) & 15) ||
+      (GST_VAAPI_ENCODER_HEIGHT (encoder) & 15)) {
+    static const guint SubWidthC[] = { 1, 2, 2, 1 };
+    static const guint SubHeightC[] = { 1, 2, 1, 1 };
+    const guint CropUnitX =
+        SubWidthC[seq_param->seq_fields.bits.chroma_format_idc];
+    const guint CropUnitY =
+        SubHeightC[seq_param->seq_fields.bits.chroma_format_idc] *
+        (2 - seq_param->seq_fields.bits.frame_mbs_only_flag);
+
+    seq_param->frame_cropping_flag = 1;
+    seq_param->frame_crop_left_offset = 0;
+    seq_param->frame_crop_right_offset =
+        (16 * encoder->mb_width -
+        GST_VAAPI_ENCODER_WIDTH (encoder)) / CropUnitX;
+    seq_param->frame_crop_top_offset = 0;
+    seq_param->frame_crop_bottom_offset =
+        (16 * encoder->mb_height -
+        GST_VAAPI_ENCODER_HEIGHT (encoder)) / CropUnitY;
+  }
+
+  /* VUI parameters are always set, at least for timing_info (framerate) */
+  seq_param->vui_parameters_present_flag = TRUE;
+  if (seq_param->vui_parameters_present_flag) {
+    seq_param->vui_fields.bits.aspect_ratio_info_present_flag = FALSE;
+    if (seq_param->vui_fields.bits.aspect_ratio_info_present_flag) {
+      const GstVideoInfo *const vip = GST_VAAPI_ENCODER_VIDEO_INFO (encoder);
+      seq_param->sar_width = GST_VIDEO_INFO_PAR_N (vip);
+      seq_param->sar_height = GST_VIDEO_INFO_PAR_D (vip);
+    }
+    seq_param->vui_fields.bits.bitstream_restriction_flag = FALSE;
+    /* if vui_parameters_present_flag is TRUE and sps data belongs to
+     * subset sps, timing_info_preset_flag should be zero (H.7.4.2.1.1) */
+    seq_param->vui_fields.bits.timing_info_present_flag = !encoder->view_idx;
+    if (seq_param->vui_fields.bits.timing_info_present_flag) {
+      seq_param->num_units_in_tick = GST_VAAPI_ENCODER_FPS_D (encoder);
+      seq_param->time_scale = GST_VAAPI_ENCODER_FPS_N (encoder) * 2;
+    }
+  }
+  return TRUE;
+}
+
+/* Fills in VA picture parameter buffer */
+static gboolean
+fill_picture (GstVaapiEncoderH264 * encoder, GstVaapiEncPicture * picture,
+    GstVaapiCodedBuffer * codedbuf, GstVaapiSurfaceProxy * surface)
+{
+  VAEncPictureParameterBufferH264 *const pic_param = picture->param;
+  GstVaapiH264ViewRefPool *const ref_pool =
+      &encoder->ref_pools[encoder->view_idx];
+  GstVaapiEncoderH264Ref *ref_pic;
+  GList *reflist;
+  guint i;
+
+  memset (pic_param, 0, sizeof (VAEncPictureParameterBufferH264));
+
+  /* reference list,  */
+  pic_param->CurrPic.picture_id = GST_VAAPI_SURFACE_PROXY_SURFACE_ID (surface);
+  pic_param->CurrPic.TopFieldOrderCnt = picture->poc;
+  i = 0;
+  if (picture->type != GST_VAAPI_PICTURE_TYPE_I) {
+    for (reflist = g_queue_peek_head_link (&ref_pool->ref_list);
+        reflist; reflist = g_list_next (reflist)) {
+      ref_pic = reflist->data;
+      g_assert (ref_pic && ref_pic->pic &&
+          GST_VAAPI_SURFACE_PROXY_SURFACE_ID (ref_pic->pic) != VA_INVALID_ID);
+
+      pic_param->ReferenceFrames[i].picture_id =
+          GST_VAAPI_SURFACE_PROXY_SURFACE_ID (ref_pic->pic);
+      ++i;
+    }
+    g_assert (i <= 16 && i <= ref_pool->max_ref_frames);
+  }
+  for (; i < 16; ++i) {
+    pic_param->ReferenceFrames[i].picture_id = VA_INVALID_ID;
+  }
+  pic_param->coded_buf = GST_VAAPI_OBJECT_ID (codedbuf);
+
+  pic_param->pic_parameter_set_id = encoder->view_idx;
+  pic_param->seq_parameter_set_id = encoder->view_idx;
+  pic_param->last_picture = 0;  /* means last encoding picture */
+  pic_param->frame_num = picture->frame_num;
+  pic_param->pic_init_qp = encoder->init_qp;
+  pic_param->num_ref_idx_l0_active_minus1 =
+      (ref_pool->max_reflist0_count ? (ref_pool->max_reflist0_count - 1) : 0);
+  pic_param->num_ref_idx_l1_active_minus1 =
+      (ref_pool->max_reflist1_count ? (ref_pool->max_reflist1_count - 1) : 0);
+  pic_param->chroma_qp_index_offset = 0;
+  pic_param->second_chroma_qp_index_offset = 0;
+
+  /* set picture fields */
+  pic_param->pic_fields.value = 0;
+  pic_param->pic_fields.bits.idr_pic_flag =
+      GST_VAAPI_ENC_PICTURE_IS_IDR (picture);
+  pic_param->pic_fields.bits.reference_pic_flag =
+      (picture->type != GST_VAAPI_PICTURE_TYPE_B);
+  pic_param->pic_fields.bits.entropy_coding_mode_flag = encoder->use_cabac;
+  pic_param->pic_fields.bits.weighted_pred_flag = FALSE;
+  pic_param->pic_fields.bits.weighted_bipred_idc = 0;
+  pic_param->pic_fields.bits.constrained_intra_pred_flag = 0;
+  pic_param->pic_fields.bits.transform_8x8_mode_flag = encoder->use_dct8x8;
+  /* enable debloking */
+  pic_param->pic_fields.bits.deblocking_filter_control_present_flag = TRUE;
+  pic_param->pic_fields.bits.redundant_pic_cnt_present_flag = FALSE;
+  /* bottom_field_pic_order_in_frame_present_flag */
+  pic_param->pic_fields.bits.pic_order_present_flag = FALSE;
+  pic_param->pic_fields.bits.pic_scaling_matrix_present_flag = FALSE;
+
+  return TRUE;
+}
+
+/* Adds slice headers to picture */
+static gboolean
+add_slice_headers (GstVaapiEncoderH264 * encoder, GstVaapiEncPicture * picture,
+    GstVaapiEncoderH264Ref ** reflist_0, guint reflist_0_count,
+    GstVaapiEncoderH264Ref ** reflist_1, guint reflist_1_count)
+{
+  VAEncSliceParameterBufferH264 *slice_param;
+  GstVaapiEncSlice *slice;
+  guint slice_of_mbs, slice_mod_mbs, cur_slice_mbs;
+  guint mb_size;
+  guint last_mb_index;
+  guint i_slice, i_ref;
+
+  g_assert (picture);
+
+  mb_size = encoder->mb_width * encoder->mb_height;
+
+  g_assert (encoder->num_slices && encoder->num_slices < mb_size);
+  slice_of_mbs = mb_size / encoder->num_slices;
+  slice_mod_mbs = mb_size % encoder->num_slices;
+  last_mb_index = 0;
+  for (i_slice = 0; i_slice < encoder->num_slices; ++i_slice) {
+    cur_slice_mbs = slice_of_mbs;
+    if (slice_mod_mbs) {
+      ++cur_slice_mbs;
+      --slice_mod_mbs;
+    }
+    slice = GST_VAAPI_ENC_SLICE_NEW (H264, encoder);
+    g_assert (slice && slice->param_id != VA_INVALID_ID);
+    slice_param = slice->param;
+
+    memset (slice_param, 0, sizeof (VAEncSliceParameterBufferH264));
+    slice_param->macroblock_address = last_mb_index;
+    slice_param->num_macroblocks = cur_slice_mbs;
+    slice_param->macroblock_info = VA_INVALID_ID;
+    slice_param->slice_type = h264_get_slice_type (picture->type);
+    g_assert (slice_param->slice_type != -1);
+    slice_param->pic_parameter_set_id = encoder->view_idx;
+    slice_param->idr_pic_id = encoder->idr_num;
+    slice_param->pic_order_cnt_lsb = picture->poc;
+
+    /* not used if pic_order_cnt_type = 0 */
+    slice_param->delta_pic_order_cnt_bottom = 0;
+    memset (slice_param->delta_pic_order_cnt, 0,
+        sizeof (slice_param->delta_pic_order_cnt));
+
+    /* only works for B frames */
+    slice_param->direct_spatial_mv_pred_flag = FALSE;
+    /* default equal to picture parameters */
+    slice_param->num_ref_idx_active_override_flag = FALSE;
+    if (picture->type != GST_VAAPI_PICTURE_TYPE_I && reflist_0_count > 0)
+      slice_param->num_ref_idx_l0_active_minus1 = reflist_0_count - 1;
+    else
+      slice_param->num_ref_idx_l0_active_minus1 = 0;
+    if (picture->type == GST_VAAPI_PICTURE_TYPE_B && reflist_1_count > 0)
+      slice_param->num_ref_idx_l1_active_minus1 = reflist_1_count - 1;
+    else
+      slice_param->num_ref_idx_l1_active_minus1 = 0;
+    g_assert (slice_param->num_ref_idx_l0_active_minus1 == 0);
+    g_assert (slice_param->num_ref_idx_l1_active_minus1 == 0);
+
+    i_ref = 0;
+    if (picture->type != GST_VAAPI_PICTURE_TYPE_I) {
+      for (; i_ref < reflist_0_count; ++i_ref) {
+        slice_param->RefPicList0[i_ref].picture_id =
+            GST_VAAPI_SURFACE_PROXY_SURFACE_ID (reflist_0[i_ref]->pic);
+      }
+      g_assert (i_ref == 1);
+    }
+    for (; i_ref < G_N_ELEMENTS (slice_param->RefPicList0); ++i_ref) {
+      slice_param->RefPicList0[i_ref].picture_id = VA_INVALID_SURFACE;
+    }
+
+    i_ref = 0;
+    if (picture->type == GST_VAAPI_PICTURE_TYPE_B) {
+      for (; i_ref < reflist_1_count; ++i_ref) {
+        slice_param->RefPicList1[i_ref].picture_id =
+            GST_VAAPI_SURFACE_PROXY_SURFACE_ID (reflist_1[i_ref]->pic);
+      }
+      g_assert (i_ref == 1);
+    }
+    for (; i_ref < G_N_ELEMENTS (slice_param->RefPicList1); ++i_ref) {
+      slice_param->RefPicList1[i_ref].picture_id = VA_INVALID_SURFACE;
+    }
+
+    /* not used if  pic_param.pic_fields.bits.weighted_pred_flag == FALSE */
+    slice_param->luma_log2_weight_denom = 0;
+    slice_param->chroma_log2_weight_denom = 0;
+    slice_param->luma_weight_l0_flag = FALSE;
+    memset (slice_param->luma_weight_l0, 0,
+        sizeof (slice_param->luma_weight_l0));
+    memset (slice_param->luma_offset_l0, 0,
+        sizeof (slice_param->luma_offset_l0));
+    slice_param->chroma_weight_l0_flag = FALSE;
+    memset (slice_param->chroma_weight_l0, 0,
+        sizeof (slice_param->chroma_weight_l0));
+    memset (slice_param->chroma_offset_l0, 0,
+        sizeof (slice_param->chroma_offset_l0));
+    slice_param->luma_weight_l1_flag = FALSE;
+    memset (slice_param->luma_weight_l1, 0,
+        sizeof (slice_param->luma_weight_l1));
+    memset (slice_param->luma_offset_l1, 0,
+        sizeof (slice_param->luma_offset_l1));
+    slice_param->chroma_weight_l1_flag = FALSE;
+    memset (slice_param->chroma_weight_l1, 0,
+        sizeof (slice_param->chroma_weight_l1));
+    memset (slice_param->chroma_offset_l1, 0,
+        sizeof (slice_param->chroma_offset_l1));
+
+    slice_param->cabac_init_idc = 0;
+    slice_param->slice_qp_delta = encoder->init_qp - encoder->min_qp;
+    if (slice_param->slice_qp_delta > 4)
+      slice_param->slice_qp_delta = 4;
+    slice_param->disable_deblocking_filter_idc = 0;
+    slice_param->slice_alpha_c0_offset_div2 = 2;
+    slice_param->slice_beta_offset_div2 = 2;
+
+    /* set calculation for next slice */
+    last_mb_index += cur_slice_mbs;
+
+    /* add packed Prefix NAL unit before each Coded slice NAL in base view */
+    if (encoder->is_mvc && !encoder->view_idx &&
+        (GST_VAAPI_ENCODER_PACKED_HEADERS (encoder) &
+            VA_ENC_PACKED_HEADER_RAW_DATA)
+        && !add_packed_prefix_nal_header (encoder, picture, slice))
+      goto error_create_packed_prefix_nal_hdr;
+    if ((GST_VAAPI_ENCODER_PACKED_HEADERS (encoder) &
+            VA_ENC_PACKED_HEADER_SLICE)
+        && !add_packed_slice_header (encoder, picture, slice))
+      goto error_create_packed_slice_hdr;
+
+    gst_vaapi_enc_picture_add_slice (picture, slice);
+    gst_vaapi_codec_object_replace (&slice, NULL);
+  }
+  g_assert (last_mb_index == mb_size);
+  return TRUE;
+
+error_create_packed_slice_hdr:
+  {
+    GST_ERROR ("failed to create packed slice header buffer");
+    gst_vaapi_codec_object_replace (&slice, NULL);
+    return FALSE;
+  }
+error_create_packed_prefix_nal_hdr:
+  {
+    GST_ERROR ("failed to create packed prefix nal header buffer");
+    gst_vaapi_codec_object_replace (&slice, NULL);
+    return FALSE;
+  }
+}
+
+/* Generates and submits SPS header accordingly into the bitstream */
+static gboolean
+ensure_sequence (GstVaapiEncoderH264 * encoder, GstVaapiEncPicture * picture)
+{
+  GstVaapiEncSequence *sequence = NULL;
+
+  /* submit an SPS header before every new I-frame, if codec config changed */
+  if (!encoder->config_changed || picture->type != GST_VAAPI_PICTURE_TYPE_I)
+    return TRUE;
+
+  sequence = GST_VAAPI_ENC_SEQUENCE_NEW (H264, encoder);
+  if (!sequence || !fill_sequence (encoder, sequence))
+    goto error_create_seq_param;
+
+  /* add subset sps for non-base view and sps for base view */
+  if (encoder->is_mvc && encoder->view_idx) {
+    if ((GST_VAAPI_ENCODER_PACKED_HEADERS (encoder) & VAEncPackedHeaderH264_SPS)
+        && !add_packed_sequence_header_mvc (encoder, picture, sequence))
+      goto error_create_packed_seq_hdr;
+  } else {
+    if ((GST_VAAPI_ENCODER_PACKED_HEADERS (encoder) & VAEncPackedHeaderH264_SPS)
+        && !add_packed_sequence_header (encoder, picture, sequence))
+      goto error_create_packed_seq_hdr;
+  }
+
+  if (sequence) {
+    gst_vaapi_enc_picture_set_sequence (picture, sequence);
+    gst_vaapi_codec_object_replace (&sequence, NULL);
+  }
+
+  if (!encoder->is_mvc || encoder->view_idx > 0)
+    encoder->config_changed = FALSE;
+  return TRUE;
+
+  /* ERRORS */
+error_create_seq_param:
+  {
+    GST_ERROR ("failed to create sequence parameter buffer (SPS)");
+    gst_vaapi_codec_object_replace (&sequence, NULL);
+    return FALSE;
+  }
+error_create_packed_seq_hdr:
+  {
+    GST_ERROR ("failed to create packed sequence header buffer");
+    gst_vaapi_codec_object_replace (&sequence, NULL);
+    return FALSE;
+  }
+}
+
+/* Generates additional control parameters */
+static gboolean
+ensure_misc_params (GstVaapiEncoderH264 * encoder, GstVaapiEncPicture * picture)
+{
+  GstVaapiEncMiscParam *misc = NULL;
+  VAEncMiscParameterRateControl *rate_control;
+
+  /* HRD params */
+  misc = GST_VAAPI_ENC_MISC_PARAM_NEW (HRD, encoder);
+  g_assert (misc);
+  if (!misc)
+    return FALSE;
+  fill_hrd_params (encoder, misc->data);
+  gst_vaapi_enc_picture_add_misc_param (picture, misc);
+  gst_vaapi_codec_object_replace (&misc, NULL);
+
+  /* RateControl params */
+  if (GST_VAAPI_ENCODER_RATE_CONTROL (encoder) == GST_VAAPI_RATECONTROL_CBR ||
+      GST_VAAPI_ENCODER_RATE_CONTROL (encoder) == GST_VAAPI_RATECONTROL_VBR) {
+    misc = GST_VAAPI_ENC_MISC_PARAM_NEW (RateControl, encoder);
+    g_assert (misc);
+    if (!misc)
+      return FALSE;
+    rate_control = misc->data;
+    memset (rate_control, 0, sizeof (VAEncMiscParameterRateControl));
+    rate_control->bits_per_second = encoder->bitrate_bits;
+    rate_control->target_percentage = 70;
+    rate_control->window_size = encoder->cpb_length;
+    rate_control->initial_qp = encoder->init_qp;
+    rate_control->min_qp = encoder->min_qp;
+    rate_control->basic_unit_size = 0;
+    gst_vaapi_enc_picture_add_misc_param (picture, misc);
+    gst_vaapi_codec_object_replace (&misc, NULL);
+  }
+  return TRUE;
+}
+
+/* Generates and submits PPS header accordingly into the bitstream */
+static gboolean
+ensure_picture (GstVaapiEncoderH264 * encoder, GstVaapiEncPicture * picture,
+    GstVaapiCodedBufferProxy * codedbuf_proxy, GstVaapiSurfaceProxy * surface)
+{
+  GstVaapiCodedBuffer *const codedbuf =
+      GST_VAAPI_CODED_BUFFER_PROXY_BUFFER (codedbuf_proxy);
+  gboolean res = FALSE;
+
+  res = fill_picture (encoder, picture, codedbuf, surface);
+
+  if (!res)
+    return FALSE;
+
+  if (picture->type == GST_VAAPI_PICTURE_TYPE_I &&
+      (GST_VAAPI_ENCODER_PACKED_HEADERS (encoder) & VAEncPackedHeaderH264_PPS)
+      && !add_packed_picture_header (encoder, picture)) {
+    GST_ERROR ("set picture packed header failed");
+    return FALSE;
+  }
+  return TRUE;
+}
+
+/* Generates slice headers */
+static gboolean
+ensure_slices (GstVaapiEncoderH264 * encoder, GstVaapiEncPicture * picture)
+{
+  GstVaapiEncoderH264Ref *reflist_0[16];
+  GstVaapiEncoderH264Ref *reflist_1[16];
+  GstVaapiH264ViewRefPool *const ref_pool =
+      &encoder->ref_pools[encoder->view_idx];
+  guint reflist_0_count = 0, reflist_1_count = 0;
+
+  g_assert (picture);
+
+  if (picture->type != GST_VAAPI_PICTURE_TYPE_I &&
+      !reference_list_init (encoder, picture,
+          reflist_0, &reflist_0_count, reflist_1, &reflist_1_count)) {
+    GST_ERROR ("reference list reorder failed");
+    return FALSE;
+  }
+
+  g_assert (reflist_0_count + reflist_1_count <= ref_pool->max_ref_frames);
+  if (reflist_0_count > ref_pool->max_reflist0_count)
+    reflist_0_count = ref_pool->max_reflist0_count;
+  if (reflist_1_count > ref_pool->max_reflist1_count)
+    reflist_1_count = ref_pool->max_reflist1_count;
+
+  if (!add_slice_headers (encoder, picture,
+          reflist_0, reflist_0_count, reflist_1, reflist_1_count))
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Normalizes bitrate (and CPB size) for HRD conformance */
+static void
+ensure_bitrate_hrd (GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiEncoder *const base_encoder = GST_VAAPI_ENCODER_CAST (encoder);
+  guint bitrate, cpb_size;
+
+  if (!base_encoder->bitrate) {
+    encoder->bitrate_bits = 0;
+    return;
+  }
+
+  /* Round down bitrate. This is a hard limit mandated by the user */
+  g_assert (SX_BITRATE >= 6);
+  bitrate = (base_encoder->bitrate * 1000) & ~((1U << SX_BITRATE) - 1);
+  if (bitrate != encoder->bitrate_bits) {
+    GST_DEBUG ("HRD bitrate: %u bits/sec", bitrate);
+    encoder->bitrate_bits = bitrate;
+    encoder->config_changed = TRUE;
+  }
+
+  /* Round up CPB size. This is an HRD compliance detail */
+  g_assert (SX_CPB_SIZE >= 4);
+  cpb_size = gst_util_uint64_scale (bitrate, encoder->cpb_length, 1000) &
+      ~((1U << SX_CPB_SIZE) - 1);
+  if (cpb_size != encoder->cpb_length_bits) {
+    GST_DEBUG ("HRD CPB size: %u bits", cpb_size);
+    encoder->cpb_length_bits = cpb_size;
+    encoder->config_changed = TRUE;
+  }
+}
+
+/* Estimates a good enough bitrate if none was supplied */
+static void
+ensure_bitrate (GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiEncoder *const base_encoder = GST_VAAPI_ENCODER_CAST (encoder);
+
+  /* Default compression: 48 bits per macroblock in "high-compression" mode */
+  switch (GST_VAAPI_ENCODER_RATE_CONTROL (encoder)) {
+    case GST_VAAPI_RATECONTROL_CBR:
+    case GST_VAAPI_RATECONTROL_VBR:
+    case GST_VAAPI_RATECONTROL_VBR_CONSTRAINED:
+      if (!base_encoder->bitrate) {
+        /* According to the literature and testing, CABAC entropy coding
+           mode could provide for +10% to +18% improvement in general,
+           thus estimating +15% here ; and using adaptive 8x8 transforms
+           in I-frames could bring up to +10% improvement. */
+        guint bits_per_mb = 48;
+        if (!encoder->use_cabac)
+          bits_per_mb += (bits_per_mb * 15) / 100;
+        if (!encoder->use_dct8x8)
+          bits_per_mb += (bits_per_mb * 10) / 100;
+
+        base_encoder->bitrate =
+            encoder->mb_width * encoder->mb_height * bits_per_mb *
+            GST_VAAPI_ENCODER_FPS_N (encoder) /
+            GST_VAAPI_ENCODER_FPS_D (encoder) / 1000;
+        GST_INFO ("target bitrate computed to %u kbps", base_encoder->bitrate);
+      }
+      break;
+    default:
+      base_encoder->bitrate = 0;
+      break;
+  }
+  ensure_bitrate_hrd (encoder);
+}
+
+/* Constructs profile and level information based on user-defined limits */
+static GstVaapiEncoderStatus
+ensure_profile_and_level (GstVaapiEncoderH264 * encoder)
+{
+  const GstVaapiProfile profile = encoder->profile;
+  const GstVaapiLevelH264 level = encoder->level;
+
+  ensure_tuning (encoder);
+
+  if (!ensure_profile (encoder) || !ensure_profile_limits (encoder))
+    return GST_VAAPI_ENCODER_STATUS_ERROR_UNSUPPORTED_PROFILE;
+
+  /* Check HW constraints */
+  if (!ensure_hw_profile_limits (encoder))
+    return GST_VAAPI_ENCODER_STATUS_ERROR_UNSUPPORTED_PROFILE;
+  if (encoder->profile_idc > encoder->hw_max_profile_idc)
+    return GST_VAAPI_ENCODER_STATUS_ERROR_UNSUPPORTED_PROFILE;
+
+  /* Ensure bitrate if not set already and derive the right level to use */
+  ensure_bitrate (encoder);
+  if (!ensure_level (encoder))
+    return GST_VAAPI_ENCODER_STATUS_ERROR_OPERATION_FAILED;
+
+  if (encoder->profile != profile || encoder->level != level) {
+    GST_DEBUG ("selected %s profile at level %s",
+        gst_vaapi_utils_h264_get_profile_string (encoder->profile),
+        gst_vaapi_utils_h264_get_level_string (encoder->level));
+    encoder->config_changed = TRUE;
+  }
+  return GST_VAAPI_ENCODER_STATUS_SUCCESS;
+}
+
+static void
+reset_properties (GstVaapiEncoderH264 * encoder)
+{
+  GstVaapiEncoder *const base_encoder = GST_VAAPI_ENCODER_CAST (encoder);
+  guint mb_size, i;
+
+  if (encoder->idr_period < base_encoder->keyframe_period)
+    encoder->idr_period = base_encoder->keyframe_period;
+  if (encoder->idr_period > MAX_IDR_PERIOD)
+    encoder->idr_period = MAX_IDR_PERIOD;
+
+  if (encoder->min_qp > encoder->init_qp ||
+      (GST_VAAPI_ENCODER_RATE_CONTROL (encoder) == GST_VAAPI_RATECONTROL_CQP &&
+          encoder->min_qp < encoder->init_qp))
+    encoder->min_qp = encoder->init_qp;
+
+  mb_size = encoder->mb_width * encoder->mb_height;
+  if (encoder->num_slices > (mb_size + 1) / 2)
+    encoder->num_slices = (mb_size + 1) / 2;
+  g_assert (encoder->num_slices);
+
+  if (encoder->num_bframes > (base_encoder->keyframe_period + 1) / 2)
+    encoder->num_bframes = (base_encoder->keyframe_period + 1) / 2;
+
+  if (encoder->num_bframes)
+    encoder->cts_offset = GST_SECOND * GST_VAAPI_ENCODER_FPS_D (encoder) /
+        GST_VAAPI_ENCODER_FPS_N (encoder);
+  else
+    encoder->cts_offset = 0;
+
+  /* init max_frame_num, max_poc */
+  encoder->log2_max_frame_num =
+      h264_get_log2_max_frame_num (encoder->idr_period);
+  g_assert (encoder->log2_max_frame_num >= 4);
+  encoder->max_frame_num = (1 << encoder->log2_max_frame_num);
+  encoder->log2_max_pic_order_cnt = encoder->log2_max_frame_num + 1;
+  encoder->max_pic_order_cnt = (1 << encoder->log2_max_pic_order_cnt);
+  encoder->idr_num = 0;
+
+  encoder->is_mvc = encoder->num_views > 1;
+  for (i = 0; i < encoder->num_views; i++) {
+    GstVaapiH264ViewRefPool *const ref_pool = &encoder->ref_pools[i];
+    ref_pool->max_reflist0_count = 1;
+    ref_pool->max_reflist1_count = encoder->num_bframes > 0;
+    ref_pool->max_ref_frames = ref_pool->max_reflist0_count
+        + ref_pool->max_reflist1_count;
+
+    GstVaapiH264ViewReorderPool *const reorder_pool =
+        &encoder->reorder_pools[i];
+    reorder_pool->frame_index = 0;
+  }
+}
+
+static GstVaapiEncoderStatus
+gst_vaapi_encoder_h264_encode (GstVaapiEncoder * base_encoder,
+    GstVaapiEncPicture * picture, GstVaapiCodedBufferProxy * codedbuf)
+{
+  GstVaapiEncoderH264 *const encoder =
+      GST_VAAPI_ENCODER_H264_CAST (base_encoder);
+  GstVaapiEncoderStatus ret = GST_VAAPI_ENCODER_STATUS_ERROR_UNKNOWN;
+  GstVaapiSurfaceProxy *reconstruct = NULL;
+
+  reconstruct = gst_vaapi_encoder_create_surface (base_encoder);
+
+  g_assert (GST_VAAPI_SURFACE_PROXY_SURFACE (reconstruct));
+
+  if (!ensure_sequence (encoder, picture))
+    goto error;
+  if (!ensure_misc_params (encoder, picture))
+    goto error;
+  if (!ensure_picture (encoder, picture, codedbuf, reconstruct))
+    goto error;
+  if (!ensure_slices (encoder, picture))
+    goto error;
+  if (!gst_vaapi_enc_picture_encode (picture))
+    goto error;
+
+  if (!reference_list_update (encoder, picture, reconstruct))
+    goto error;
+
+  return GST_VAAPI_ENCODER_STATUS_SUCCESS;
+error:
+  if (reconstruct)
+    gst_vaapi_encoder_release_surface (GST_VAAPI_ENCODER (encoder),
+        reconstruct);
+  return ret;
+}
+
+static GstVaapiEncoderStatus
+gst_vaapi_encoder_h264_flush (GstVaapiEncoder * base_encoder)
+{
+  GstVaapiEncoderH264 *const encoder =
+      GST_VAAPI_ENCODER_H264_CAST (base_encoder);
+  GstVaapiH264ViewReorderPool *reorder_pool;
+  GstVaapiEncPicture *pic;
+  guint i;
+
+  for (i = 0; i < encoder->num_views; i++) {
+    reorder_pool = &encoder->reorder_pools[i];
+    reorder_pool->frame_index = 0;
+    reorder_pool->cur_frame_num = 0;
+    reorder_pool->cur_present_index = 0;
+
+    while (!g_queue_is_empty (&reorder_pool->reorder_frame_list)) {
+      pic = (GstVaapiEncPicture *)
+          g_queue_pop_head (&reorder_pool->reorder_frame_list);
+      gst_vaapi_enc_picture_unref (pic);
+    }
+    g_queue_clear (&reorder_pool->reorder_frame_list);
+  }
+
+  return GST_VAAPI_ENCODER_STATUS_SUCCESS;
+}
+
+/* deactivate this part of code to reduce included files */
+#if 0
+/* Generate "codec-data" buffer */
+static GstVaapiEncoderStatus
+gst_vaapi_encoder_h264_get_codec_data (GstVaapiEncoder * base_encoder,
+    GstBuffer ** out_buffer_ptr)
+{
+  GstVaapiEncoderH264 *const encoder =
+      GST_VAAPI_ENCODER_H264_CAST (base_encoder);
+  const guint32 configuration_version = 0x01;
+  const guint32 nal_length_size = 4;
+  guint8 profile_idc, profile_comp, level_idc;
+  GstMapInfo sps_info, pps_info;
+  GstBitWriter bs;
+  GstBuffer *buffer;
+
+  if (!encoder->sps_data || !encoder->pps_data)
+    return GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_HEADER;
+  if (gst_buffer_get_size (encoder->sps_data) < 4)
+    return GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_HEADER;
+
+  if (!gst_buffer_map (encoder->sps_data, &sps_info, GST_MAP_READ))
+    goto error_map_sps_buffer;
+
+  if (!gst_buffer_map (encoder->pps_data, &pps_info, GST_MAP_READ))
+    goto error_map_pps_buffer;
+
+  /* skip sps_data[0], which is the nal_unit_type */
+  profile_idc = sps_info.data[1];
+  profile_comp = sps_info.data[2];
+  level_idc = sps_info.data[3];
+
+  /* Header */
+  gst_bit_writer_init (&bs, (sps_info.size + pps_info.size + 64) * 8);
+  WRITE_UINT32 (&bs, configuration_version, 8);
+  WRITE_UINT32 (&bs, profile_idc, 8);
+  WRITE_UINT32 (&bs, profile_comp, 8);
+  WRITE_UINT32 (&bs, level_idc, 8);
+  WRITE_UINT32 (&bs, 0x3f, 6);  /* 111111 */
+  WRITE_UINT32 (&bs, nal_length_size - 1, 2);
+  WRITE_UINT32 (&bs, 0x07, 3);  /* 111 */
+
+  /* Write SPS */
+  WRITE_UINT32 (&bs, 1, 5);     /* SPS count = 1 */
+  g_assert (GST_BIT_WRITER_BIT_SIZE (&bs) % 8 == 0);
+  WRITE_UINT32 (&bs, sps_info.size, 16);
+  gst_bit_writer_put_bytes (&bs, sps_info.data, sps_info.size);
+
+  /* Write PPS */
+  WRITE_UINT32 (&bs, 1, 8);     /* PPS count = 1 */
+  WRITE_UINT32 (&bs, pps_info.size, 16);
+  gst_bit_writer_put_bytes (&bs, pps_info.data, pps_info.size);
+
+  gst_buffer_unmap (encoder->pps_data, &pps_info);
+  gst_buffer_unmap (encoder->sps_data, &sps_info);
+
+  buffer = gst_buffer_new_wrapped (GST_BIT_WRITER_DATA (&bs),
+      GST_BIT_WRITER_BIT_SIZE (&bs) / 8);
+  if (!buffer)
+    goto error_alloc_buffer;
+  *out_buffer_ptr = buffer;
+
+  gst_bit_writer_clear (&bs, FALSE);
+  return GST_VAAPI_ENCODER_STATUS_SUCCESS;
+
+  /* ERRORS */
+bs_error:
+  {
+    GST_ERROR ("failed to write codec-data");
+    gst_buffer_unmap (encoder->sps_data, &sps_info);
+    gst_buffer_unmap (encoder->pps_data, &pps_info);
+    gst_bit_writer_clear (&bs, TRUE);
+    return FALSE;
+  }
+error_map_sps_buffer:
+  {
+    GST_ERROR ("failed to map SPS packed header");
+    return GST_VAAPI_ENCODER_STATUS_ERROR_ALLOCATION_FAILED;
+  }
+error_map_pps_buffer:
+  {
+    GST_ERROR ("failed to map PPS packed header");
+    gst_buffer_unmap (encoder->sps_data, &sps_info);
+    return GST_VAAPI_ENCODER_STATUS_ERROR_ALLOCATION_FAILED;
+  }
+error_alloc_buffer:
+  {
+    GST_ERROR ("failed to allocate codec-data buffer");
+    gst_bit_writer_clear (&bs, TRUE);
+    return GST_VAAPI_ENCODER_STATUS_ERROR_ALLOCATION_FAILED;
+  }
+}
+
+static GstVaapiEncoderStatus
+gst_vaapi_encoder_h264_reordering (GstVaapiEncoder * base_encoder,
+    GstVideoCodecFrame * frame, GstVaapiEncPicture ** output)
+{
+  GstVaapiEncoderH264 *const encoder =
+      GST_VAAPI_ENCODER_H264_CAST (base_encoder);
+  GstVaapiH264ViewReorderPool *reorder_pool = NULL;
+  GstVaapiEncPicture *picture;
+  gboolean is_idr = FALSE;
+
+  *output = NULL;
+
+  /* encoding views alternatively for MVC */
+  if (encoder->is_mvc) {
+    if (frame)
+      encoder->view_idx = frame->system_frame_number % MAX_NUM_VIEWS;
+    else
+      encoder->view_idx = (encoder->view_idx + 1) % MAX_NUM_VIEWS;
+  }
+  reorder_pool = &encoder->reorder_pools[encoder->view_idx];
+
+  if (!frame) {
+    if (reorder_pool->reorder_state != GST_VAAPI_ENC_H264_REORD_DUMP_FRAMES)
+      return GST_VAAPI_ENCODER_STATUS_NO_SURFACE;
+
+    /* reorder_state = GST_VAAPI_ENC_H264_REORD_DUMP_FRAMES
+       dump B frames from queue, sometime, there may also have P frame or I frame */
+    g_assert (encoder->num_bframes > 0);
+    g_return_val_if_fail (!g_queue_is_empty (&reorder_pool->reorder_frame_list),
+        GST_VAAPI_ENCODER_STATUS_ERROR_UNKNOWN);
+    picture = g_queue_pop_head (&reorder_pool->reorder_frame_list);
+    g_assert (picture);
+    if (g_queue_is_empty (&reorder_pool->reorder_frame_list)) {
+      reorder_pool->reorder_state = GST_VAAPI_ENC_H264_REORD_WAIT_FRAMES;
+    }
+    goto end;
+  }
+
+  /* new frame coming */
+  picture = GST_VAAPI_ENC_PICTURE_NEW (H264, encoder, frame);
+  if (!picture) {
+    GST_WARNING ("create H264 picture failed, frame timestamp:%"
+        GST_TIME_FORMAT, GST_TIME_ARGS (frame->pts));
+    return GST_VAAPI_ENCODER_STATUS_ERROR_ALLOCATION_FAILED;
+  }
+  ++reorder_pool->cur_present_index;
+  picture->poc = ((reorder_pool->cur_present_index * 2) %
+      encoder->max_pic_order_cnt);
+
+  is_idr = (reorder_pool->frame_index == 0 ||
+      reorder_pool->frame_index >= encoder->idr_period);
+
+  /* check key frames */
+  if (is_idr || GST_VIDEO_CODEC_FRAME_IS_FORCE_KEYFRAME (frame) ||
+      (reorder_pool->frame_index %
+          GST_VAAPI_ENCODER_KEYFRAME_PERIOD (encoder)) == 0) {
+    ++reorder_pool->cur_frame_num;
+    ++reorder_pool->frame_index;
+
+    /* b frame enabled,  check queue of reorder_frame_list */
+    if (encoder->num_bframes
+        && !g_queue_is_empty (&reorder_pool->reorder_frame_list)) {
+      GstVaapiEncPicture *p_pic;
+
+      p_pic = g_queue_pop_tail (&reorder_pool->reorder_frame_list);
+      set_p_frame (p_pic, encoder);
+      g_queue_foreach (&reorder_pool->reorder_frame_list,
+          (GFunc) set_b_frame, encoder);
+      ++reorder_pool->cur_frame_num;
+      set_key_frame (picture, encoder, is_idr);
+      g_queue_push_tail (&reorder_pool->reorder_frame_list, picture);
+      picture = p_pic;
+      reorder_pool->reorder_state = GST_VAAPI_ENC_H264_REORD_DUMP_FRAMES;
+    } else {                    /* no b frames in queue */
+      set_key_frame (picture, encoder, is_idr);
+      g_assert (g_queue_is_empty (&reorder_pool->reorder_frame_list));
+      if (encoder->num_bframes)
+        reorder_pool->reorder_state = GST_VAAPI_ENC_H264_REORD_WAIT_FRAMES;
+    }
+    goto end;
+  }
+
+  /* new p/b frames coming */
+  ++reorder_pool->frame_index;
+  if (reorder_pool->reorder_state == GST_VAAPI_ENC_H264_REORD_WAIT_FRAMES &&
+      g_queue_get_length (&reorder_pool->reorder_frame_list) <
+      encoder->num_bframes) {
+    g_queue_push_tail (&reorder_pool->reorder_frame_list, picture);
+    return GST_VAAPI_ENCODER_STATUS_NO_SURFACE;
+  }
+
+  ++reorder_pool->cur_frame_num;
+  set_p_frame (picture, encoder);
+
+  if (reorder_pool->reorder_state == GST_VAAPI_ENC_H264_REORD_WAIT_FRAMES) {
+    g_queue_foreach (&reorder_pool->reorder_frame_list, (GFunc) set_b_frame,
+        encoder);
+    reorder_pool->reorder_state = GST_VAAPI_ENC_H264_REORD_DUMP_FRAMES;
+    g_assert (!g_queue_is_empty (&reorder_pool->reorder_frame_list));
+  }
+
+end:
+  g_assert (picture);
+  frame = picture->frame;
+  if (GST_CLOCK_TIME_IS_VALID (frame->pts))
+    frame->pts += encoder->cts_offset;
+  *output = picture;
+
+  return GST_VAAPI_ENCODER_STATUS_SUCCESS;
+}
+
+static GstVaapiEncoderStatus
+set_context_info (GstVaapiEncoder * base_encoder)
+{
+  GstVaapiEncoderH264 *const encoder =
+      GST_VAAPI_ENCODER_H264_CAST (base_encoder);
+  GstVideoInfo *const vip = GST_VAAPI_ENCODER_VIDEO_INFO (encoder);
+  const guint DEFAULT_SURFACES_COUNT = 3;
+
+  /* Maximum sizes for common headers (in bits) */
+  enum
+  {
+    MAX_SPS_HDR_SIZE = 16473,
+    MAX_VUI_PARAMS_SIZE = 210,
+    MAX_HRD_PARAMS_SIZE = 4103,
+    MAX_PPS_HDR_SIZE = 101,
+    MAX_SLICE_HDR_SIZE = 397 + 2572 + 6670 + 2402,
+  };
+
+  if (!ensure_hw_profile (encoder))
+    return GST_VAAPI_ENCODER_STATUS_ERROR_UNSUPPORTED_PROFILE;
+
+  base_encoder->num_ref_frames =
+      ((encoder->num_bframes ? 2 : 1) + DEFAULT_SURFACES_COUNT)
+      * encoder->num_views;
+
+  /* Only YUV 4:2:0 formats are supported for now. This means that we
+     have a limit of 3200 bits per macroblock. */
+  /* XXX: check profile and compute RawMbBits */
+  base_encoder->codedbuf_size = (GST_ROUND_UP_16 (vip->width) *
+      GST_ROUND_UP_16 (vip->height) / 256) * 400;
+
+  /* Account for SPS header */
+  /* XXX: exclude scaling lists, MVC/SVC extensions */
+  base_encoder->codedbuf_size += 4 + GST_ROUND_UP_8 (MAX_SPS_HDR_SIZE +
+      MAX_VUI_PARAMS_SIZE + 2 * MAX_HRD_PARAMS_SIZE) / 8;
+
+  /* Account for PPS header */
+  /* XXX: exclude slice groups, scaling lists, MVC/SVC extensions */
+  base_encoder->codedbuf_size += 4 + GST_ROUND_UP_8 (MAX_PPS_HDR_SIZE) / 8;
+
+  /* Account for slice header */
+  base_encoder->codedbuf_size += encoder->num_slices * (4 +
+      GST_ROUND_UP_8 (MAX_SLICE_HDR_SIZE) / 8);
+
+  return GST_VAAPI_ENCODER_STATUS_SUCCESS;
+}
+
+static GstVaapiEncoderStatus
+gst_vaapi_encoder_h264_reconfigure (GstVaapiEncoder * base_encoder)
+{
+  GstVaapiEncoderH264 *const encoder =
+      GST_VAAPI_ENCODER_H264_CAST (base_encoder);
+  GstVaapiEncoderStatus status;
+  guint mb_width, mb_height;
+
+  mb_width = (GST_VAAPI_ENCODER_WIDTH (encoder) + 15) / 16;
+  mb_height = (GST_VAAPI_ENCODER_HEIGHT (encoder) + 15) / 16;
+  if (mb_width != encoder->mb_width || mb_height != encoder->mb_height) {
+    GST_DEBUG ("resolution: %dx%d", GST_VAAPI_ENCODER_WIDTH (encoder),
+        GST_VAAPI_ENCODER_HEIGHT (encoder));
+    encoder->mb_width = mb_width;
+    encoder->mb_height = mb_height;
+    encoder->config_changed = TRUE;
+  }
+
+  status = ensure_profile_and_level (encoder);
+  if (status != GST_VAAPI_ENCODER_STATUS_SUCCESS)
+    return status;
+
+  reset_properties (encoder);
+  return set_context_info (base_encoder);
+}
+
+static gboolean
+gst_vaapi_encoder_h264_init (GstVaapiEncoder * base_encoder)
+{
+  GstVaapiEncoderH264 *const encoder =
+      GST_VAAPI_ENCODER_H264_CAST (base_encoder);
+  guint32 i;
+
+  /* Multi-view coding information */
+  encoder->is_mvc = FALSE;
+  encoder->num_views = 1;
+  encoder->view_idx = 0;
+
+  /* re-ordering  list initialize */
+  for (i = 0; i < MAX_NUM_VIEWS; i++) {
+    GstVaapiH264ViewReorderPool *const reorder_pool =
+        &encoder->reorder_pools[i];
+    g_queue_init (&reorder_pool->reorder_frame_list);
+    reorder_pool->reorder_state = GST_VAAPI_ENC_H264_REORD_NONE;
+    reorder_pool->frame_index = 0;
+    reorder_pool->cur_frame_num = 0;
+    reorder_pool->cur_present_index = 0;
+  }
+
+  /* reference list info initialize */
+  for (i = 0; i < MAX_NUM_VIEWS; i++) {
+    GstVaapiH264ViewRefPool *const ref_pool = &encoder->ref_pools[i];
+    g_queue_init (&ref_pool->ref_list);
+    ref_pool->max_ref_frames = 0;
+    ref_pool->max_reflist0_count = 1;
+    ref_pool->max_reflist1_count = 1;
+  }
+
+  return TRUE;
+}
+
+static void
+gst_vaapi_encoder_h264_finalize (GstVaapiEncoder * base_encoder)
+{
+  /*free private buffers */
+  GstVaapiEncoderH264 *const encoder =
+      GST_VAAPI_ENCODER_H264_CAST (base_encoder);
+  GstVaapiEncPicture *pic;
+  GstVaapiEncoderH264Ref *ref;
+  guint32 i;
+
+  gst_buffer_replace (&encoder->sps_data, NULL);
+  gst_buffer_replace (&encoder->subset_sps_data, NULL);
+  gst_buffer_replace (&encoder->pps_data, NULL);
+
+  /* reference list info de-init */
+  for (i = 0; i < MAX_NUM_VIEWS; i++) {
+    GstVaapiH264ViewRefPool *const ref_pool = &encoder->ref_pools[i];
+    while (!g_queue_is_empty (&ref_pool->ref_list)) {
+      ref = (GstVaapiEncoderH264Ref *) g_queue_pop_head (&ref_pool->ref_list);
+      reference_pic_free (encoder, ref);
+    }
+    g_queue_clear (&ref_pool->ref_list);
+  }
+
+  /* re-ordering  list initialize */
+  for (i = 0; i < MAX_NUM_VIEWS; i++) {
+    GstVaapiH264ViewReorderPool *const reorder_pool =
+        &encoder->reorder_pools[i];
+    while (!g_queue_is_empty (&reorder_pool->reorder_frame_list)) {
+      pic = (GstVaapiEncPicture *)
+          g_queue_pop_head (&reorder_pool->reorder_frame_list);
+      gst_vaapi_enc_picture_unref (pic);
+    }
+    g_queue_clear (&reorder_pool->reorder_frame_list);
+  }
+}
+
+static GstVaapiEncoderStatus
+gst_vaapi_encoder_h264_set_property (GstVaapiEncoder * base_encoder,
+    gint prop_id, const GValue * value)
+{
+  GstVaapiEncoderH264 *const encoder =
+      GST_VAAPI_ENCODER_H264_CAST (base_encoder);
+
+  switch (prop_id) {
+    case GST_VAAPI_ENCODER_H264_PROP_MAX_BFRAMES:
+      encoder->num_bframes = g_value_get_uint (value);
+      break;
+    case GST_VAAPI_ENCODER_H264_PROP_INIT_QP:
+      encoder->init_qp = g_value_get_uint (value);
+      break;
+    case GST_VAAPI_ENCODER_H264_PROP_MIN_QP:
+      encoder->min_qp = g_value_get_uint (value);
+      break;
+    case GST_VAAPI_ENCODER_H264_PROP_NUM_SLICES:
+      encoder->num_slices = g_value_get_uint (value);
+      break;
+    case GST_VAAPI_ENCODER_H264_PROP_CABAC:
+      encoder->use_cabac = g_value_get_boolean (value);
+      break;
+    case GST_VAAPI_ENCODER_H264_PROP_DCT8X8:
+      encoder->use_dct8x8 = g_value_get_boolean (value);
+      break;
+    case GST_VAAPI_ENCODER_H264_PROP_CPB_LENGTH:
+      encoder->cpb_length = g_value_get_uint (value);
+      break;
+    case GST_VAAPI_ENCODER_H264_PROP_NUM_VIEWS:
+      encoder->num_views = g_value_get_uint (value);
+      break;
+    default:
+      return GST_VAAPI_ENCODER_STATUS_ERROR_INVALID_PARAMETER;
+  }
+  return GST_VAAPI_ENCODER_STATUS_SUCCESS;
+}
+
+GST_VAAPI_ENCODER_DEFINE_CLASS_DATA (H264);
+
+static inline const GstVaapiEncoderClass *
+gst_vaapi_encoder_h264_class (void)
+{
+  static const GstVaapiEncoderClass GstVaapiEncoderH264Class = {
+    GST_VAAPI_ENCODER_CLASS_INIT (H264, h264),
+    .set_property = gst_vaapi_encoder_h264_set_property,
+    .get_codec_data = gst_vaapi_encoder_h264_get_codec_data
+  };
+  return &GstVaapiEncoderH264Class;
+}
+
+/**
+ * gst_vaapi_encoder_h264_new:
+ * @display: a #GstVaapiDisplay
+ *
+ * Creates a new #GstVaapiEncoder for H.264 encoding. Note that the
+ * only supported output stream format is "byte-stream" format.
+ *
+ * Return value: the newly allocated #GstVaapiEncoder object
+ */
+GstVaapiEncoder *
+gst_vaapi_encoder_h264_new (GstVaapiDisplay * display)
+{
+  return gst_vaapi_encoder_new (gst_vaapi_encoder_h264_class (), display);
+}
+
+/**
+ * gst_vaapi_encoder_h264_get_default_properties:
+ *
+ * Determines the set of common and H.264 specific encoder properties.
+ * The caller owns an extra reference to the resulting array of
+ * #GstVaapiEncoderPropInfo elements, so it shall be released with
+ * g_ptr_array_unref() after usage.
+ *
+ * Return value: the set of encoder properties for #GstVaapiEncoderH264,
+ *   or %NULL if an error occurred.
+ */
+GPtrArray *
+gst_vaapi_encoder_h264_get_default_properties (void)
+{
+  const GstVaapiEncoderClass *const klass = gst_vaapi_encoder_h264_class ();
+  GPtrArray *props;
+
+  props = gst_vaapi_encoder_properties_get_default (klass);
+  if (!props)
+    return NULL;
+
+  /**
+   * GstVaapiEncoderH264:max-bframes:
+   *
+   * The number of B-frames between I and P.
+   */
+  GST_VAAPI_ENCODER_PROPERTIES_APPEND (props,
+      GST_VAAPI_ENCODER_H264_PROP_MAX_BFRAMES,
+      g_param_spec_uint ("max-bframes",
+          "Max B-Frames", "Number of B-frames between I and P", 0, 10, 0,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVaapiEncoderH264:init-qp:
+   *
+   * The initial quantizer value.
+   */
+  GST_VAAPI_ENCODER_PROPERTIES_APPEND (props,
+      GST_VAAPI_ENCODER_H264_PROP_INIT_QP,
+      g_param_spec_uint ("init-qp",
+          "Initial QP", "Initial quantizer value", 1, 51, 26,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVaapiEncoderH264:min-qp:
+   *
+   * The minimum quantizer value.
+   */
+  GST_VAAPI_ENCODER_PROPERTIES_APPEND (props,
+      GST_VAAPI_ENCODER_H264_PROP_MIN_QP,
+      g_param_spec_uint ("min-qp",
+          "Minimum QP", "Minimum quantizer value", 1, 51, 1,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVaapiEncoderH264:num-slices:
+   *
+   * The number of slices per frame.
+   */
+  GST_VAAPI_ENCODER_PROPERTIES_APPEND (props,
+      GST_VAAPI_ENCODER_H264_PROP_NUM_SLICES,
+      g_param_spec_uint ("num-slices",
+          "Number of Slices",
+          "Number of slices per frame",
+          1, 200, 1, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVaapiEncoderH264:cabac:
+   *
+   * Enable CABAC entropy coding mode for improved compression ratio,
+   * at the expense that the minimum target profile is Main. Default
+   * is CAVLC entropy coding mode.
+   */
+  GST_VAAPI_ENCODER_PROPERTIES_APPEND (props,
+      GST_VAAPI_ENCODER_H264_PROP_CABAC,
+      g_param_spec_boolean ("cabac",
+          "Enable CABAC",
+          "Enable CABAC entropy coding mode",
+          FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVaapiEncoderH264:dct8x8:
+   *
+   * Enable adaptive use of 8x8 transforms in I-frames. This improves
+   * the compression ratio by the minimum target profile is High.
+   * Default is to use 4x4 DCT only.
+   */
+  GST_VAAPI_ENCODER_PROPERTIES_APPEND (props,
+      GST_VAAPI_ENCODER_H264_PROP_DCT8X8,
+      g_param_spec_boolean ("dct8x8",
+          "Enable 8x8 DCT",
+          "Enable adaptive use of 8x8 transforms in I-frames",
+          FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVaapiEncoderH264:cpb-length:
+   *
+   * The size of the CPB buffer in milliseconds.
+   */
+  GST_VAAPI_ENCODER_PROPERTIES_APPEND (props,
+      GST_VAAPI_ENCODER_H264_PROP_CPB_LENGTH,
+      g_param_spec_uint ("cpb-length",
+          "CPB Length", "Length of the CPB buffer in milliseconds",
+          1, 10000, DEFAULT_CPB_LENGTH,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVaapiEncoderH264:num-views:
+   *
+   * The number of views for MVC encoding .
+   */
+  GST_VAAPI_ENCODER_PROPERTIES_APPEND (props,
+      GST_VAAPI_ENCODER_H264_PROP_NUM_VIEWS,
+      g_param_spec_uint ("num-views",
+          "Number of Views",
+          "Number of Views for MVC encoding",
+          1, MAX_NUM_VIEWS, 1, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  return props;
+}
+
+/**
+ * gst_vaapi_encoder_h264_set_max_profile:
+ * @encoder: a #GstVaapiEncoderH264
+ * @profile: an H.264 #GstVaapiProfile
+ *
+ * Notifies the @encoder to use coding tools from the supplied
+ * @profile at most.
+ *
+ * This means that if the minimal profile derived to
+ * support the specified coding tools is greater than this @profile,
+ * then an error is returned when the @encoder is configured.
+ *
+ * Return value: %TRUE on success
+ */
+gboolean
+gst_vaapi_encoder_h264_set_max_profile (GstVaapiEncoderH264 * encoder,
+    GstVaapiProfile profile)
+{
+  guint8 profile_idc;
+
+  g_return_val_if_fail (encoder != NULL, FALSE);
+  g_return_val_if_fail (profile != GST_VAAPI_PROFILE_UNKNOWN, FALSE);
+
+  if (gst_vaapi_profile_get_codec (profile) != GST_VAAPI_CODEC_H264)
+    return FALSE;
+
+  profile_idc = gst_vaapi_utils_h264_get_profile_idc (profile);
+  if (!profile_idc)
+    return FALSE;
+
+  encoder->max_profile_idc = profile_idc;
+  return TRUE;
+}
+
+/**
+ * gst_vaapi_encoder_h264_get_profile_and_level:
+ * @encoder: a #GstVaapiEncoderH264
+ * @out_profile_ptr: return location for the #GstVaapiProfile
+ * @out_level_ptr: return location for the #GstVaapiLevelH264
+ *
+ * Queries the H.264 @encoder for the active profile and level. That
+ * information is only constructed and valid after the encoder is
+ * configured, i.e. after the gst_vaapi_encoder_set_codec_state()
+ * function is called.
+ *
+ * Return value: %TRUE on success
+ */
+gboolean
+gst_vaapi_encoder_h264_get_profile_and_level (GstVaapiEncoderH264 * encoder,
+    GstVaapiProfile * out_profile_ptr, GstVaapiLevelH264 * out_level_ptr)
+{
+  g_return_val_if_fail (encoder != NULL, FALSE);
+
+  if (!encoder->profile || !encoder->level)
+    return FALSE;
+
+  if (out_profile_ptr)
+    *out_profile_ptr = encoder->profile;
+  if (out_level_ptr)
+    *out_level_ptr = encoder->level;
+  return TRUE;
+}
+#endif
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_h264.h b/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_h264.h
new file mode 100644
index 0000000..e10d764
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_h264.h
@@ -0,0 +1,160 @@
+/*
+ *  gstvaapiencoder_h264.h - H.264 encoder
+ *
+ *  Copyright (C) 2011-2014 Intel Corporation
+ *    Author: Wind Yuan <feng.yuan@intel.com>
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_ENCODER_H264_H
+#define GST_VAAPI_ENCODER_H264_H
+
+#include <va/va_enc_h264.h>
+#include <gst/vaapi/gstvaapiencoder.h>
+#include <gst/vaapi/gstvaapiencoder_priv.h>
+#include <gst/vaapi/gstvaapiutils_h264.h>
+
+G_BEGIN_DECLS
+
+/* move _GstVaapiH264ViewRefPool, _GstVaapiH264ViewReorderPool & _GstVaapiEncoderH264
+ * structures from gstvaapiencoder_h264.h */
+/* Define the maximum number of views supported */
+#define MAX_NUM_VIEWS 2
+
+typedef struct _GstVaapiH264ViewRefPool
+{
+  GQueue ref_list;
+  guint max_ref_frames;
+  guint max_reflist0_count;
+  guint max_reflist1_count;
+} GstVaapiH264ViewRefPool;
+
+typedef struct _GstVaapiH264ViewReorderPool
+{
+  GQueue reorder_frame_list;
+  guint reorder_state;
+  guint frame_index;
+  guint cur_frame_num;
+  guint cur_present_index;
+} GstVaapiH264ViewReorderPool;
+
+struct _GstVaapiEncoderH264
+{
+  GstVaapiEncoder parent_instance;
+
+  GstVaapiProfile profile;
+  GstVaapiLevelH264 level;
+  guint8 profile_idc;
+  guint8 max_profile_idc;
+  guint8 hw_max_profile_idc;
+  guint8 level_idc;
+  guint32 idr_period;
+  guint32 init_qp;
+  guint32 min_qp;
+  guint32 num_slices;
+  guint32 num_bframes;
+  guint32 mb_width;
+  guint32 mb_height;
+  gboolean use_cabac;
+  gboolean use_dct8x8;
+  GstClockTime cts_offset;
+  gboolean config_changed;
+
+  /* frame, poc */
+  guint32 max_frame_num;
+  guint32 log2_max_frame_num;
+  guint32 max_pic_order_cnt;
+  guint32 log2_max_pic_order_cnt;
+  guint32 idr_num;
+  guint8 pic_order_cnt_type;
+  guint8 delta_pic_order_always_zero_flag;
+
+  GstBuffer *sps_data;
+  GstBuffer *subset_sps_data;
+  GstBuffer *pps_data;
+
+  guint bitrate_bits;           // bitrate (bits)
+  guint cpb_length;             // length of CPB buffer (ms)
+  guint cpb_length_bits;        // length of CPB buffer (bits)
+
+  /* MVC */
+  gboolean is_mvc;
+  guint32 view_idx;
+  guint32 num_views;
+  GstVaapiH264ViewRefPool ref_pools[MAX_NUM_VIEWS];
+  GstVaapiH264ViewReorderPool reorder_pools[MAX_NUM_VIEWS];
+};
+
+#define GST_VAAPI_ENCODER_H264(encoder) \
+  ((GstVaapiEncoderH264 *) (encoder))
+
+typedef struct _GstVaapiEncoderH264 GstVaapiEncoderH264;
+
+/**
+ * GstVaapiEncoderH264Prop:
+ * @GST_VAAPI_ENCODER_H264_PROP_MAX_BFRAMES: Number of B-frames between I
+ *   and P (uint).
+ * @GST_VAAPI_ENCODER_H264_PROP_INIT_QP: Initial quantizer value (uint).
+ * @GST_VAAPI_ENCODER_H264_PROP_MIN_QP: Minimal quantizer value (uint).
+ * @GST_VAAPI_ENCODER_H264_PROP_NUM_SLICES: Number of slices per frame (uint).
+ * @GST_VAAPI_ENCODER_H264_PROP_CABAC: Enable CABAC entropy coding mode (bool).
+ * @GST_VAAPI_ENCODER_H264_PROP_DCT8X8: Enable adaptive use of 8x8
+ *   transforms in I-frames (bool).
+ * @GST_VAAPI_ENCODER_H264_PROP_CPB_LENGTH: Length of the CPB buffer
+ *   in milliseconds (uint).
+ * @GST_VAAPI_ENCODER_H264_PROP_NUM_VIEWS: Number of views per frame.
+ *
+ * The set of H.264 encoder specific configurable properties.
+ */
+typedef enum {
+  GST_VAAPI_ENCODER_H264_PROP_MAX_BFRAMES = -1,
+  GST_VAAPI_ENCODER_H264_PROP_INIT_QP = -2,
+  GST_VAAPI_ENCODER_H264_PROP_MIN_QP = -3,
+  GST_VAAPI_ENCODER_H264_PROP_NUM_SLICES = -4,
+  GST_VAAPI_ENCODER_H264_PROP_CABAC = -5,
+  GST_VAAPI_ENCODER_H264_PROP_DCT8X8 = -6,
+  GST_VAAPI_ENCODER_H264_PROP_CPB_LENGTH = -7,
+  GST_VAAPI_ENCODER_H264_PROP_NUM_VIEWS = -8,
+} GstVaapiEncoderH264Prop;
+
+GstVaapiEncoder *
+gst_vaapi_encoder_h264_new (GstVaapiDisplay * display);
+
+GPtrArray *
+gst_vaapi_encoder_h264_get_default_properties (void);
+
+gboolean
+gst_vaapi_encoder_h264_set_max_profile (GstVaapiEncoderH264 * encoder,
+    GstVaapiProfile profile);
+
+gboolean
+gst_vaapi_encoder_h264_get_profile_and_level (GstVaapiEncoderH264 * encoder,
+    GstVaapiProfile * out_profile_ptr, GstVaapiLevelH264 * out_level_ptr);
+
+/* these functions will be called by libv4l-hva plugin */
+gboolean
+add_packed_sequence_header (GstVaapiEncoderH264 * encoder,
+    GstVaapiEncPicture * picture, GstVaapiEncSequence * sequence);
+
+gboolean
+add_packed_picture_header (GstVaapiEncoderH264 * encoder,
+    GstVaapiEncPicture * picture);
+
+G_END_DECLS
+
+#endif /*GST_VAAPI_ENCODER_H264_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_objects.h b/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_objects.h
new file mode 100644
index 0000000..aa1ccbf
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_objects.h
@@ -0,0 +1,277 @@
+/*
+ *  gstvaapiencoder_objects.h - VA encoder objects abstraction
+ *
+ *  Copyright (C) 2013-2014 Intel Corporation
+ *    Author: Wind Yuan <feng.yuan@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_ENCODER_OBJECTS_H
+#define GST_VAAPI_ENCODER_OBJECTS_H
+
+#include <gst/vaapi/gstvaapicodec_objects.h>
+#include <gst/vaapi/gstvaapidecoder_objects.h>
+#include <gst/vaapi/gstvaapiencoder.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GstVaapiEncPicture GstVaapiEncPicture;
+typedef struct _GstVaapiEncSequence GstVaapiEncSequence;
+typedef struct _GstVaapiEncMiscParam GstVaapiEncMiscParam;
+typedef struct _GstVaapiEncSlice GstVaapiEncSlice;
+typedef struct _GstVaapiCodedBuffer GstVaapiCodedBuffer;
+typedef struct _GstVaapiEncPackedHeader GstVaapiEncPackedHeader;
+
+/* ------------------------------------------------------------------------- */
+/* --- Encoder Packed Header                                             --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_ENC_PACKED_HEADER(obj) \
+  ((GstVaapiEncPackedHeader *) (obj))
+
+/**
+ * GstVaapiEncPackedHeader:
+ *
+ * A #GstVaapiCodecObject holding a packed header (param/data) for the
+ * encoder.
+ */
+struct _GstVaapiEncPackedHeader
+{
+  /*< private >*/
+  GstVaapiCodecObject parent_instance;
+
+  /*< public >*/
+  VABufferID param_id;
+  gpointer param;
+  VABufferID data_id;
+  gpointer data;
+};
+
+G_GNUC_INTERNAL
+GstVaapiEncPackedHeader *
+gst_vaapi_enc_packed_header_new (GstVaapiEncoder * encoder,
+    gconstpointer param, guint param_size, gconstpointer data, guint data_size);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_enc_packed_header_set_data (GstVaapiEncPackedHeader * header,
+    gconstpointer data, guint data_size);
+
+/* ------------------------------------------------------------------------- */
+/* --- Encoder Sequence                                                  --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_ENC_SEQUENCE(obj) \
+  ((GstVaapiEncSequence *) (obj))
+
+/**
+ * GstVaapiEncSequence:
+ *
+ * A #GstVaapiCodecObject holding a sequence parameter for encoding.
+ */
+struct _GstVaapiEncSequence
+{
+  /*< private >*/
+  GstVaapiCodecObject parent_instance;
+
+  /*< public >*/
+  VABufferID param_id;
+  gpointer param;
+};
+
+G_GNUC_INTERNAL
+GstVaapiEncSequence *
+gst_vaapi_enc_sequence_new (GstVaapiEncoder * encoder,
+    gconstpointer param, guint param_size);
+
+/* ------------------------------------------------------------------------- */
+/* --- Encoder Slice                                                     --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_ENC_SLICE(obj) \
+  ((GstVaapiEncSlice *) (obj))
+
+/**
+ * GstVaapiEncSlice:
+ *
+ * A #GstVaapiCodecObject holding a slice parameter used for encoding.
+ */
+struct _GstVaapiEncSlice
+{
+  /*< private >*/
+  GstVaapiCodecObject parent_instance;
+
+  /*< public >*/
+  VABufferID param_id;
+  gpointer param;
+  GPtrArray *packed_headers;
+};
+
+G_GNUC_INTERNAL
+GstVaapiEncSlice *
+gst_vaapi_enc_slice_new (GstVaapiEncoder * encoder,
+    gconstpointer param, guint param_size);
+
+/* ------------------------------------------------------------------------- */
+/* --- Encoder Misc Parameter Buffer                                     --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_ENC_MISC_PARAM(obj) \
+  ((GstVaapiEncMiscParam *) (obj))
+
+/**
+ * GstVaapiEncMiscParam:
+ *
+ * A #GstVaapiCodecObject holding a misc parameter and associated data
+ * used for controlling the encoder dynamically.
+ */
+struct _GstVaapiEncMiscParam
+{
+  /*< private >*/
+  GstVaapiCodecObject parent_instance;
+  gpointer param;
+
+  /*< public >*/
+  VABufferID param_id;
+  gpointer data;
+};
+
+G_GNUC_INTERNAL
+GstVaapiEncMiscParam *
+gst_vaapi_enc_misc_param_new (GstVaapiEncoder * encoder,
+    VAEncMiscParameterType type, guint data_size);
+
+/* ------------------------------------------------------------------------- */
+/* --- Encoder Picture                                                   --- */
+/* ------------------------------------------------------------------------- */
+
+#define GST_VAAPI_ENC_PICTURE(obj) \
+  ((GstVaapiEncPicture *) (obj))
+
+typedef enum
+{
+  GST_VAAPI_ENC_PICTURE_FLAG_IDR    = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 0),
+  GST_VAAPI_ENC_PICTURE_FLAG_LAST   = (GST_VAAPI_CODEC_OBJECT_FLAG_LAST << 1),
+} GstVaapiEncPictureFlags;
+
+#define GST_VAAPI_ENC_PICTURE_FLAGS         GST_VAAPI_MINI_OBJECT_FLAGS
+#define GST_VAAPI_ENC_PICTURE_FLAG_IS_SET   GST_VAAPI_MINI_OBJECT_FLAG_IS_SET
+#define GST_VAAPI_ENC_PICTURE_FLAG_SET      GST_VAAPI_MINI_OBJECT_FLAG_SET
+#define GST_VAAPI_ENC_PICTURE_FLAG_UNSET    GST_VAAPI_MINI_OBJECT_FLAG_UNSET
+
+#define GST_VAAPI_ENC_PICTURE_IS_IDR(picture) \
+    GST_VAAPI_ENC_PICTURE_FLAG_IS_SET(picture, GST_VAAPI_ENC_PICTURE_FLAG_IDR)
+
+/**
+ * GstVaapiEncPicture:
+ *
+ * A #GstVaapiCodecObject holding a picture parameter for encoding.
+ */
+struct _GstVaapiEncPicture
+{
+  /*< private >*/
+  GstVaapiCodecObject parent_instance;
+  GstVideoCodecFrame *frame;
+  GstVaapiSurfaceProxy *proxy;
+  GstVaapiSurface *surface;
+  VABufferID param_id;
+  guint param_size;
+
+  /* Additional data to pass down */
+  GstVaapiEncSequence *sequence;
+  GPtrArray *packed_headers;
+  GPtrArray *misc_params;
+
+  /*< public >*/
+  GstVaapiPictureType type;
+  VASurfaceID surface_id;
+  gpointer param;
+  GPtrArray *slices;
+  GstClockTime pts;
+  guint frame_num;
+  guint poc;
+};
+
+G_GNUC_INTERNAL
+GstVaapiEncPicture *
+gst_vaapi_enc_picture_new (GstVaapiEncoder * encoder,
+    gconstpointer param, guint param_size, GstVideoCodecFrame * frame);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_enc_picture_set_sequence (GstVaapiEncPicture * picture,
+    GstVaapiEncSequence * sequence);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_enc_picture_add_packed_header (GstVaapiEncPicture * picture,
+    GstVaapiEncPackedHeader * header);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_enc_picture_add_misc_param (GstVaapiEncPicture * picture,
+    GstVaapiEncMiscParam * misc);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_enc_picture_add_slice (GstVaapiEncPicture * picture,
+    GstVaapiEncSlice * slice);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_enc_slice_add_packed_header (GstVaapiEncSlice *slice,
+    GstVaapiEncPackedHeader * header);
+
+G_GNUC_INTERNAL
+gboolean
+gst_vaapi_enc_picture_encode (GstVaapiEncPicture * picture);
+
+#define gst_vaapi_enc_picture_ref(picture) \
+  gst_vaapi_codec_object_ref (picture)
+#define gst_vaapi_enc_picture_unref(picture) \
+  gst_vaapi_codec_object_unref (picture)
+#define gst_vaapi_enc_picture_replace(old_picture_ptr, new_picture) \
+  gst_vaapi_codec_object_replace (old_picture_ptr, new_picture)
+
+/* ------------------------------------------------------------------------- */
+/* --- Helpers to create codec-dependent objects                         --- */
+/* ------------------------------------------------------------------------- */
+
+/* GstVaapiEncSequence */
+#define GST_VAAPI_ENC_SEQUENCE_NEW(codec, encoder)                      \
+  gst_vaapi_enc_sequence_new (GST_VAAPI_ENCODER_CAST (encoder),         \
+      NULL, sizeof (G_PASTE (VAEncSequenceParameterBuffer, codec)))
+
+/* GstVaapiEncMiscParam */
+#define GST_VAAPI_ENC_MISC_PARAM_NEW(type, encoder)                     \
+  gst_vaapi_enc_misc_param_new (GST_VAAPI_ENCODER_CAST (encoder),       \
+      G_PASTE (VAEncMiscParameterType, type),                           \
+      sizeof (G_PASTE (VAEncMiscParameter, type)))
+
+/* GstVaapiEncPicture  */
+#define GST_VAAPI_ENC_PICTURE_NEW(codec, encoder, frame)                \
+  gst_vaapi_enc_picture_new (GST_VAAPI_ENCODER_CAST (encoder),          \
+      NULL, sizeof (G_PASTE (VAEncPictureParameterBuffer, codec)), frame)
+
+/* GstVaapiEncSlice */
+#define GST_VAAPI_ENC_SLICE_NEW(codec, encoder)                         \
+  gst_vaapi_enc_slice_new (GST_VAAPI_ENCODER_CAST (encoder),            \
+      NULL, sizeof(G_PASTE (VAEncSliceParameterBuffer, codec)))
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_ENCODER_OBJECTS_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_priv.h b/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_priv.h
new file mode 100644
index 0000000..5cf748a
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiencoder_priv.h
@@ -0,0 +1,345 @@
+/*
+ *  gstvaapiencoder_priv.h - VA encoder abstraction (private definitions)
+ *
+ *  Copyright (C) 2013-2014 Intel Corporation
+ *    Author: Wind Yuan <feng.yuan@intel.com>
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_ENCODER_PRIV_H
+#define GST_VAAPI_ENCODER_PRIV_H
+
+#include <gst/vaapi/gstvaapiencoder.h>
+#include <gst/vaapi/gstvaapiencoder_objects.h>
+#include <gst/vaapi/gstvaapicontext.h>
+#include <gst/vaapi/gstvaapivideopool.h>
+#include <gst/video/gstvideoutils.h>
+#include <gst/vaapi/gstvaapivalue.h>
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_ENCODER_CAST(encoder) \
+    ((GstVaapiEncoder *)(encoder))
+
+#define GST_VAAPI_ENCODER_CLASS(klass) \
+    ((GstVaapiEncoderClass *)(klass))
+
+#define GST_VAAPI_ENCODER_GET_CLASS(obj) \
+    GST_VAAPI_ENCODER_CLASS(GST_VAAPI_MINI_OBJECT_GET_CLASS(obj))
+
+/**
+ * GST_VAAPI_ENCODER_PACKED_HEADERS:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the required set of VA packed headers that
+ * need to be submitted along with the corresponding param buffers.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_PACKED_HEADERS
+#define GST_VAAPI_ENCODER_PACKED_HEADERS(encoder) \
+    GST_VAAPI_ENCODER_CAST(encoder)->packed_headers
+
+/**
+ * GST_VAAPI_ENCODER_DISPLAY:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the #GstVaapiDisplay of @encoder.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_DISPLAY
+#define GST_VAAPI_ENCODER_DISPLAY(encoder) \
+    GST_VAAPI_ENCODER_CAST(encoder)->display
+
+/**
+ * GST_VAAPI_ENCODER_CONTEXT:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the #GstVaapiContext of @encoder.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_CONTEXT
+#define GST_VAAPI_ENCODER_CONTEXT(encoder) \
+    GST_VAAPI_ENCODER_CAST(encoder)->context
+
+/**
+ * GST_VAAPI_ENCODER_VIDEO_INFO:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the #GstVideoInfo of @encoder.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_VIDEO_INFO
+#define GST_VAAPI_ENCODER_VIDEO_INFO(encoder) \
+  (&GST_VAAPI_ENCODER_CAST (encoder)->video_info)
+
+/**
+ * GST_VAAPI_ENCODER_WIDTH:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the coded width of the picture.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_WIDTH
+#define GST_VAAPI_ENCODER_WIDTH(encoder) \
+  (GST_VAAPI_ENCODER_VIDEO_INFO (encoder)->width)
+
+/**
+ * GST_VAAPI_ENCODER_HEIGHT:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the coded height of the picture.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_HEIGHT
+#define GST_VAAPI_ENCODER_HEIGHT(encoder) \
+  (GST_VAAPI_ENCODER_VIDEO_INFO (encoder)->height)
+
+/**
+ * GST_VAAPI_ENCODER_FPS_N:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the coded framerate numerator.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_FPS_N
+#define GST_VAAPI_ENCODER_FPS_N(encoder) \
+  (GST_VAAPI_ENCODER_VIDEO_INFO (encoder)->fps_n)
+
+/**
+ * GST_VAAPI_ENCODER_FPS_D:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the coded framerate denominator.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_FPS_D
+#define GST_VAAPI_ENCODER_FPS_D(encoder) \
+  (GST_VAAPI_ENCODER_VIDEO_INFO (encoder)->fps_d)
+
+/**
+ * GST_VAAPI_ENCODER_RATE_CONTROL:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the rate control.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_RATE_CONTROL
+#define GST_VAAPI_ENCODER_RATE_CONTROL(encoder) \
+  (GST_VAAPI_ENCODER_CAST (encoder)->rate_control)
+
+/**
+ * GST_VAAPI_ENCODER_KEYFRAME_PERIOD:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the keyframe period.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_KEYFRAME_PERIOD
+#define GST_VAAPI_ENCODER_KEYFRAME_PERIOD(encoder) \
+  (GST_VAAPI_ENCODER_CAST (encoder)->keyframe_period)
+
+/**
+ * GST_VAAPI_ENCODER_TUNE:
+ * @encoder: a #GstVaapiEncoder
+ *
+ * Macro that evaluates to the tuning option.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_ENCODER_TUNE
+#define GST_VAAPI_ENCODER_TUNE(encoder) \
+  (GST_VAAPI_ENCODER_CAST (encoder)->tune)
+
+/* Generate a mask for the supplied tuning option (internal) */
+#define GST_VAAPI_ENCODER_TUNE_MASK(TUNE) \
+  (1U << G_PASTE (GST_VAAPI_ENCODER_TUNE_, TUNE))
+
+#define GST_VAAPI_TYPE_ENCODER_TUNE \
+  (gst_vaapi_encoder_tune_get_type ())
+
+typedef struct _GstVaapiEncoderClass GstVaapiEncoderClass;
+typedef struct _GstVaapiEncoderClassData GstVaapiEncoderClassData;
+
+/* Private GstVaapiEncoderPropInfo definition */
+typedef struct {
+  gint prop;
+  GParamSpec *pspec;
+} GstVaapiEncoderPropData;
+
+#define GST_VAAPI_ENCODER_PROPERTIES_APPEND(props, id, pspec) do {      \
+    props = gst_vaapi_encoder_properties_append (props, id, pspec);     \
+    if (!props)                                                         \
+      return NULL;                                                      \
+  } while (0)
+
+G_GNUC_INTERNAL
+GPtrArray *
+gst_vaapi_encoder_properties_append (GPtrArray * props, gint prop_id,
+    GParamSpec *pspec);
+
+G_GNUC_INTERNAL
+GPtrArray *
+gst_vaapi_encoder_properties_get_default (const GstVaapiEncoderClass * klass);
+
+struct _GstVaapiEncoder
+{
+  /*< private >*/
+  GstVaapiMiniObject parent_instance;
+
+  GPtrArray *properties;
+  GstVaapiDisplay *display;
+  GstVaapiContext *context;
+  GstVaapiContextInfo context_info;
+  GstVaapiEncoderTune tune;
+  guint packed_headers;
+
+  VADisplay va_display;
+  VAContextID va_context;
+  GstVideoInfo video_info;
+  GstVaapiProfile profile;
+  guint num_ref_frames;
+  GstVaapiRateControl rate_control;
+  guint32 rate_control_mask;
+  guint bitrate; /* kbps */
+  guint keyframe_period;
+
+  GMutex mutex;
+  GCond surface_free;
+  GCond codedbuf_free;
+  guint codedbuf_size;
+  GstVaapiVideoPool *codedbuf_pool;
+  GAsyncQueue *codedbuf_queue;
+  guint32 num_codedbuf_queued;
+
+  guint got_packed_headers:1;
+  guint got_rate_control_mask:1;
+};
+
+struct _GstVaapiEncoderClassData
+{
+  /*< private >*/
+  GstVaapiCodec codec;
+  guint32 packed_headers;
+
+  GType (*rate_control_get_type)(void);
+  GstVaapiRateControl default_rate_control;
+  guint32 rate_control_mask;
+
+  GType (*encoder_tune_get_type)(void);
+  GstVaapiEncoderTune default_encoder_tune;
+  guint32 encoder_tune_mask;
+};
+
+#define GST_VAAPI_ENCODER_DEFINE_CLASS_DATA(CODEC)                      \
+  GST_VAAPI_TYPE_DEFINE_ENUM_SUBSET_FROM_MASK(                          \
+      G_PASTE (GstVaapiRateControl, CODEC),                             \
+      G_PASTE (gst_vaapi_rate_control_, CODEC),                         \
+      GST_VAAPI_TYPE_RATE_CONTROL, SUPPORTED_RATECONTROLS);             \
+                                                                        \
+  GST_VAAPI_TYPE_DEFINE_ENUM_SUBSET_FROM_MASK(                          \
+      G_PASTE (GstVaapiEncoderTune, CODEC),                             \
+      G_PASTE (gst_vaapi_encoder_tune_, CODEC),                         \
+      GST_VAAPI_TYPE_ENCODER_TUNE, SUPPORTED_TUNE_OPTIONS);             \
+                                                                        \
+  static const GstVaapiEncoderClassData g_class_data = {                \
+    .codec = G_PASTE (GST_VAAPI_CODEC_, CODEC),                         \
+    .packed_headers = SUPPORTED_PACKED_HEADERS,                         \
+    .rate_control_get_type =                                            \
+        G_PASTE (G_PASTE (gst_vaapi_rate_control_, CODEC), _get_type),  \
+    .default_rate_control = DEFAULT_RATECONTROL,                        \
+    .rate_control_mask = SUPPORTED_RATECONTROLS,                        \
+    .encoder_tune_get_type =                                            \
+        G_PASTE (G_PASTE (gst_vaapi_encoder_tune_, CODEC), _get_type),  \
+    .default_encoder_tune = GST_VAAPI_ENCODER_TUNE_NONE,                \
+    .encoder_tune_mask = SUPPORTED_TUNE_OPTIONS,                        \
+  }
+
+struct _GstVaapiEncoderClass
+{
+  /*< private >*/
+  GstVaapiMiniObjectClass parent_class;
+
+  const GstVaapiEncoderClassData *class_data;
+
+  gboolean              (*init)         (GstVaapiEncoder * encoder);
+  void                  (*finalize)     (GstVaapiEncoder * encoder);
+
+  GstVaapiEncoderStatus (*reconfigure)  (GstVaapiEncoder * encoder);
+
+  GPtrArray *           (*get_default_properties) (void);
+  GstVaapiEncoderStatus (*set_property) (GstVaapiEncoder * encoder,
+                                         gint prop_id,
+                                         const GValue * value);
+
+  GstVaapiEncoderStatus (*reordering)   (GstVaapiEncoder * encoder,
+                                         GstVideoCodecFrame * in,
+                                         GstVaapiEncPicture ** out);
+  GstVaapiEncoderStatus (*encode)       (GstVaapiEncoder * encoder,
+                                         GstVaapiEncPicture * picture,
+                                         GstVaapiCodedBufferProxy * codedbuf);
+
+  GstVaapiEncoderStatus (*flush)        (GstVaapiEncoder * encoder);
+
+  /* get_codec_data can be NULL */
+  GstVaapiEncoderStatus (*get_codec_data) (GstVaapiEncoder * encoder,
+                                           GstBuffer ** codec_data);
+};
+
+#define GST_VAAPI_ENCODER_CLASS_HOOK(codec, func) \
+  .func = G_PASTE (G_PASTE (G_PASTE (gst_vaapi_encoder_,codec),_), func)
+
+#define GST_VAAPI_ENCODER_CLASS_INIT_BASE(CODEC)                \
+  .parent_class = {                                             \
+    .size = sizeof (G_PASTE (GstVaapiEncoder, CODEC)),          \
+    .finalize = (GDestroyNotify) gst_vaapi_encoder_finalize     \
+  }
+
+#define GST_VAAPI_ENCODER_CLASS_INIT(CODEC, codec)              \
+  GST_VAAPI_ENCODER_CLASS_INIT_BASE (CODEC),                    \
+    .class_data = &g_class_data,                                \
+    GST_VAAPI_ENCODER_CLASS_HOOK (codec, init),                 \
+    GST_VAAPI_ENCODER_CLASS_HOOK (codec, finalize),             \
+    GST_VAAPI_ENCODER_CLASS_HOOK (codec, reconfigure),          \
+    GST_VAAPI_ENCODER_CLASS_HOOK (codec, get_default_properties), \
+    GST_VAAPI_ENCODER_CLASS_HOOK (codec, reordering),           \
+    GST_VAAPI_ENCODER_CLASS_HOOK (codec, encode),               \
+    GST_VAAPI_ENCODER_CLASS_HOOK (codec, flush)
+
+G_GNUC_INTERNAL
+GstVaapiEncoder *
+gst_vaapi_encoder_new (const GstVaapiEncoderClass * klass,
+    GstVaapiDisplay * display);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_encoder_finalize (GstVaapiEncoder * encoder);
+
+G_GNUC_INTERNAL
+GstVaapiSurfaceProxy *
+gst_vaapi_encoder_create_surface (GstVaapiEncoder *
+    encoder);
+
+static inline void
+gst_vaapi_encoder_release_surface (GstVaapiEncoder * encoder,
+    GstVaapiSurfaceProxy * proxy)
+{
+  gst_vaapi_surface_proxy_unref (proxy);
+}
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_ENCODER_PRIV_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiimage.h b/lib/libv4l-hva/gst/vaapi/gstvaapiimage.h
new file mode 100644
index 0000000..6e440ef
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiimage.h
@@ -0,0 +1,136 @@
+/*
+ *  gstvaapiimage.h - VA image abstraction
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_IMAGE_H
+#define GST_VAAPI_IMAGE_H
+
+#include <gst/gstbuffer.h>
+#include <gst/vaapi/gstvaapiobject.h>
+#include <gst/vaapi/gstvaapidisplay.h>
+#include <gst/vaapi/video-format.h>
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_IMAGE(obj) \
+    ((GstVaapiImage *)(obj))
+
+/**
+ * GST_VAAPI_IMAGE_FORMAT:
+ * @image: a #GstVaapiImage
+ *
+ * Macro that evaluates to the #GstVideoFormat of @image.
+ */
+#define GST_VAAPI_IMAGE_FORMAT(image)   gst_vaapi_image_get_format(image)
+
+/**
+ * GST_VAAPI_IMAGE_WIDTH:
+ * @image: a #GstVaapiImage
+ *
+ * Macro that evaluates to the width of @image.
+ */
+#define GST_VAAPI_IMAGE_WIDTH(image)    gst_vaapi_image_get_width(image)
+
+/**
+ * GST_VAAPI_IMAGE_HEIGHT:
+ * @image: a #GstVaapiImage
+ *
+ * Macro that evaluates to the height of @image.
+ */
+#define GST_VAAPI_IMAGE_HEIGHT(image)   gst_vaapi_image_get_height(image)
+
+typedef struct _GstVaapiImage                   GstVaapiImage;
+
+GstVaapiImage *
+gst_vaapi_image_new(
+    GstVaapiDisplay    *display,
+    GstVideoFormat      format,
+    guint               width,
+    guint               height
+);
+
+GstVaapiImage *
+gst_vaapi_image_new_with_image(GstVaapiDisplay *display, VAImage *va_image);
+
+GstVaapiID
+gst_vaapi_image_get_id(GstVaapiImage *image);
+
+gboolean
+gst_vaapi_image_get_image(GstVaapiImage *image, VAImage *va_image);
+
+GstVideoFormat
+gst_vaapi_image_get_format(GstVaapiImage *image);
+
+guint
+gst_vaapi_image_get_width(GstVaapiImage *image);
+
+guint
+gst_vaapi_image_get_height(GstVaapiImage *image);
+
+void
+gst_vaapi_image_get_size(GstVaapiImage *image, guint *pwidth, guint *pheight);
+
+gboolean
+gst_vaapi_image_is_linear(GstVaapiImage *image);
+
+gboolean
+gst_vaapi_image_is_mapped(GstVaapiImage *image);
+
+gboolean
+gst_vaapi_image_map(GstVaapiImage *image);
+
+gboolean
+gst_vaapi_image_unmap(GstVaapiImage *image);
+
+guint
+gst_vaapi_image_get_plane_count(GstVaapiImage *image);
+
+guchar *
+gst_vaapi_image_get_plane(GstVaapiImage *image, guint plane);
+
+guint
+gst_vaapi_image_get_pitch(GstVaapiImage *image, guint plane);
+
+guint
+gst_vaapi_image_get_data_size(GstVaapiImage *image);
+
+gboolean
+gst_vaapi_image_get_buffer(
+    GstVaapiImage     *image,
+    GstBuffer         *buffer,
+    GstVaapiRectangle *rect
+);
+
+gboolean
+gst_vaapi_image_update_from_buffer(
+    GstVaapiImage     *image,
+    GstBuffer         *buffer,
+    GstVaapiRectangle *rect
+);
+
+gboolean
+gst_vaapi_image_copy(GstVaapiImage *dst_image, GstVaapiImage *src_image);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_IMAGE_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiminiobject.h b/lib/libv4l-hva/gst/vaapi/gstvaapiminiobject.h
new file mode 100644
index 0000000..058378d
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiminiobject.h
@@ -0,0 +1,156 @@
+/*
+ *  gstvaapiminiobject.h - A lightweight reference counted object
+ *
+ *  Copyright (C) 2012-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_MINI_OBJECT_H
+#define GST_VAAPI_MINI_OBJECT_H
+
+#include <glib.h>
+#include "libgstvaapi_priv_check.h"
+
+G_BEGIN_DECLS
+
+typedef struct _GstVaapiMiniObject      GstVaapiMiniObject;
+typedef struct _GstVaapiMiniObjectClass GstVaapiMiniObjectClass;
+
+/**
+ * GST_VAAPI_MINI_OBJECT:
+ * @object: a #GstVaapiMiniObject
+ *
+ * Casts the @object to a #GstVaapiMiniObject
+ */
+#define GST_VAAPI_MINI_OBJECT(object) \
+    ((GstVaapiMiniObject *)(object))
+
+/**
+ * GST_VAAPI_MINI_OBJECT_CLASS:
+ * @klass: a #GstVaapiMiniObjectClass
+ *
+ * Casts the @klass to a #GstVaapiMiniObjectClass
+ */
+#define GST_VAAPI_MINI_OBJECT_CLASS(klass) \
+    ((GstVaapiMiniObjectClass *)(klass))
+
+/**
+ * GST_VAAPI_MINI_OBJECT_GET_CLASS:
+ * @object: a #GstVaapiMiniObject
+ *
+ * Retrieves the #GstVaapiMiniObjectClass associated with the @object
+ */
+#define GST_VAAPI_MINI_OBJECT_GET_CLASS(object) \
+    (GST_VAAPI_MINI_OBJECT(object)->object_class)
+
+/**
+ * GST_VAAPI_MINI_OBJECT_FLAGS:
+ * @object: a #GstVaapiMiniObject
+ *
+ * The entire set of flags for the @object
+ */
+#define GST_VAAPI_MINI_OBJECT_FLAGS(object) \
+    (GST_VAAPI_MINI_OBJECT(object)->flags)
+
+/**
+ * GST_VAAPI_MINI_OBJECT_FLAG_IS_SET:
+ * @object: a #GstVaapiMiniObject
+ * @flag: a flag to check for
+ *
+ * Checks whether the given @flag is set
+ */
+#define GST_VAAPI_MINI_OBJECT_FLAG_IS_SET(object, flag) \
+    ((GST_VAAPI_MINI_OBJECT_FLAGS(object) & (flag)) != 0)
+
+/**
+ * GST_VAAPI_MINI_OBJECT_FLAG_SET:
+ * @object: a #GstVaapiMiniObject
+ * @flags: flags to set
+ *
+ * This macro sets the given bits
+ */
+#define GST_VAAPI_MINI_OBJECT_FLAG_SET(object, flags) \
+    (GST_VAAPI_MINI_OBJECT_FLAGS(object) |= (flags))
+
+/**
+ * GST_VAAPI_MINI_OBJECT_FLAG_UNSET:
+ * @object: a #GstVaapiMiniObject
+ * @flags: flags to unset
+ *
+ * This macro unsets the given bits.
+ */
+#define GST_VAAPI_MINI_OBJECT_FLAG_UNSET(object, flags) \
+    (GST_VAAPI_MINI_OBJECT_FLAGS(object) &= ~(flags))
+
+/**
+ * GstVaapiMiniObject:
+ * @object_class: the #GstVaapiMiniObjectClass
+ * @ref_count: the object reference count that should be manipulated
+ *   through gst_vaapi_mini_object_ref() et al. helpers
+ * @flags: set of flags that should be manipulated through
+ *   GST_VAAPI_MINI_OBJECT_FLAG_*() functions
+ *
+ * A #GstVaapiMiniObject represents a minimal reference counted data
+ * structure that can hold a set of flags and user-provided data.
+ */
+struct _GstVaapiMiniObject {
+    /*< private >*/
+    gconstpointer       object_class;
+    volatile gint       ref_count;
+    guint               flags;
+};
+
+/**
+ * GstVaapiMiniObjectClass:
+ * @size: size in bytes of the #GstVaapiMiniObject, plus any
+ *   additional data for derived classes
+ * @finalize: function called to destroy data in derived classes
+ *
+ * A #GstVaapiMiniObjectClass represents the base object class that
+ * defines the size of the #GstVaapiMiniObject and utility function to
+ * dispose child objects
+ */
+struct _GstVaapiMiniObjectClass {
+    guint               size;
+    GDestroyNotify      finalize;
+};
+
+G_GNUC_INTERNAL
+GstVaapiMiniObject *
+gst_vaapi_mini_object_new(const GstVaapiMiniObjectClass *object_class);
+
+G_GNUC_INTERNAL
+GstVaapiMiniObject *
+gst_vaapi_mini_object_new0(const GstVaapiMiniObjectClass *object_class);
+
+G_GNUC_INTERNAL
+GstVaapiMiniObject *
+gst_vaapi_mini_object_ref(GstVaapiMiniObject *object);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_mini_object_unref(GstVaapiMiniObject *object);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_mini_object_replace(GstVaapiMiniObject **old_object_ptr,
+    GstVaapiMiniObject *new_object);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_MINI_OBJECT_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiobject.h b/lib/libv4l-hva/gst/vaapi/gstvaapiobject.h
new file mode 100644
index 0000000..ed76af1
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiobject.h
@@ -0,0 +1,79 @@
+/*
+ *  gstvaapiobject.h - Base VA object
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2012-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_OBJECT_H
+#define GST_VAAPI_OBJECT_H
+
+#include <gst/vaapi/gstvaapitypes.h>
+#include <gst/vaapi/gstvaapidisplay.h>
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_OBJECT(obj) \
+    ((GstVaapiObject *)(obj))
+
+typedef struct _GstVaapiObject                  GstVaapiObject;
+
+/**
+ * GST_VAAPI_OBJECT_DISPLAY:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the #GstVaapiDisplay the @object is bound to.
+ */
+#define GST_VAAPI_OBJECT_DISPLAY(object) \
+    gst_vaapi_object_get_display(GST_VAAPI_OBJECT(object))
+
+/**
+ * GST_VAAPI_OBJECT_ID:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the #GstVaapiID contained in @object.
+ */
+#define GST_VAAPI_OBJECT_ID(object) \
+    gst_vaapi_object_get_id(GST_VAAPI_OBJECT(object))
+
+gpointer
+gst_vaapi_object_ref(gpointer object);
+
+void
+gst_vaapi_object_unref(gpointer object);
+
+void
+gst_vaapi_object_replace(gpointer old_object_ptr, gpointer new_object);
+
+GstVaapiDisplay *
+gst_vaapi_object_get_display(GstVaapiObject *object);
+
+void
+gst_vaapi_object_lock_display(GstVaapiObject *object);
+
+void
+gst_vaapi_object_unlock_display(GstVaapiObject *object);
+
+GstVaapiID
+gst_vaapi_object_get_id(GstVaapiObject *object);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_OBJECT_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiobject_priv.h b/lib/libv4l-hva/gst/vaapi/gstvaapiobject_priv.h
new file mode 100644
index 0000000..f6f3a58
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiobject_priv.h
@@ -0,0 +1,257 @@
+/*
+ *  gstvaapiobject_priv.h - Base VA object (private definitions)
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2012-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_OBJECT_PRIV_H
+#define GST_VAAPI_OBJECT_PRIV_H
+
+#include <gst/vaapi/gstvaapiobject.h>
+#include "gstvaapiminiobject.h"
+#include "gstvaapidisplay_priv.h"
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_OBJECT_CLASS(klass) \
+    ((GstVaapiObjectClass *)(klass))
+
+#define GST_VAAPI_IS_OBJECT_CLASS(klass) \
+    ((klass) != NULL)
+
+#define GST_VAAPI_OBJECT_GET_CLASS(object) \
+    GST_VAAPI_OBJECT_CLASS(GST_VAAPI_MINI_OBJECT_GET_CLASS(object))
+
+typedef struct _GstVaapiObjectClass             GstVaapiObjectClass;
+typedef void (*GstVaapiObjectInitFunc)         (GstVaapiObject *object);
+typedef void (*GstVaapiObjectFinalizeFunc)     (GstVaapiObject *object);
+
+#define GST_VAAPI_OBJECT_DEFINE_CLASS_WITH_CODE(TN, t_n, code)  \
+static inline const GstVaapiObjectClass *                       \
+G_PASTE(t_n,_class)(void)                                       \
+{                                                               \
+    static G_PASTE(TN,Class) g_class;                           \
+    static gsize g_class_init = FALSE;                          \
+                                                                \
+    if (g_once_init_enter(&g_class_init)) {                     \
+        GstVaapiObjectClass * const klass =                     \
+            GST_VAAPI_OBJECT_CLASS(&g_class);                   \
+        gst_vaapi_object_class_init(klass, sizeof(TN));         \
+        code;                                                   \
+        klass->finalize = (GstVaapiObjectFinalizeFunc)          \
+            G_PASTE(t_n,_finalize);                             \
+        g_once_init_leave(&g_class_init, TRUE);                 \
+    }                                                           \
+    return GST_VAAPI_OBJECT_CLASS(&g_class);                    \
+}
+
+#define GST_VAAPI_OBJECT_DEFINE_CLASS(TN, t_n) \
+    GST_VAAPI_OBJECT_DEFINE_CLASS_WITH_CODE(TN, t_n, /**/)
+
+/**
+ * GST_VAAPI_OBJECT_DISPLAY:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the #GstVaapiDisplay the @object is bound to.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_OBJECT_DISPLAY
+#define GST_VAAPI_OBJECT_DISPLAY(object) \
+    GST_VAAPI_OBJECT(object)->display
+
+/**
+ * GST_VAAPI_OBJECT_ID:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the #GstVaapiID contained in @object.
+ * This is an internal macro that does not do any run-time type checks.
+ */
+#undef  GST_VAAPI_OBJECT_ID
+#define GST_VAAPI_OBJECT_ID(object) \
+    GST_VAAPI_OBJECT(object)->object_id
+
+/**
+ * GST_VAAPI_OBJECT_DISPLAY_X11:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the #GstVaapiDisplayX11 the @object is bound to.
+ * This is an internal macro that does not do any run-time type check
+ * and requires #include "gstvaapidisplay_x11_priv.h"
+ */
+#define GST_VAAPI_OBJECT_DISPLAY_X11(object) \
+    GST_VAAPI_DISPLAY_X11_CAST(GST_VAAPI_OBJECT_DISPLAY(object))
+
+/**
+ * GST_VAAPI_OBJECT_DISPLAY_GLX:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the #GstVaapiDisplayGLX the @object is bound to.
+ * This is an internal macro that does not do any run-time type check
+ * and requires #include "gstvaapidisplay_glx_priv.h".
+ */
+#define GST_VAAPI_OBJECT_DISPLAY_GLX(object) \
+    GST_VAAPI_DISPLAY_GLX_CAST(GST_VAAPI_OBJECT_DISPLAY(object))
+
+/**
+ * GST_VAAPI_OBJECT_DISPLAY_WAYLAND:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the #GstVaapiDisplayWayland the @object is
+ * bound to.  This is an internal macro that does not do any run-time
+ * type check and requires #include "gstvaapidisplay_wayland_priv.h"
+ */
+#define GST_VAAPI_OBJECT_DISPLAY_WAYLAND(object) \
+    GST_VAAPI_DISPLAY_WAYLAND_CAST(GST_VAAPI_OBJECT_DISPLAY(object))
+
+/**
+ * GST_VAAPI_OBJECT_VADISPLAY:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the #VADisplay of @display.
+ * This is an internal macro that does not do any run-time type check
+ * and requires #include "gstvaapidisplay_priv.h".
+ */
+#define GST_VAAPI_OBJECT_VADISPLAY(object) \
+    GST_VAAPI_DISPLAY_VADISPLAY(GST_VAAPI_OBJECT_DISPLAY(object))
+
+/**
+ * GST_VAAPI_OBJECT_XDISPLAY:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the underlying X11 #Display of @display.
+ * This is an internal macro that does not do any run-time type check
+ * and requires #include "gstvaapidisplay_x11_priv.h".
+ */
+#define GST_VAAPI_OBJECT_XDISPLAY(object) \
+    GST_VAAPI_DISPLAY_XDISPLAY(GST_VAAPI_OBJECT_DISPLAY(object))
+
+/**
+ * GST_VAAPI_OBJECT_XSCREEN:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the underlying X11 screen of @display.
+ * This is an internal macro that does not do any run-time type check
+ * and requires #include "gstvaapidisplay_x11_priv.h".
+ */
+#define GST_VAAPI_OBJECT_XSCREEN(object) \
+    GST_VAAPI_DISPLAY_XSCREEN(GST_VAAPI_OBJECT_DISPLAY(object))
+
+/**
+ * GST_VAAPI_OBJECT_WL_DISPLAY:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that evaluates to the underlying #wl_display of @display.
+ * This is an internal macro that does not do any run-time type check
+ * and requires #include "gstvaapidisplay_wayland_priv.h".
+ */
+#define GST_VAAPI_OBJECT_WL_DISPLAY(object) \
+    GST_VAAPI_DISPLAY_WL_DISPLAY(GST_VAAPI_OBJECT_DISPLAY(object))
+
+/**
+ * GST_VAAPI_OBJECT_LOCK_DISPLAY:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that locks the #GstVaapiDisplay contained in the @object.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#define GST_VAAPI_OBJECT_LOCK_DISPLAY(object) \
+    GST_VAAPI_DISPLAY_LOCK(GST_VAAPI_OBJECT_DISPLAY(object))
+
+/**
+ * GST_VAAPI_OBJECT_UNLOCK_DISPLAY:
+ * @object: a #GstVaapiObject
+ *
+ * Macro that unlocks the #GstVaapiDisplay contained in the @object.
+ * This is an internal macro that does not do any run-time type check.
+ */
+#define GST_VAAPI_OBJECT_UNLOCK_DISPLAY(object) \
+    GST_VAAPI_DISPLAY_UNLOCK(GST_VAAPI_OBJECT_DISPLAY(object))
+
+/**
+ * GstVaapiObject:
+ *
+ * VA object base.
+ */
+struct _GstVaapiObject {
+    /*< private >*/
+    GstVaapiMiniObject  parent_instance;
+
+    GstVaapiDisplay    *display;
+    GstVaapiID          object_id;
+};
+
+/**
+ * GstVaapiObjectClass:
+ *
+ * VA object base class.
+ */
+struct _GstVaapiObjectClass {
+    /*< private >*/
+    GstVaapiMiniObjectClass     parent_class;
+
+    GstVaapiObjectInitFunc      init;
+    GstVaapiObjectFinalizeFunc  finalize;
+};
+
+void
+gst_vaapi_object_class_init(GstVaapiObjectClass *klass, guint size);
+
+gpointer
+gst_vaapi_object_new(const GstVaapiObjectClass *klass,
+    GstVaapiDisplay *display);
+
+/* Inline reference counting for core libgstvaapi library */
+#ifdef IN_LIBGSTVAAPI_CORE
+static inline gpointer
+gst_vaapi_object_ref_internal(gpointer object)
+{
+    return gst_vaapi_mini_object_ref(object);
+}
+
+static inline void
+gst_vaapi_object_unref_internal(gpointer object)
+{
+    gst_vaapi_mini_object_unref(object);
+}
+
+static inline void
+gst_vaapi_object_replace_internal(gpointer old_object_ptr, gpointer new_object)
+{
+    gst_vaapi_mini_object_replace((GstVaapiMiniObject **)old_object_ptr,
+        new_object);
+}
+
+#undef  gst_vaapi_object_ref
+#define gst_vaapi_object_ref(object) \
+    gst_vaapi_object_ref_internal((object))
+
+#undef  gst_vaapi_object_unref
+#define gst_vaapi_object_unref(object) \
+    gst_vaapi_object_unref_internal((object))
+
+#undef  gst_vaapi_object_replace
+#define gst_vaapi_object_replace(old_object_ptr, new_object) \
+    gst_vaapi_object_replace_internal((old_object_ptr), (new_object))
+#endif
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_OBJECT_PRIV_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiparser_frame.h b/lib/libv4l-hva/gst/vaapi/gstvaapiparser_frame.h
new file mode 100644
index 0000000..b8de9bc
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiparser_frame.h
@@ -0,0 +1,87 @@
+/*
+ *  gstvaapiparser_frame.h - VA parser frame
+ *
+ *  Copyright (C) 2012-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_PARSER_FRAME_H
+#define GST_VAAPI_PARSER_FRAME_H
+
+#include <gst/vaapi/gstvaapiminiobject.h>
+#include <gst/vaapi/gstvaapidecoder_unit.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GstVaapiParserFrame             GstVaapiParserFrame;
+
+#define GST_VAAPI_PARSER_FRAME(frame) \
+    ((GstVaapiParserFrame *)(frame))
+
+#define GST_VAAPI_IS_PARSER_FRAME(frame) \
+    (GST_VAAPI_PARSER_FRAME(frame) != NULL)
+
+/**
+ * GstVaapiParserFrame:
+ * @output_offset: current offset to the reconstructed #GstBuffer for
+ *    this #GstVideoCodecFrame. This is used to initialize the decoder
+ *    unit offset
+ * @units: list of #GstVaapiDecoderUnit objects (slice data)
+ * @pre_units: list of units to decode before GstVaapiDecoder:start_frame()
+ * @post_units: list of units to decode after GstVaapiDecoder:end_frame()
+ *
+ * An extension to #GstVideoCodecFrame with #GstVaapiDecoder specific
+ * information. Decoder frames are usually attached to codec frames as
+ * the user_data anchor point.
+ */
+struct _GstVaapiParserFrame {
+    /*< private >*/
+    GstVaapiMiniObject  parent_instance;
+
+    guint               output_offset;
+    GArray             *units;
+    GArray             *pre_units;
+    GArray             *post_units;
+};
+
+G_GNUC_INTERNAL
+GstVaapiParserFrame *
+gst_vaapi_parser_frame_new(guint width, guint height);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_parser_frame_free(GstVaapiParserFrame *frame);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_parser_frame_append_unit(GstVaapiParserFrame *frame,
+    GstVaapiDecoderUnit *unit);
+
+#define gst_vaapi_parser_frame_ref(frame) \
+    gst_vaapi_mini_object_ref(GST_VAAPI_MINI_OBJECT(frame))
+
+#define gst_vaapi_parser_frame_unref(frame) \
+    gst_vaapi_mini_object_unref(GST_VAAPI_MINI_OBJECT(frame))
+
+#define gst_vaapi_parser_frame_replace(old_frame_p, new_frame)          \
+    gst_vaapi_mini_object_replace((GstVaapiMiniObject **)(old_frame_p), \
+        (GstVaapiMiniObject *)(new_frame))
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_PARSER_FRAME_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiprofile.h b/lib/libv4l-hva/gst/vaapi/gstvaapiprofile.h
new file mode 100644
index 0000000..24dde89
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiprofile.h
@@ -0,0 +1,206 @@
+/*
+ *  gstvaapiprofile.h - VA profile abstraction
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2012-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_PROFILE_H
+#define GST_VAAPI_PROFILE_H
+
+#include <gst/gstvalue.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GstVaapiCodec:
+ * @GST_VAAPI_CODEC_MPEG1: MPEG-1 (ISO/IEC 11172)
+ * @GST_VAAPI_CODEC_MPEG2: MPEG-2 (ISO/IEC 13818-2)
+ * @GST_VAAPI_CODEC_MPEG4: MPEG-4 Part 2 (ISO/IEC 14496-2)
+ * @GST_VAAPI_CODEC_H263: H.263
+ * @GST_VAAPI_CODEC_H264: H.264 aka MPEG-4 Part 10 (ISO/IEC 14496-10)
+ * @GST_VAAPI_CODEC_WMV3: Windows Media Video 9. VC-1 Simple or Main profile (SMPTE 421M)
+ * @GST_VAAPI_CODEC_VC1: VC-1 Advanced profile (SMPTE 421M)
+ * @GST_VAAPI_CODEC_JPEG: JPEG (ITU-T 81)
+ *
+ * The set of all codecs for #GstVaapiCodec.
+ */
+typedef enum {
+    GST_VAAPI_CODEC_MPEG1       = GST_MAKE_FOURCC('M','P','1',0),
+    GST_VAAPI_CODEC_MPEG2       = GST_MAKE_FOURCC('M','P','2',0),
+    GST_VAAPI_CODEC_MPEG4       = GST_MAKE_FOURCC('M','P','4',0),
+    GST_VAAPI_CODEC_H263        = GST_MAKE_FOURCC('2','6','3',0),
+    GST_VAAPI_CODEC_H264        = GST_MAKE_FOURCC('2','6','4',0),
+    GST_VAAPI_CODEC_WMV3        = GST_MAKE_FOURCC('W','M','V',0),
+    GST_VAAPI_CODEC_VC1         = GST_MAKE_FOURCC('V','C','1',0),
+    GST_VAAPI_CODEC_JPEG        = GST_MAKE_FOURCC('J','P','G',0),
+    GST_VAAPI_CODEC_VP8         = GST_MAKE_FOURCC('V','P','8',0),
+} GstVaapiCodec;
+
+/**
+ * GST_VAAPI_MAKE_PROFILE:
+ * @codec: the #GstVaapiCodec without the GST_VAAPI_CODEC_ prefix
+ * @sub_id: a non-zero sub-codec id
+ *
+ * Macro that evaluates to the profile composed from @codec and
+ * @sub_id.
+ */
+#define GST_VAAPI_MAKE_PROFILE(codec, sub_id) \
+    (GST_VAAPI_CODEC_##codec | GST_MAKE_FOURCC(0,0,0,sub_id))
+
+/**
+ * GstVaapiProfile:
+ * @GST_VAAPI_PROFILE_UNKNOWN:
+ *   Unknown profile, used for initializers
+ * @GST_VAAPI_PROFILE_MPEG1:
+ *   MPEG-1
+ * @GST_VAAPI_PROFILE_MPEG2_SIMPLE:
+ *   MPEG-2 simple profile
+ * @GST_VAAPI_PROFILE_MPEG2_MAIN:
+ *   MPEG-2 main profile
+ * @GST_VAAPI_PROFILE_MPEG2_HIGH:
+ *   MPEG-2 high profile
+ * @GST_VAAPI_PROFILE_MPEG4_SIMPLE:
+ *   MPEG-4 Part-2 simple profile
+ * @GST_VAAPI_PROFILE_MPEG4_ADVANCED_SIMPLE:
+ *   MPEG-4 Part-2 advanced simple profile
+ * @GST_VAAPI_PROFILE_MPEG4_MAIN:
+ *   MPEG-4 Part-2 main profile
+ * @GST_VAAPI_PROFILE_H263_BASELINE:
+ *   H.263 baseline profile
+ * @GST_VAAPI_PROFILE_H264_BASELINE:
+ *   H.264 (MPEG-4 Part-10) baseline profile [A.2.1]
+ * @GST_VAAPI_PROFILE_H264_CONSTRAINED_BASELINE:
+ *   H.264 (MPEG-4 Part-10) constrained baseline profile [A.2.1.1]
+ * @GST_VAAPI_PROFILE_H264_MAIN:
+ *   H.264 (MPEG-4 Part-10) main profile [A.2.2]
+ * @GST_VAAPI_PROFILE_H264_EXTENDED:
+ *   H.264 (MPEG-4 Part 10) extended profile [A.2.3]
+ * @GST_VAAPI_PROFILE_H264_HIGH:
+ *   H.264 (MPEG-4 Part-10) high profile [A.2.4]
+ * @GST_VAAPI_PROFILE_H264_HIGH10:
+ *   H.264 (MPEG-4 Part-10) high 10 profile [A.2.5], or high 10 intra
+ *   profile [A.2.8], depending on constraint_set3_flag
+ * @GST_VAAPI_PROFILE_H264_HIGH_422:
+ *   H.264 (MPEG-4 Part-10) high 4:2:2 profile [A.2.6], or high 4:2:2
+ *   intra profile [A.2.9], depending on constraint_set3_flag
+ * @GST_VAAPI_PROFILE_H264_HIGH_444:
+ *   H.264 (MPEG-4 Part-10) high 4:4:4 predictive profile [A.2.7], or
+ *   high 4:4:4 intra profile [A.2.10], depending on constraint_set3_flag
+ * @GST_VAAPI_PROFILE_H264_SCALABLE_BASELINE:
+ *   H.264 (MPEG-4 Part-10) scalable baseline profile [G.10.1.1]
+ * @GST_VAAPI_PROFILE_H264_SCALABLE_HIGH:
+ *   H.264 (MPEG-4 Part-10) scalable high profile [G.10.1.2], or scalable
+ *   high intra profile [G.10.1.3], depending on constraint_set3_flag
+ * @GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH:
+ *   H.264 (MPEG-4 Part-10) multiview high profile [H.10.1.1]
+ * @GST_VAAPI_PROFILE_H264_STEREO_HIGH:
+ *   H.264 (MPEG-4 Part-10) stereo high profile [H.10.1.2]
+ * @GST_VAAPI_PROFILE_VC1_SIMPLE:
+ *   VC-1 simple profile
+ * @GST_VAAPI_PROFILE_VC1_MAIN:
+ *   VC-1 main profile
+ * @GST_VAAPI_PROFILE_VC1_ADVANCED:
+ *   VC-1 advanced profile
+ * @GST_VAAPI_PROFILE_JPEG_BASELINE:
+ *   JPEG baseline profile
+ *
+ * The set of all profiles for #GstVaapiProfile.
+ */
+typedef enum {
+    GST_VAAPI_PROFILE_UNKNOWN               = 0,
+    GST_VAAPI_PROFILE_MPEG1                 = GST_VAAPI_MAKE_PROFILE(MPEG1,1),
+    GST_VAAPI_PROFILE_MPEG2_SIMPLE          = GST_VAAPI_MAKE_PROFILE(MPEG2,1),
+    GST_VAAPI_PROFILE_MPEG2_MAIN            = GST_VAAPI_MAKE_PROFILE(MPEG2,2),
+    GST_VAAPI_PROFILE_MPEG2_HIGH            = GST_VAAPI_MAKE_PROFILE(MPEG2,3),
+    GST_VAAPI_PROFILE_MPEG4_SIMPLE          = GST_VAAPI_MAKE_PROFILE(MPEG4,1),
+    GST_VAAPI_PROFILE_MPEG4_ADVANCED_SIMPLE = GST_VAAPI_MAKE_PROFILE(MPEG4,2),
+    GST_VAAPI_PROFILE_MPEG4_MAIN            = GST_VAAPI_MAKE_PROFILE(MPEG4,3),
+    GST_VAAPI_PROFILE_H263_BASELINE         = GST_VAAPI_MAKE_PROFILE(H263,1),
+    GST_VAAPI_PROFILE_H264_BASELINE         = GST_VAAPI_MAKE_PROFILE(H264,1),
+    GST_VAAPI_PROFILE_H264_CONSTRAINED_BASELINE =
+                                              GST_VAAPI_MAKE_PROFILE(H264,9),
+    GST_VAAPI_PROFILE_H264_MAIN             = GST_VAAPI_MAKE_PROFILE(H264,2),
+    GST_VAAPI_PROFILE_H264_EXTENDED         = GST_VAAPI_MAKE_PROFILE(H264,10),
+    GST_VAAPI_PROFILE_H264_HIGH             = GST_VAAPI_MAKE_PROFILE(H264,3),
+    GST_VAAPI_PROFILE_H264_HIGH10           = GST_VAAPI_MAKE_PROFILE(H264,7),
+    GST_VAAPI_PROFILE_H264_HIGH_422         = GST_VAAPI_MAKE_PROFILE(H264,4),
+    GST_VAAPI_PROFILE_H264_HIGH_444         = GST_VAAPI_MAKE_PROFILE(H264,8),
+    GST_VAAPI_PROFILE_H264_SCALABLE_BASELINE =
+                                              GST_VAAPI_MAKE_PROFILE(H264,5),
+    GST_VAAPI_PROFILE_H264_SCALABLE_HIGH    = GST_VAAPI_MAKE_PROFILE(H264,6),
+    GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH   = GST_VAAPI_MAKE_PROFILE(H264,11),
+    GST_VAAPI_PROFILE_H264_STEREO_HIGH      = GST_VAAPI_MAKE_PROFILE(H264,15),
+    GST_VAAPI_PROFILE_VC1_SIMPLE            = GST_VAAPI_MAKE_PROFILE(VC1,1),
+    GST_VAAPI_PROFILE_VC1_MAIN              = GST_VAAPI_MAKE_PROFILE(VC1,2),
+    GST_VAAPI_PROFILE_VC1_ADVANCED          = GST_VAAPI_MAKE_PROFILE(VC1,3),
+    GST_VAAPI_PROFILE_JPEG_BASELINE         = GST_VAAPI_MAKE_PROFILE(JPEG,1),
+    GST_VAAPI_PROFILE_VP8                   = GST_VAAPI_MAKE_PROFILE(VP8,1),
+} GstVaapiProfile;
+
+/**
+ * GstVaapiEntrypoint:
+ * @GST_VAAPI_ENTRYPOINT_VLD: Variable Length Decoding
+ * @GST_VAAPI_ENTRYPOINT_IDCT: Inverse Decrete Cosine Transform
+ * @GST_VAAPI_ENTRYPOINT_MOCO: Motion Compensation
+ * @GST_VAAPI_ENTRYPOINT_SLICE_ENCODE: Encode Slice
+ *
+ * The set of all entrypoints for #GstVaapiEntrypoint
+ */
+typedef enum {
+    GST_VAAPI_ENTRYPOINT_VLD = 1,
+    GST_VAAPI_ENTRYPOINT_IDCT,
+    GST_VAAPI_ENTRYPOINT_MOCO,
+    GST_VAAPI_ENTRYPOINT_SLICE_ENCODE
+} GstVaapiEntrypoint;
+
+const gchar *
+gst_vaapi_codec_get_name(GstVaapiCodec codec);
+
+GstVaapiProfile
+gst_vaapi_profile(VAProfile profile);
+
+GstVaapiProfile
+gst_vaapi_profile_from_caps(const GstCaps *caps);
+
+const gchar *
+gst_vaapi_profile_get_name(GstVaapiProfile profile);
+
+const gchar *
+gst_vaapi_profile_get_media_type_name(GstVaapiProfile profile);
+
+VAProfile
+gst_vaapi_profile_get_va_profile(GstVaapiProfile profile);
+
+GstCaps *
+gst_vaapi_profile_get_caps(GstVaapiProfile profile);
+
+GstVaapiCodec
+gst_vaapi_profile_get_codec(GstVaapiProfile profile);
+
+GstVaapiEntrypoint
+gst_vaapi_entrypoint(VAEntrypoint entrypoint);
+
+VAEntrypoint
+gst_vaapi_entrypoint_get_va_entrypoint(GstVaapiEntrypoint entrypoint);
+
+G_END_DECLS
+
+#endif /* GST_GST_VAAPI_IMAGE_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapisubpicture.h b/lib/libv4l-hva/gst/vaapi/gstvaapisubpicture.h
new file mode 100644
index 0000000..7bfef36
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapisubpicture.h
@@ -0,0 +1,86 @@
+/*
+ *  gstvaapisubpicture.h - VA subpicture abstraction
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_SUBPICTURE_H
+#define GST_VAAPI_SUBPICTURE_H
+
+#include <gst/vaapi/gstvaapiobject.h>
+#include <gst/vaapi/gstvaapidisplay.h>
+#include <gst/vaapi/gstvaapiimage.h>
+#include <gst/video/video-overlay-composition.h>
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_SUBPICTURE(obj) \
+    ((GstVaapiSubpicture *)(obj))
+
+typedef struct _GstVaapiSubpicture              GstVaapiSubpicture;
+
+/**
+ * GstVaapiSubpictureFlags:
+ * @GST_VAAPI_SUBPICTURE_FLAG_PREMULTIPLIED_ALPHA:
+ *   subpicture has RGB pixels with pre-multiplied alpha
+ * @GST_VAAPI_SUBPICTURE_FLAG_GLOBAL_ALPHA:
+ *   subpicture needs to be blended with some global-alpha value at
+ *   rendering time
+ *
+ * The set of all subpicture rendering flags for #GstVaapiSubpicture.
+ */
+typedef enum {
+    GST_VAAPI_SUBPICTURE_FLAG_PREMULTIPLIED_ALPHA    = (1 << 0),
+    GST_VAAPI_SUBPICTURE_FLAG_GLOBAL_ALPHA           = (1 << 1),
+} GstVaapiSubpictureFlags;
+
+GstVaapiSubpicture *
+gst_vaapi_subpicture_new(GstVaapiImage *image, guint flags);
+
+GstVaapiSubpicture *
+gst_vaapi_subpicture_new_from_overlay_rectangle(
+    GstVaapiDisplay          *display,
+    GstVideoOverlayRectangle *rect
+);
+
+GstVaapiID
+gst_vaapi_subpicture_get_id(GstVaapiSubpicture *subpicture);
+
+guint
+gst_vaapi_subpicture_get_flags(GstVaapiSubpicture *subpicture);
+
+GstVaapiImage *
+gst_vaapi_subpicture_get_image(GstVaapiSubpicture *subpicture);
+
+gboolean
+gst_vaapi_subpicture_set_image(GstVaapiSubpicture *subpicture,
+    GstVaapiImage *image);
+
+gfloat
+gst_vaapi_subpicture_get_global_alpha(GstVaapiSubpicture *subpicture);
+
+gboolean
+gst_vaapi_subpicture_set_global_alpha(GstVaapiSubpicture *subpicture,
+    gfloat global_alpha);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_SUBPICTURE_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapisurface.h b/lib/libv4l-hva/gst/vaapi/gstvaapisurface.h
new file mode 100644
index 0000000..48f8662
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapisurface.h
@@ -0,0 +1,226 @@
+/*
+ *  gstvaapisurface.h - VA surface abstraction
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_SURFACE_H
+#define GST_VAAPI_SURFACE_H
+
+#include <gst/vaapi/gstvaapiobject.h>
+#include <gst/vaapi/gstvaapidisplay.h>
+#include <gst/vaapi/gstvaapiimage.h>
+#include <gst/vaapi/gstvaapisubpicture.h>
+#include <gst/video/video.h>
+#include <gst/video/video-overlay-composition.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GST_VAAPI_SURFACE_CAPS_NAME:
+ *
+ * Generic caps type for VA surfaces.
+ */
+#define GST_VAAPI_SURFACE_CAPS_NAME "video/x-surface"
+
+/**
+ * GST_VAAPI_SURFACE_CAPS:
+ *
+ * Generic caps for VA surfaces.
+ */
+#define GST_VAAPI_SURFACE_CAPS                  \
+    GST_VAAPI_SURFACE_CAPS_NAME ", "            \
+    "type = vaapi, "                            \
+    "opengl = (boolean) { true, false }, "      \
+    "width  = (int) [ 1, MAX ], "               \
+    "height = (int) [ 1, MAX ], "               \
+    "framerate = (fraction) [ 0, MAX ]"
+
+/**
+ * GstVaapiChromaType:
+ * @GST_VAAPI_CHROMA_TYPE_YUV420: YUV 4:2:0 chroma format
+ * @GST_VAAPI_CHROMA_TYPE_YUV422: YUV 4:2:2 chroma format
+ * @GST_VAAPI_CHROMA_TYPE_YUV444: YUV 4:4:4 chroma format
+ * @GST_VAAPI_CHROMA_TYPE_YUV411: YUV 4:1:1 chroma format
+ * @GST_VAAPI_CHROMA_TYPE_YUV410: YUV 4:1:0 chroma format
+ * @GST_VAAPI_CHROMA_TYPE_YUV400: YUV 4:0:0 chroma format (grayscale)
+ * @GST_VAAPI_CHROMA_TYPE_RGB32: 32-bit RGB chroma format
+ * @GST_VAAPI_CHROMA_TYPE_RGB16: 16-bit RGB chroma format
+ *
+ * The set of all chroma types for #GstVaapiSurface.
+ */
+typedef enum {
+    GST_VAAPI_CHROMA_TYPE_YUV420 = 1,
+    GST_VAAPI_CHROMA_TYPE_YUV422,
+    GST_VAAPI_CHROMA_TYPE_YUV444,
+    GST_VAAPI_CHROMA_TYPE_YUV411,
+    GST_VAAPI_CHROMA_TYPE_YUV410,
+    GST_VAAPI_CHROMA_TYPE_YUV400,
+    GST_VAAPI_CHROMA_TYPE_RGB32,
+    GST_VAAPI_CHROMA_TYPE_RGB16
+} GstVaapiChromaType;
+
+/**
+ * GstVaapiSurfaceStatus:
+ * @GST_VAAPI_SURFACE_STATUS_IDLE:
+ *   the surface is not being rendered or displayed
+ * @GST_VAAPI_SURFACE_STATUS_RENDERING:
+ *   the surface is used for rendering (decoding to the surface in progress)
+ * @GST_VAAPI_SURFACE_STATUS_DISPLAYING:
+ *   the surface is being displayed to screen
+ * @GST_VAAPI_SURFACE_STATUS_SKIPPED:
+ *   indicates a skipped frame during encode
+ *
+ * The set of all surface status for #GstVaapiSurface.
+ */
+typedef enum {
+    GST_VAAPI_SURFACE_STATUS_IDLE       = 1 << 0,
+    GST_VAAPI_SURFACE_STATUS_RENDERING  = 1 << 1,
+    GST_VAAPI_SURFACE_STATUS_DISPLAYING = 1 << 2,
+    GST_VAAPI_SURFACE_STATUS_SKIPPED    = 1 << 3
+} GstVaapiSurfaceStatus;
+
+/**
+ * GstVaapiSurfaceRenderFlags
+ * @GST_VAAPI_PICTURE_STRUCTURE_TOP_FIELD:
+ *   selects the top field of the surface
+ * @GST_VAAPI_PICTURE_STRUCTURE_BOTTOM_FIELD:
+ *   selects the bottom field of the surface
+ * @GST_VAAPI_PICTURE_STRUCTURE_FRAME:
+ *   selects the entire surface
+ * @GST_VAAPI_COLOR_STANDARD_ITUR_BT_601:
+ *   uses ITU-R BT.601 standard for color space conversion
+ * @GST_VAAPI_COLOR_STANDARD_ITUR_BT_709:
+ *   uses ITU-R BT.709 standard for color space conversion
+ * @GST_VAAPI_COLOR_STANDARD_ITUR_BT_470M:
+ *   uses ITU-R BT.470-2 System M standard for color space conversion
+ * @GST_VAAPI_COLOR_STANDARD_ITUR_BT_470BG:
+ *   uses ITU-R BT.470-2 System B, G standard for color space conversion
+ * @GST_VAAPI_COLOR_STANDARD_SMPTE_170M:
+ *   uses SMPTE-170M standard for color space conversion
+ * @GST_VAAPI_COLOR_STANDARD_SMPTE_240M:
+ *   uses SMPTE-240M standard for color space conversion
+ *
+ * The set of all render flags for gst_vaapi_window_put_surface().
+ */
+typedef enum {
+    /* Picture structure */
+    GST_VAAPI_PICTURE_STRUCTURE_TOP_FIELD       = 0x01 << 0,
+    GST_VAAPI_PICTURE_STRUCTURE_BOTTOM_FIELD    = 0x02 << 0,
+    GST_VAAPI_PICTURE_STRUCTURE_FRAME           = 0x03 << 0,
+    GST_VAAPI_PICTURE_STRUCTURE_MASK            = 0x00000003, /* 2 bits */
+
+    /* Color standard */
+    GST_VAAPI_COLOR_STANDARD_ITUR_BT_601        = 0x01 << 2,
+    GST_VAAPI_COLOR_STANDARD_ITUR_BT_709        = 0x02 << 2,
+    GST_VAAPI_COLOR_STANDARD_ITUR_BT_470M       = 0x03 << 2,
+    GST_VAAPI_COLOR_STANDARD_ITUR_BT_470BG      = 0x04 << 2,
+    GST_VAAPI_COLOR_STANDARD_SMPTE_170M         = 0x05 << 2,
+    GST_VAAPI_COLOR_STANDARD_SMPTE_240M         = 0x06 << 2,
+    GST_VAAPI_COLOR_STANDARD_MASK               = 0x0000003c, /* 4 bits */
+} GstVaapiSurfaceRenderFlags;
+
+#define GST_VAAPI_SURFACE(obj) \
+    ((GstVaapiSurface *)(obj))
+
+typedef struct _GstVaapiSurface                 GstVaapiSurface;
+typedef struct _GstVaapiSurfaceProxy            GstVaapiSurfaceProxy;
+
+GstVaapiSurface *
+gst_vaapi_surface_new(
+    GstVaapiDisplay    *display,
+    GstVaapiChromaType  chroma_type,
+    guint               width,
+    guint               height
+);
+
+GstVaapiSurface *
+gst_vaapi_surface_new_with_format(
+    GstVaapiDisplay    *display,
+    GstVideoFormat      format,
+    guint               width,
+    guint               height
+);
+
+GstVaapiID
+gst_vaapi_surface_get_id(GstVaapiSurface *surface);
+
+GstVaapiChromaType
+gst_vaapi_surface_get_chroma_type(GstVaapiSurface *surface);
+
+GstVideoFormat
+gst_vaapi_surface_get_format(GstVaapiSurface *surface);
+
+guint
+gst_vaapi_surface_get_width(GstVaapiSurface *surface);
+
+guint
+gst_vaapi_surface_get_height(GstVaapiSurface *surface);
+
+void
+gst_vaapi_surface_get_size(
+    GstVaapiSurface *surface,
+    guint           *pwidth,
+    guint           *pheight
+);
+
+GstVaapiImage *
+gst_vaapi_surface_derive_image(GstVaapiSurface *surface);
+
+gboolean
+gst_vaapi_surface_get_image(GstVaapiSurface *surface, GstVaapiImage *image);
+
+gboolean
+gst_vaapi_surface_put_image(GstVaapiSurface *surface, GstVaapiImage *image);
+
+gboolean
+gst_vaapi_surface_associate_subpicture(
+    GstVaapiSurface         *surface,
+    GstVaapiSubpicture      *subpicture,
+    const GstVaapiRectangle *src_rect,
+    const GstVaapiRectangle *dst_rect
+);
+
+gboolean
+gst_vaapi_surface_deassociate_subpicture(
+    GstVaapiSurface         *surface,
+    GstVaapiSubpicture      *subpicture
+);
+
+gboolean
+gst_vaapi_surface_sync(GstVaapiSurface *surface);
+
+gboolean
+gst_vaapi_surface_query_status(
+    GstVaapiSurface       *surface,
+    GstVaapiSurfaceStatus *pstatus
+);
+
+gboolean
+gst_vaapi_surface_set_subpictures_from_composition(
+    GstVaapiSurface            *surface,
+    GstVideoOverlayComposition *composition,
+    gboolean                    propagate_context
+);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_SURFACE_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapisurface_priv.h b/lib/libv4l-hva/gst/vaapi/gstvaapisurface_priv.h
new file mode 100644
index 0000000..468226d
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapisurface_priv.h
@@ -0,0 +1,118 @@
+/*
+ *  gstvaapisurface_priv.h - VA surface abstraction (private data)
+ *
+ *  Copyright (C) 2011-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_SURFACE_PRIV_H
+#define GST_VAAPI_SURFACE_PRIV_H
+
+#include <gst/vaapi/gstvaapicontext.h>
+#include <gst/vaapi/gstvaapisurface.h>
+#include "gstvaapiobject_priv.h"
+
+typedef struct _GstVaapiSurfaceClass            GstVaapiSurfaceClass;
+
+/**
+ * GstVaapiSurface:
+ *
+ * A VA surface wrapper.
+ */
+struct _GstVaapiSurface {
+    /*< private >*/
+    GstVaapiObject      parent_instance;
+
+    GstVideoFormat      format;
+    guint               width;
+    guint               height;
+    GstVaapiChromaType  chroma_type;
+    GPtrArray          *subpictures;
+    GstVaapiContext    *parent_context;
+};
+
+/**
+ * GstVaapiSurfaceClass:
+ *
+ * A VA surface wrapper class.
+ */
+struct _GstVaapiSurfaceClass {
+    /*< private >*/
+    GstVaapiObjectClass parent_class;
+};
+
+/**
+ * GST_VAAPI_SURFACE_SURFACE_CHROMA_TYPE:
+ * @surface: a #GstVaapiSurface
+ *
+ * Macro that evaluates to the @surface chroma type.
+ *
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_SURFACE_CHROMA_TYPE
+#define GST_VAAPI_SURFACE_CHROMA_TYPE(surface) \
+    GST_VAAPI_SURFACE(surface)->chroma_type
+
+/**
+ * GST_VAAPI_SURFACE_SURFACE_FORMAT:
+ * @surface: a #GstVaapiSurface
+ *
+ * Macro that evaluates to the @surface format.
+ *
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_SURFACE_FORMAT
+#define GST_VAAPI_SURFACE_FORMAT(surface) \
+    GST_VAAPI_SURFACE(surface)->format
+
+/**
+ * GST_VAAPI_SURFACE_SURFACE_WIDTH:
+ * @surface: a #GstVaapiSurface
+ *
+ * Macro that evaluates to the @surface width in pixels.
+ *
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_SURFACE_WIDTH
+#define GST_VAAPI_SURFACE_WIDTH(surface) \
+    GST_VAAPI_SURFACE(surface)->width
+
+/**
+ * GST_VAAPI_SURFACE_SURFACE_HEIGHT:
+ * @surface: a #GstVaapiSurface
+ *
+ * Macro that evaluates to the @surface height in pixels.
+ *
+ * This is an internal macro that does not do any run-time type check.
+ */
+#undef  GST_VAAPI_SURFACE_HEIGHT
+#define GST_VAAPI_SURFACE_HEIGHT(surface) \
+    GST_VAAPI_SURFACE(surface)->height
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_surface_set_parent_context(
+    GstVaapiSurface *surface,
+    GstVaapiContext *context
+);
+
+G_GNUC_INTERNAL
+GstVaapiContext *
+gst_vaapi_surface_get_parent_context(GstVaapiSurface *surface);
+
+#endif /* GST_VAAPI_SURFACE_PRIV_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapisurfacepool.h b/lib/libv4l-hva/gst/vaapi/gstvaapisurfacepool.h
new file mode 100644
index 0000000..bc7a3ed
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapisurfacepool.h
@@ -0,0 +1,44 @@
+/*
+ *  gstvaapisurfacepool.h - Gst VA surface pool
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2012-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_SURFACE_POOL_H
+#define GST_VAAPI_SURFACE_POOL_H
+
+#include <gst/vaapi/gstvaapisurface.h>
+#include <gst/vaapi/gstvaapivideopool.h>
+#include <gst/vaapi/video-format.h>
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_SURFACE_POOL(obj) \
+    ((GstVaapiSurfacePool *)(obj))
+
+typedef struct _GstVaapiSurfacePool             GstVaapiSurfacePool;
+
+GstVaapiVideoPool *
+gst_vaapi_surface_pool_new(GstVaapiDisplay *display, const GstVideoInfo *vip);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_SURFACE_POOL_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapisurfaceproxy.h b/lib/libv4l-hva/gst/vaapi/gstvaapisurfaceproxy.h
new file mode 100644
index 0000000..b36be5d
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapisurfaceproxy.h
@@ -0,0 +1,150 @@
+/*
+ *  gstvaapisurfaceproxy.h - VA surface proxy
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_SURFACE_PROXY_H
+#define GST_VAAPI_SURFACE_PROXY_H
+
+#include <gst/vaapi/gstvaapisurface.h>
+#include <gst/vaapi/gstvaapisurfacepool.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GstVaapiSurfaceProxyFlags:
+ * @GST_VAAPI_SURFACE_PROXY_FLAG_INTERLACED: interlaced frame
+ * @GST_VAAPI_SURFACE_PROXY_FLAG_TFF: top-field-first
+ * @GST_VAAPI_SURFACE_PROXY_FLAG_RFF: repeat-field-first
+ * @GST_VAAPI_SURFACE_PROXY_FLAG_ONEFIELD: only one field is available
+ * @GST_VAAPI_SURFACE_PROXY_FLAG_FFB: first frame in bundle, e.g. the first
+ *   view component of a MultiView Coded (MVC) frame
+ * @GST_VAAPI_SURFACE_PROXY_FLAG_LAST: first flag that can be used by subclasses
+ *
+ * Flags for #GstVaapiDecoderFrame.
+ */
+typedef enum {
+    GST_VAAPI_SURFACE_PROXY_FLAG_INTERLACED     = (1 << 0),
+    GST_VAAPI_SURFACE_PROXY_FLAG_TFF            = (1 << 1),
+    GST_VAAPI_SURFACE_PROXY_FLAG_RFF            = (1 << 2),
+    GST_VAAPI_SURFACE_PROXY_FLAG_ONEFIELD       = (1 << 3),
+    GST_VAAPI_SURFACE_PROXY_FLAG_FFB            = (1 << 4),
+    GST_VAAPI_SURFACE_PROXY_FLAG_LAST           = (1 << 8)
+} GstVaapiSurfaceProxyFlags;
+
+/**
+ * GST_VAAPI_SURFACE_PROXY_SURFACE:
+ * @proxy: a #GstVaapiSurfaceProxy
+ *
+ * Macro that evaluates to the #GstVaapiSurface of @proxy.
+ */
+#define GST_VAAPI_SURFACE_PROXY_SURFACE(proxy) \
+    gst_vaapi_surface_proxy_get_surface(proxy)
+
+/**
+ * GST_VAAPI_SURFACE_PROXY_SURFACE_ID:
+ * @proxy: a #GstVaapiSurfaceProxy
+ *
+ * Macro that evaluates to the VA surface ID of the underlying @proxy
+ * surface.
+ */
+#define GST_VAAPI_SURFACE_PROXY_SURFACE_ID(proxy) \
+    gst_vaapi_surface_proxy_get_surface_id(proxy)
+
+/**
+ * GST_VAAPI_SURFACE_PROXY_VIEW_ID:
+ * @proxy: a #GstVaapiSurfaceProxy
+ *
+ * Macro that evaluates to the decoded view ID of the underlying @proxy
+ * surface.
+ */
+#define GST_VAAPI_SURFACE_PROXY_VIEW_ID(proxy) \
+    gst_vaapi_surface_proxy_get_view_id(proxy)
+
+/**
+ * GST_VAAPI_SURFACE_PROXY_TIMESTAMP:
+ * @proxy: a #GstVaapiSurfaceProxy
+ *
+ * Macro that evaluates to the presentation timestamp of the
+ * underlying @proxy surface.
+ */
+#define GST_VAAPI_SURFACE_PROXY_TIMESTAMP(proxy) \
+    gst_vaapi_surface_proxy_get_timestamp(proxy)
+
+/**
+ * GST_VAAPI_SURFACE_PROXY_DURATION:
+ * @proxy: a #GstVaapiSurfaceProxy
+ *
+ * Macro that evaluates to the presentation duration of the
+ * underlying @proxy surface.
+ */
+#define GST_VAAPI_SURFACE_PROXY_DURATION(proxy) \
+    gst_vaapi_surface_proxy_get_duration(proxy)
+
+GstVaapiSurfaceProxy *
+gst_vaapi_surface_proxy_new_from_pool(GstVaapiSurfacePool *pool);
+
+GstVaapiSurfaceProxy *
+gst_vaapi_surface_proxy_copy(GstVaapiSurfaceProxy *proxy);
+
+GstVaapiSurfaceProxy *
+gst_vaapi_surface_proxy_ref(GstVaapiSurfaceProxy *proxy);
+
+void
+gst_vaapi_surface_proxy_unref(GstVaapiSurfaceProxy *proxy);
+
+void
+gst_vaapi_surface_proxy_replace(GstVaapiSurfaceProxy **old_proxy_ptr,
+    GstVaapiSurfaceProxy *new_proxy);
+
+guint
+gst_vaapi_surface_proxy_get_flags(GstVaapiSurfaceProxy *proxy);
+
+GstVaapiSurface *
+gst_vaapi_surface_proxy_get_surface(GstVaapiSurfaceProxy *proxy);
+
+GstVaapiID
+gst_vaapi_surface_proxy_get_surface_id(GstVaapiSurfaceProxy *proxy);
+
+guintptr
+gst_vaapi_surface_proxy_get_view_id(GstVaapiSurfaceProxy *proxy);
+
+GstClockTime
+gst_vaapi_surface_proxy_get_timestamp(GstVaapiSurfaceProxy *proxy);
+
+GstClockTime
+gst_vaapi_surface_proxy_get_duration(GstVaapiSurfaceProxy *proxy);
+
+void
+gst_vaapi_surface_proxy_set_destroy_notify(GstVaapiSurfaceProxy *proxy,
+    GDestroyNotify destroy_func, gpointer user_data);
+
+const GstVaapiRectangle *
+gst_vaapi_surface_proxy_get_crop_rect(GstVaapiSurfaceProxy *proxy);
+
+void
+gst_vaapi_surface_proxy_set_crop_rect(GstVaapiSurfaceProxy *proxy,
+    const GstVaapiRectangle *crop_rect);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_SURFACE_PROXY_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapitexture.h b/lib/libv4l-hva/gst/vaapi/gstvaapitexture.h
new file mode 100644
index 0000000..3259574
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapitexture.h
@@ -0,0 +1,96 @@
+/*
+ *  gstvaapitexture.h - VA texture abstraction
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2012-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_TEXTURE_H
+#define GST_VAAPI_TEXTURE_H
+
+#include <GL/gl.h>
+#include <gst/vaapi/gstvaapitypes.h>
+#include <gst/vaapi/gstvaapiobject.h>
+#include <gst/vaapi/gstvaapidisplay.h>
+#include <gst/vaapi/gstvaapisurface.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GstVaapiTexture                 GstVaapiTexture;
+
+GstVaapiTexture *
+gst_vaapi_texture_new(
+    GstVaapiDisplay *display,
+    GLenum           target,
+    GLenum           format,
+    guint            width,
+    guint            height
+);
+
+GstVaapiTexture *
+gst_vaapi_texture_new_with_texture(
+    GstVaapiDisplay *display,
+    GLuint           texture_id,
+    GLenum           target,
+    GLenum           format
+);
+
+GstVaapiTexture *
+gst_vaapi_texture_ref(GstVaapiTexture *texture);
+
+void
+gst_vaapi_texture_unref(GstVaapiTexture *texture);
+
+void
+gst_vaapi_texture_replace(GstVaapiTexture **old_texture_ptr,
+    GstVaapiTexture *new_texture);
+
+GLuint
+gst_vaapi_texture_get_id(GstVaapiTexture *texture);
+
+GLenum
+gst_vaapi_texture_get_target(GstVaapiTexture *texture);
+
+GLenum
+gst_vaapi_texture_get_format(GstVaapiTexture *texture);
+
+guint
+gst_vaapi_texture_get_width(GstVaapiTexture *texture);
+
+guint
+gst_vaapi_texture_get_height(GstVaapiTexture *texture);
+
+void
+gst_vaapi_texture_get_size(
+    GstVaapiTexture *texture,
+    guint           *pwidth,
+    guint           *pheight
+);
+
+gboolean
+gst_vaapi_texture_put_surface(
+    GstVaapiTexture *texture,
+    GstVaapiSurface *surface,
+    guint            flags
+);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_TEXTURE_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapitypes.h b/lib/libv4l-hva/gst/vaapi/gstvaapitypes.h
new file mode 100644
index 0000000..ccdddbf
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapitypes.h
@@ -0,0 +1,153 @@
+/*
+ *  gstvaapitypes.h - Basic types
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2012-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_TYPES_H
+#define GST_VAAPI_TYPES_H
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GstVaapiID:
+ *
+ * An integer large enough to hold a generic VA id or a pointer
+ * wherever necessary.
+ */
+typedef gsize GstVaapiID;
+
+/**
+ * GST_VAAPI_ID_FORMAT:
+ *
+ * Can be used together with #GST_VAAPI_ID_ARGS to properly output an
+ * integer value in a printf()-style text message.
+ * <informalexample>
+ * <programlisting>
+ * printf("id: %" GST_VAAPI_ID_FORMAT "\n", GST_VAAPI_ID_ARGS(id));
+ * </programlisting>
+ * </informalexample>
+ */
+#define GST_VAAPI_ID_FORMAT "p"
+
+/**
+ * GST_VAAPI_ID_ARGS:
+ * @id: a #GstVaapiID
+ *
+ * Can be used together with #GST_VAAPI_ID_FORMAT to properly output
+ * an integer value in a printf()-style text message.
+ */
+#define GST_VAAPI_ID_ARGS(id) GSIZE_TO_POINTER(id)
+
+/**
+ * GstVaapiPoint:
+ * @x: X coordinate
+ * @y: Y coordinate
+ *
+ * A location within a surface.
+ */
+typedef struct _GstVaapiPoint GstVaapiPoint;
+struct _GstVaapiPoint {
+    guint32 x;
+    guint32 y;
+};
+
+/**
+ * GstVaapiRectangle:
+ * @x: X coordinate
+ * @y: Y coordinate
+ * @width: region width
+ * @height: region height
+ *
+ * A rectangle region within a surface.
+ */
+typedef struct _GstVaapiRectangle GstVaapiRectangle;
+struct _GstVaapiRectangle {
+    guint32 x;
+    guint32 y;
+    guint32 width;
+    guint32 height;
+};
+
+/**
+ * GstVaapiRenderMode:
+ * @GST_VAAPI_RENDER_MODE_OVERLAY: in this mode, the VA display
+ *   backend renders surfaces with an overlay engine. This means that
+ *   the surface that is currently displayed shall not be re-used
+ *   right away for decoding. i.e. it needs to be retained further,
+ *   until the next surface is to be displayed.
+ * @GST_VAAPI_RENDER_MODE_TEXTURE: in this modem the VA display
+ *   backend renders surfaces with a textured blit (GPU/3D engine).
+ *   This means that the surface is copied to some intermediate
+ *   backing store, or back buffer of a frame buffer, and is free to
+ *   be re-used right away for decoding.
+ */
+typedef enum {
+    GST_VAAPI_RENDER_MODE_OVERLAY = 1,
+    GST_VAAPI_RENDER_MODE_TEXTURE
+} GstVaapiRenderMode;
+
+/**
+ * GstVaapiRotation:
+ * @GST_VAAPI_ROTATION_0: the VA display is not rotated.
+ * @GST_VAAPI_ROTATION_90: the VA display is rotated by 90°, clockwise.
+ * @GST_VAAPI_ROTATION_180: the VA display is rotated by 180°, clockwise.
+ * @GST_VAAPI_ROTATION_270: the VA display is rotated by 270°, clockwise.
+ */
+typedef enum {
+    GST_VAAPI_ROTATION_0   = 0,
+    GST_VAAPI_ROTATION_90  = 90,
+    GST_VAAPI_ROTATION_180 = 180,
+    GST_VAAPI_ROTATION_270 = 270,
+} GstVaapiRotation;
+
+/**
+ * GstVaapiRateControl:
+ * @GST_VAAPI_RATECONTROL_NONE: No rate control performed by the
+ *   underlying driver
+ * @GST_VAAPI_RATECONTROL_CQP: Constant QP
+ * @GST_VAAPI_RATECONTROL_CBR: Constant bitrate
+ * @GST_VAAPI_RATECONTROL_VCM: Video conference mode
+ * @GST_VAAPI_RATECONTROL_VBR: Variable bitrate
+ * @GST_VAAPI_RATECONTROL_VBR_CONSTRAINED: Variable bitrate with peak
+ *   rate higher than average bitrate
+ *
+ * The set of allowed rate control values for #GstVaapiRateControl.
+ * Note: this is only valid for encoders.
+ */
+typedef enum {
+    GST_VAAPI_RATECONTROL_NONE = 0,
+    GST_VAAPI_RATECONTROL_CQP,
+    GST_VAAPI_RATECONTROL_CBR,
+    GST_VAAPI_RATECONTROL_VCM,
+    GST_VAAPI_RATECONTROL_VBR,
+    GST_VAAPI_RATECONTROL_VBR_CONSTRAINED,
+} GstVaapiRateControl;
+
+/* Define a mask for GstVaapiRateControl */
+#define GST_VAAPI_RATECONTROL_MASK(RC) \
+    (1 << G_PASTE(GST_VAAPI_RATECONTROL_,RC))
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_TYPES_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiutils.h b/lib/libv4l-hva/gst/vaapi/gstvaapiutils.h
new file mode 100644
index 0000000..e5f8503
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiutils.h
@@ -0,0 +1,135 @@
+/*
+ *  gstvaapiutils.h - VA-API utilities
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_UTILS_H
+#define GST_VAAPI_UTILS_H
+
+#include "config.h"
+#include "libgstvaapi_priv_check.h"
+#include <glib.h>
+#include <va/va.h>
+
+/** Check VA status for success or print out an error */
+G_GNUC_INTERNAL
+gboolean
+vaapi_check_status (VAStatus status, const gchar *msg);
+
+/** Maps VA buffer */
+G_GNUC_INTERNAL
+gpointer
+vaapi_map_buffer (VADisplay dpy, VABufferID buf_id);
+
+/** Unmaps VA buffer */
+G_GNUC_INTERNAL
+void
+vaapi_unmap_buffer (VADisplay dpy, VABufferID buf_id, void **pbuf);
+
+/** Creates and maps VA buffer */
+G_GNUC_INTERNAL
+gboolean
+vaapi_create_buffer (VADisplay dpy, VAContextID ctx, int type, guint size,
+    gconstpointer data, VABufferID * buf_id, gpointer * mapped_data);
+
+/** Destroy VA buffer */
+G_GNUC_INTERNAL
+void
+vaapi_destroy_buffer (VADisplay dpy, VABufferID * buf_id);
+
+/** Return a string representation of a VAProfile */
+G_GNUC_INTERNAL
+const gchar *
+string_of_VAProfile (VAProfile profile);
+
+/** Return a string representation of a VAEntrypoint */
+G_GNUC_INTERNAL
+const gchar *
+string_of_VAEntrypoint (VAEntrypoint entrypoint);
+
+/* Return a string representation of a VADisplayAttributeType */
+G_GNUC_INTERNAL
+const gchar *
+string_of_VADisplayAttributeType (VADisplayAttribType attribute_type);
+
+/* Return a string representation of a VA chroma format */
+G_GNUC_INTERNAL
+const gchar *
+string_of_va_chroma_format (guint chroma_format);
+
+G_GNUC_INTERNAL
+const gchar *
+string_of_VARateControl (guint rate_control);
+
+G_GNUC_INTERNAL
+guint
+from_GstVaapiChromaType (guint chroma_type);
+
+G_GNUC_INTERNAL
+guint
+from_GstVaapiSubpictureFlags (guint flags);
+
+G_GNUC_INTERNAL
+guint
+to_GstVaapiSubpictureFlags (guint va_flags);
+
+G_GNUC_INTERNAL
+guint
+from_GstVideoOverlayFormatFlags (guint ovl_flags);
+
+G_GNUC_INTERNAL
+guint
+to_GstVideoOverlayFormatFlags (guint flags);
+
+G_GNUC_INTERNAL
+guint
+from_GstVaapiSurfaceRenderFlags (guint flags);
+
+G_GNUC_INTERNAL
+guint
+to_GstVaapiSurfaceStatus (guint va_flags);
+
+G_GNUC_INTERNAL
+guint
+from_GstVaapiRotation (guint value);
+
+G_GNUC_INTERNAL
+guint
+to_GstVaapiRotation (guint value);
+
+G_GNUC_INTERNAL
+guint
+from_GstVaapiRateControl (guint value);
+
+G_GNUC_INTERNAL
+guint
+to_GstVaapiRateControl (guint value);
+
+G_GNUC_INTERNAL
+guint
+from_GstVaapiDeinterlaceMethod (guint value);
+
+G_GNUC_INTERNAL
+guint
+from_GstVaapiDeinterlaceFlags (guint flags);
+
+#endif /* GST_VAAPI_UTILS_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264.c b/lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264.c
new file mode 100644
index 0000000..f8d95fe
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264.c
@@ -0,0 +1,399 @@
+/*
+ *  gstvaapiutils_h264.c - H.264 related utilities
+ *
+ *  Copyright (C) 2011-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#include "sysdeps.h"
+#include <gst/codecparsers/gsth264parser.h>
+#include "gstvaapiutils_h264_priv.h"
+
+struct map
+{
+  guint value;
+  const gchar *name;
+};
+
+/* Profile string map */
+static const struct map gst_vaapi_h264_profile_map[] = {
+/* *INDENT-OFF* */
+  { GST_VAAPI_PROFILE_H264_CONSTRAINED_BASELINE, "constrained-baseline" },
+  { GST_VAAPI_PROFILE_H264_BASELINE,             "baseline"             },
+  { GST_VAAPI_PROFILE_H264_MAIN,                 "main"                 },
+  { GST_VAAPI_PROFILE_H264_EXTENDED,             "extended"             },
+  { GST_VAAPI_PROFILE_H264_HIGH,                 "high"                 },
+  { GST_VAAPI_PROFILE_H264_HIGH10,               "high-10"              },
+  { GST_VAAPI_PROFILE_H264_HIGH_422,             "high-4:2:2"           },
+  { GST_VAAPI_PROFILE_H264_HIGH_444,             "high-4:4:4"           },
+  { GST_VAAPI_PROFILE_H264_SCALABLE_BASELINE,    "scalable-baseline"    },
+  { GST_VAAPI_PROFILE_H264_SCALABLE_HIGH,        "scalable-high"        },
+  { GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH,       "multiview-high"       },
+  { GST_VAAPI_PROFILE_H264_STEREO_HIGH,          "stereo-high"          },
+  { 0, NULL }
+/* *INDENT-ON* */
+};
+
+/* Level string map */
+static const struct map gst_vaapi_h264_level_map[] = {
+/* *INDENT-OFF* */
+  { GST_VAAPI_LEVEL_H264_L1,    "1"     },
+  { GST_VAAPI_LEVEL_H264_L1b,   "1b"    },
+  { GST_VAAPI_LEVEL_H264_L1_1,  "1.1"   },
+  { GST_VAAPI_LEVEL_H264_L1_2,  "1.2"   },
+  { GST_VAAPI_LEVEL_H264_L1_3,  "1.3"   },
+  { GST_VAAPI_LEVEL_H264_L2,    "2"     },
+  { GST_VAAPI_LEVEL_H264_L2_1,  "2.1"   },
+  { GST_VAAPI_LEVEL_H264_L2_2,  "2.2"   },
+  { GST_VAAPI_LEVEL_H264_L3,    "3"     },
+  { GST_VAAPI_LEVEL_H264_L3_1,  "3.1"   },
+  { GST_VAAPI_LEVEL_H264_L3_2,  "3.2"   },
+  { GST_VAAPI_LEVEL_H264_L4,    "4"     },
+  { GST_VAAPI_LEVEL_H264_L4_1,  "4.1"   },
+  { GST_VAAPI_LEVEL_H264_L4_2,  "4.2"   },
+  { GST_VAAPI_LEVEL_H264_L5,    "5"     },
+  { GST_VAAPI_LEVEL_H264_L5_1,  "5.1"   },
+  { GST_VAAPI_LEVEL_H264_L5_2,  "5.2"   },
+  { 0, NULL }
+/* *INDENT-ON* */
+};
+
+/* Table A-1 - Level limits */
+/* *INDENT-OFF* */
+static const GstVaapiH264LevelLimits gst_vaapi_h264_level_limits[] = {
+  /* level                     idc   MaxMBPS   MaxFS MaxDpbMbs  MaxBR MaxCPB */
+  { GST_VAAPI_LEVEL_H264_L1,    10,     1485,     99,    396,     64,    175 },
+  { GST_VAAPI_LEVEL_H264_L1b,   11,     1485,     99,    396,    128,    350 },
+  { GST_VAAPI_LEVEL_H264_L1_1,  11,     3000,    396,    900,    192,    500 },
+  { GST_VAAPI_LEVEL_H264_L1_2,  12,     6000,    396,   2376,    384,   1000 },
+  { GST_VAAPI_LEVEL_H264_L1_3,  13,    11880,    396,   2376,    768,   2000 },
+  { GST_VAAPI_LEVEL_H264_L2,    20,    11880,    396,   2376,   2000,   2000 },
+  { GST_VAAPI_LEVEL_H264_L2_1,  21,    19800,    792,   4752,   4000,   4000 },
+  { GST_VAAPI_LEVEL_H264_L2_2,  22,    20250,   1620,   8100,   4000,   4000 },
+  { GST_VAAPI_LEVEL_H264_L3,    30,    40500,   1620,   8100,  10000,  10000 },
+  { GST_VAAPI_LEVEL_H264_L3_1,  31,   108000,   3600,  18000,  14000,  14000 },
+  { GST_VAAPI_LEVEL_H264_L3_2,  32,   216000,   5120,  20480,  20000,  20000 },
+  { GST_VAAPI_LEVEL_H264_L4,    40,   245760,   8192,  32768,  20000,  25000 },
+  { GST_VAAPI_LEVEL_H264_L4_1,  41,   245760,   8192,  32768,  50000,  62500 },
+  { GST_VAAPI_LEVEL_H264_L4_2,  42,   522240,   8704,  34816,  50000,  62500 },
+  { GST_VAAPI_LEVEL_H264_L5,    50,   589824,  22080, 110400, 135000, 135000 },
+  { GST_VAAPI_LEVEL_H264_L5_1,  51,   983040,  36864, 184320, 240000, 240000 },
+  { GST_VAAPI_LEVEL_H264_L5_2,  52,  2073600,  36864, 184320, 240000, 240000 },
+  { 0, }
+};
+/* *INDENT-ON* */
+
+/* Lookup value in map */
+static const struct map *
+map_lookup_value (const struct map *m, guint value)
+{
+  g_return_val_if_fail (m != NULL, NULL);
+
+  for (; m->name != NULL; m++) {
+    if (m->value == value)
+      return m;
+  }
+  return NULL;
+}
+
+/* Lookup name in map */
+static const struct map *
+map_lookup_name (const struct map *m, const gchar * name)
+{
+  g_return_val_if_fail (m != NULL, NULL);
+
+  if (!name)
+    return NULL;
+
+  for (; m->name != NULL; m++) {
+    if (strcmp (m->name, name) == 0)
+      return m;
+  }
+  return NULL;
+}
+
+/** Returns a relative score for the supplied GstVaapiProfile */
+guint
+gst_vaapi_utils_h264_get_profile_score (GstVaapiProfile profile)
+{
+  const struct map *const m =
+      map_lookup_value (gst_vaapi_h264_profile_map, profile);
+
+  return m ? 1 + (m - gst_vaapi_h264_profile_map) : 0;
+}
+
+/** Returns GstVaapiProfile from H.264 profile_idc value */
+GstVaapiProfile
+gst_vaapi_utils_h264_get_profile (guint8 profile_idc)
+{
+  GstVaapiProfile profile;
+
+  switch (profile_idc) {
+    case GST_H264_PROFILE_BASELINE:
+      profile = GST_VAAPI_PROFILE_H264_BASELINE;
+      break;
+    case GST_H264_PROFILE_MAIN:
+      profile = GST_VAAPI_PROFILE_H264_MAIN;
+      break;
+    case GST_H264_PROFILE_EXTENDED:
+      profile = GST_VAAPI_PROFILE_H264_EXTENDED;
+      break;
+    case GST_H264_PROFILE_HIGH:
+      profile = GST_VAAPI_PROFILE_H264_HIGH;
+      break;
+    case GST_H264_PROFILE_HIGH10:
+      profile = GST_VAAPI_PROFILE_H264_HIGH10;
+      break;
+    case GST_H264_PROFILE_HIGH_422:
+      profile = GST_VAAPI_PROFILE_H264_HIGH_422;
+      break;
+    case GST_H264_PROFILE_HIGH_444:
+      profile = GST_VAAPI_PROFILE_H264_HIGH_444;
+      break;
+    case GST_H264_PROFILE_SCALABLE_BASELINE:
+      profile = GST_VAAPI_PROFILE_H264_SCALABLE_BASELINE;
+      break;
+    case GST_H264_PROFILE_SCALABLE_HIGH:
+      profile = GST_VAAPI_PROFILE_H264_SCALABLE_HIGH;
+      break;
+    case GST_H264_PROFILE_MULTIVIEW_HIGH:
+      profile = GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH;
+      break;
+    case GST_H264_PROFILE_STEREO_HIGH:
+      profile = GST_VAAPI_PROFILE_H264_STEREO_HIGH;
+      break;
+    default:
+      g_debug ("unsupported profile_idc value");
+      profile = GST_VAAPI_PROFILE_UNKNOWN;
+      break;
+  }
+  return profile;
+}
+
+/** Returns H.264 profile_idc value from GstVaapiProfile */
+guint8
+gst_vaapi_utils_h264_get_profile_idc (GstVaapiProfile profile)
+{
+  guint8 profile_idc;
+
+  switch (profile) {
+    case GST_VAAPI_PROFILE_H264_BASELINE:
+    case GST_VAAPI_PROFILE_H264_CONSTRAINED_BASELINE:
+      profile_idc = GST_H264_PROFILE_BASELINE;
+      break;
+    case GST_VAAPI_PROFILE_H264_MAIN:
+      profile_idc = GST_H264_PROFILE_MAIN;
+      break;
+    case GST_VAAPI_PROFILE_H264_EXTENDED:
+      profile_idc = GST_H264_PROFILE_EXTENDED;
+      break;
+    case GST_VAAPI_PROFILE_H264_HIGH:
+      profile_idc = GST_H264_PROFILE_HIGH;
+      break;
+    case GST_VAAPI_PROFILE_H264_HIGH10:
+      profile_idc = GST_H264_PROFILE_HIGH10;
+      break;
+    case GST_VAAPI_PROFILE_H264_HIGH_422:
+      profile_idc = GST_H264_PROFILE_HIGH_422;
+      break;
+    case GST_VAAPI_PROFILE_H264_HIGH_444:
+      profile_idc = GST_H264_PROFILE_HIGH_444;
+      break;
+    case GST_VAAPI_PROFILE_H264_SCALABLE_BASELINE:
+      profile_idc = GST_H264_PROFILE_SCALABLE_BASELINE;
+      break;
+    case GST_VAAPI_PROFILE_H264_SCALABLE_HIGH:
+      profile_idc = GST_H264_PROFILE_SCALABLE_HIGH;
+      break;
+    case GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH:
+      profile_idc = GST_H264_PROFILE_MULTIVIEW_HIGH;
+      break;
+    case GST_VAAPI_PROFILE_H264_STEREO_HIGH:
+      profile_idc = GST_H264_PROFILE_STEREO_HIGH;
+      break;
+    default:
+      g_debug ("unsupported GstVaapiProfile value");
+      profile_idc = 0;
+      break;
+  }
+  return profile_idc;
+}
+
+/** Returns GstVaapiProfile from a string representation */
+GstVaapiProfile
+gst_vaapi_utils_h264_get_profile_from_string (const gchar * str)
+{
+  const struct map *const m = map_lookup_name (gst_vaapi_h264_profile_map, str);
+
+  return m ? (GstVaapiProfile) m->value : GST_VAAPI_PROFILE_UNKNOWN;
+}
+
+/** Returns a string representation for the supplied H.264 profile */
+const gchar *
+gst_vaapi_utils_h264_get_profile_string (GstVaapiProfile profile)
+{
+  const struct map *const m =
+      map_lookup_value (gst_vaapi_h264_profile_map, profile);
+
+  return m ? m->name : NULL;
+}
+
+/** Returns GstVaapiLevelH264 from H.264 level_idc value */
+GstVaapiLevelH264
+gst_vaapi_utils_h264_get_level (guint8 level_idc)
+{
+  const GstVaapiH264LevelLimits *llp;
+
+  // Prefer Level 1.1 over level 1b
+  if (G_UNLIKELY (level_idc == 11))
+    return GST_VAAPI_LEVEL_H264_L1_1;
+
+  for (llp = gst_vaapi_h264_level_limits; llp->level != 0; llp++) {
+    if (llp->level_idc == level_idc)
+      return llp->level;
+  }
+  g_debug ("unsupported level_idc value");
+  return (GstVaapiLevelH264) 0;
+}
+
+/** Returns H.264 level_idc value from GstVaapiLevelH264 */
+guint8
+gst_vaapi_utils_h264_get_level_idc (GstVaapiLevelH264 level)
+{
+  const GstVaapiH264LevelLimits *const llp =
+      gst_vaapi_utils_h264_get_level_limits (level);
+
+  return llp ? llp->level_idc : 0;
+}
+
+/** Returns GstVaapiLevelH264 from a string representation */
+GstVaapiLevelH264
+gst_vaapi_utils_h264_get_level_from_string (const gchar * str)
+{
+  gint v, level_idc = 0;
+
+  if (!str || !str[0])
+    goto not_found;
+
+  v = g_ascii_digit_value (str[0]);
+  if (v < 0)
+    goto not_found;
+  level_idc = v * 10;
+
+  switch (str[1]) {
+    case '\0':
+      break;
+    case '.':
+      v = g_ascii_digit_value (str[2]);
+      if (v < 0 || str[3] != '\0')
+        goto not_found;
+      level_idc += v;
+      break;
+    case 'b':
+      if (level_idc == 10 && str[2] == '\0')
+        return GST_VAAPI_LEVEL_H264_L1b;
+      // fall-trough
+    default:
+      goto not_found;
+  }
+  return gst_vaapi_utils_h264_get_level (level_idc);
+
+not_found:
+  return (GstVaapiLevelH264) 0;
+}
+
+/** Returns a string representation for the supplied H.264 level */
+const gchar *
+gst_vaapi_utils_h264_get_level_string (GstVaapiLevelH264 level)
+{
+  if (level < GST_VAAPI_LEVEL_H264_L1 || level > GST_VAAPI_LEVEL_H264_L5_2)
+    return NULL;
+  return gst_vaapi_h264_level_map[level - GST_VAAPI_LEVEL_H264_L1].name;
+}
+
+/** Returns level limits as specified in Table A-1 of the H.264 standard */
+const GstVaapiH264LevelLimits *
+gst_vaapi_utils_h264_get_level_limits (GstVaapiLevelH264 level)
+{
+  if (level < GST_VAAPI_LEVEL_H264_L1 || level > GST_VAAPI_LEVEL_H264_L5_2)
+    return NULL;
+  return &gst_vaapi_h264_level_limits[level - GST_VAAPI_LEVEL_H264_L1];
+}
+
+/** Returns the Table A-1 specification */
+const GstVaapiH264LevelLimits *
+gst_vaapi_utils_h264_get_level_limits_table (guint * out_length_ptr)
+{
+  if (out_length_ptr)
+    *out_length_ptr = G_N_ELEMENTS (gst_vaapi_h264_level_limits) - 1;
+  return gst_vaapi_h264_level_limits;
+}
+
+/** Returns GstVaapiChromaType from H.264 chroma_format_idc value */
+GstVaapiChromaType
+gst_vaapi_utils_h264_get_chroma_type (guint chroma_format_idc)
+{
+  GstVaapiChromaType chroma_type;
+
+  switch (chroma_format_idc) {
+    case 0:
+      chroma_type = GST_VAAPI_CHROMA_TYPE_YUV400;
+      break;
+    case 1:
+      chroma_type = GST_VAAPI_CHROMA_TYPE_YUV420;
+      break;
+    case 2:
+      chroma_type = GST_VAAPI_CHROMA_TYPE_YUV422;
+      break;
+    case 3:
+      chroma_type = GST_VAAPI_CHROMA_TYPE_YUV444;
+      break;
+    default:
+      g_debug ("unsupported chroma_format_idc value");
+      chroma_type = (GstVaapiChromaType) 0;
+      break;
+  }
+  return chroma_type;
+}
+
+/** Returns H.264 chroma_format_idc value from GstVaapiChromaType */
+guint
+gst_vaapi_utils_h264_get_chroma_format_idc (GstVaapiChromaType chroma_type)
+{
+  guint chroma_format_idc;
+
+  switch (chroma_type) {
+    case GST_VAAPI_CHROMA_TYPE_YUV400:
+      chroma_format_idc = 0;
+      break;
+    case GST_VAAPI_CHROMA_TYPE_YUV420:
+      chroma_format_idc = 1;
+      break;
+    case GST_VAAPI_CHROMA_TYPE_YUV422:
+      chroma_format_idc = 2;
+      break;
+    case GST_VAAPI_CHROMA_TYPE_YUV444:
+      chroma_format_idc = 3;
+      break;
+    default:
+      g_debug ("unsupported GstVaapiChromaType value");
+      chroma_format_idc = 1;
+      break;
+  }
+  return chroma_format_idc;
+}
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264.h b/lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264.h
new file mode 100644
index 0000000..16db4ea
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264.h
@@ -0,0 +1,95 @@
+/*
+ *  gstvaapiutils_h264.h - H.264 related utilities
+ *
+ *  Copyright (C) 2011-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_UTILS_H264_H
+#define GST_VAAPI_UTILS_H264_H
+
+#include <va/va.h>
+#include <gst/vaapi/gstvaapiprofile.h>
+#include <gst/vaapi/gstvaapisurface.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GstVaapiLevelH264:
+ * @GST_VAAPI_LEVEL_H264_L1: H.264 level 1.
+ * @GST_VAAPI_LEVEL_H264_L1_1: H.264 level 1.1.
+ * @GST_VAAPI_LEVEL_H264_L1_2: H.264 level 1.2.
+ * @GST_VAAPI_LEVEL_H264_L1_3: H.264 level 1.3.
+ * @GST_VAAPI_LEVEL_H264_L2: H.264 level 2.
+ * @GST_VAAPI_LEVEL_H264_L2_1: H.264 level 2.1.
+ * @GST_VAAPI_LEVEL_H264_L2_2: H.264 level 2.2.
+ * @GST_VAAPI_LEVEL_H264_L3: H.264 level 3.
+ * @GST_VAAPI_LEVEL_H264_L3_1: H.264 level 3.1.
+ * @GST_VAAPI_LEVEL_H264_L3_2: H.264 level 3.2.
+ * @GST_VAAPI_LEVEL_H264_L4: H.264 level 4.
+ * @GST_VAAPI_LEVEL_H264_L4_1: H.264 level 4.1.
+ * @GST_VAAPI_LEVEL_H264_L4_2: H.264 level 4.2.
+ * @GST_VAAPI_LEVEL_H264_L5: H.264 level 5.
+ * @GST_VAAPI_LEVEL_H264_L5_1: H.264 level 5.1.
+ * @GST_VAAPI_LEVEL_H264_L5_2: H.264 level 5.2.
+ *
+ * The set of all levels for #GstVaapiLevelH264.
+ */
+typedef enum {
+  GST_VAAPI_LEVEL_H264_L1 = 1,
+  GST_VAAPI_LEVEL_H264_L1b,
+  GST_VAAPI_LEVEL_H264_L1_1,
+  GST_VAAPI_LEVEL_H264_L1_2,
+  GST_VAAPI_LEVEL_H264_L1_3,
+  GST_VAAPI_LEVEL_H264_L2,
+  GST_VAAPI_LEVEL_H264_L2_1,
+  GST_VAAPI_LEVEL_H264_L2_2,
+  GST_VAAPI_LEVEL_H264_L3,
+  GST_VAAPI_LEVEL_H264_L3_1,
+  GST_VAAPI_LEVEL_H264_L3_2,
+  GST_VAAPI_LEVEL_H264_L4,
+  GST_VAAPI_LEVEL_H264_L4_1,
+  GST_VAAPI_LEVEL_H264_L4_2,
+  GST_VAAPI_LEVEL_H264_L5,
+  GST_VAAPI_LEVEL_H264_L5_1,
+  GST_VAAPI_LEVEL_H264_L5_2,
+} GstVaapiLevelH264;
+
+/* Returns a relative score for the supplied GstVaapiProfile */
+guint
+gst_vaapi_utils_h264_get_profile_score (GstVaapiProfile profile);
+
+/* Returns GstVaapiProfile from a string representation */
+GstVaapiProfile
+gst_vaapi_utils_h264_get_profile_from_string (const gchar * str);
+
+/* Returns a string representation for the supplied H.264 profile */
+const gchar *
+gst_vaapi_utils_h264_get_profile_string (GstVaapiProfile profile);
+
+/* Returns GstVaapiLevelH264 from a string representation */
+GstVaapiLevelH264
+gst_vaapi_utils_h264_get_level_from_string (const gchar * str);
+
+/* Returns a string representation for the supplied H.264 level */
+const gchar *
+gst_vaapi_utils_h264_get_level_string (GstVaapiLevelH264 level);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_UTILS_H264_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264_priv.h b/lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264_priv.h
new file mode 100644
index 0000000..0ca552a
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiutils_h264_priv.h
@@ -0,0 +1,95 @@
+/*
+ *  gstvaapiutils_h264_priv.h - H.264 related utilities
+ *
+ *  Copyright (C) 2011-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_UTILS_H264_PRIV_H
+#define GST_VAAPI_UTILS_H264_PRIV_H
+
+#include "gstvaapiutils_h264.h"
+#include "libgstvaapi_priv_check.h"
+
+G_BEGIN_DECLS
+
+/**
+ * GstVaapiH264LevelLimits:
+ * @level: the #GstVaapiLevelH264
+ * @level_idc: the H.264 level_idc value
+ * @MaxMBPS: the maximum macroblock processing rate (MB/sec)
+ * @MaxFS: the maximum frame size (MBs)
+ * @MaxDpbMbs: the maxium decoded picture buffer size (MBs)
+ * @MaxBR: the maximum video bit rate (kbps)
+ * @MaxCPB: the maximum CPB size (kbits)
+ *
+ * The data structure that describes the limits of an H.264 level.
+ */
+typedef struct {
+  GstVaapiLevelH264 level;
+  guint8 level_idc;
+  guint32 MaxMBPS;
+  guint32 MaxFS;
+  guint32 MaxDpbMbs;
+  guint32 MaxBR;
+  guint32 MaxCPB;
+} GstVaapiH264LevelLimits;
+
+/* Returns GstVaapiProfile from H.264 profile_idc value */
+G_GNUC_INTERNAL
+GstVaapiProfile
+gst_vaapi_utils_h264_get_profile (guint8 profile_idc);
+
+/* Returns H.264 profile_idc value from GstVaapiProfile */
+G_GNUC_INTERNAL
+guint8
+gst_vaapi_utils_h264_get_profile_idc (GstVaapiProfile profile);
+
+/* Returns GstVaapiLevelH264 from H.264 level_idc value */
+G_GNUC_INTERNAL
+GstVaapiLevelH264
+gst_vaapi_utils_h264_get_level (guint8 level_idc);
+
+/* Returns H.264 level_idc value from GstVaapiLevelH264 */
+G_GNUC_INTERNAL
+guint8
+gst_vaapi_utils_h264_get_level_idc (GstVaapiLevelH264 level);
+
+/* Returns level limits as specified in Table A-1 of the H.264 standard */
+G_GNUC_INTERNAL
+const GstVaapiH264LevelLimits *
+gst_vaapi_utils_h264_get_level_limits (GstVaapiLevelH264 level);
+
+/* Returns the Table A-1 specification */
+G_GNUC_INTERNAL
+const GstVaapiH264LevelLimits *
+gst_vaapi_utils_h264_get_level_limits_table (guint * out_length_ptr);
+
+/* Returns GstVaapiChromaType from H.264 chroma_format_idc value */
+G_GNUC_INTERNAL
+GstVaapiChromaType
+gst_vaapi_utils_h264_get_chroma_type (guint chroma_format_idc);
+
+/* Returns H.264 chroma_format_idc value from GstVaapiChromaType */
+G_GNUC_INTERNAL
+guint
+gst_vaapi_utils_h264_get_chroma_format_idc (GstVaapiChromaType chroma_type);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_UTILS_H264_PRIV_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapivalue.h b/lib/libv4l-hva/gst/vaapi/gstvaapivalue.h
new file mode 100644
index 0000000..e7d445a
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapivalue.h
@@ -0,0 +1,162 @@
+/*
+ *  gstvaapivalue.h - GValue implementations specific to VA-API
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2012-2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_VALUE_H
+#define GST_VAAPI_VALUE_H
+
+#include <glib-object.h>
+#include <gst/vaapi/gstvaapitypes.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GST_VAAPI_TYPE_POINT:
+ *
+ * A #GstVaapiPoint type that represents a 2D point coordinates.
+ *
+ * Return value: the GType of #GstVaapiPoint
+ */
+#define GST_VAAPI_TYPE_POINT gst_vaapi_point_get_type()
+
+/**
+ * GST_VAAPI_TYPE_RECTANGLE:
+ *
+ * A #GstVaapiRectangle type that represents a 2D rectangle position
+ * and size.
+ *
+ * Return value: the GType of #GstVaapiRectangle
+ */
+#define GST_VAAPI_TYPE_RECTANGLE gst_vaapi_rectangle_get_type()
+
+/**
+ * GST_VAAPI_TYPE_RENDER_MODE:
+ *
+ * A #GstVaapiRenderMode type that represents the VA display backend
+ * rendering mode: overlay (2D engine) or textured-blit (3D engine).
+ *
+ * Return value: the #GType of GstVaapiRenderMode
+ */
+#define GST_VAAPI_TYPE_RENDER_MODE gst_vaapi_render_mode_get_type()
+
+/**
+ * GST_VAAPI_TYPE_ROTATION:
+ *
+ * A type that represents the VA display rotation.
+ *
+ * Return value: the #GType of GstVaapiRotation
+ */
+#define GST_VAAPI_TYPE_ROTATION gst_vaapi_rotation_get_type()
+
+/**
+ * GST_VAAPI_TYPE_RATE_CONTROL:
+ *
+ * A type that represents the VA rate control.
+ *
+ * Return value: the #GType of GstVaapiRateControl
+ */
+#define GST_VAAPI_TYPE_RATE_CONTROL gst_vaapi_rate_control_get_type()
+
+GType
+gst_vaapi_point_get_type(void) G_GNUC_CONST;
+
+GType
+gst_vaapi_rectangle_get_type(void) G_GNUC_CONST;
+
+GType
+gst_vaapi_render_mode_get_type(void) G_GNUC_CONST;
+
+GType
+gst_vaapi_rotation_get_type(void) G_GNUC_CONST;
+
+GType
+gst_vaapi_rate_control_get_type(void) G_GNUC_CONST;
+
+/**
+ * GST_VAAPI_POPCOUNT32:
+ * @x: the value from which to compute population count
+ *
+ * Computes the number of bits set in the supplied 32-bit value @x.
+ *
+ * Return value: the number of bits set in @x
+ */
+#define GST_VAAPI_POPCOUNT32(x) \
+    GST_VAAPI_POPCOUNT32_0(x)
+#define GST_VAAPI_POPCOUNT32_0(x) \
+    GST_VAAPI_POPCOUNT32_1((x) - (((x) >> 1) & 0x55555555))
+#define GST_VAAPI_POPCOUNT32_1(x) \
+    GST_VAAPI_POPCOUNT32_2(((x) & 0x33333333) + (((x) >> 2) & 0x33333333))
+#define GST_VAAPI_POPCOUNT32_2(x) \
+    GST_VAAPI_POPCOUNT32_3((x) + ((x) >> 4))
+#define GST_VAAPI_POPCOUNT32_3(x) \
+    GST_VAAPI_POPCOUNT32_4((x) & 0x0f0f0f0f)
+#define GST_VAAPI_POPCOUNT32_4(x) \
+    (((x) * 0x01010101) >> 24)
+
+/* --- GstVaapiEnumSubset --- */
+
+/**
+ * GstVaapiEnumSubset:
+ * @name: name of the enum subset
+ * @parent_type: parent enum type
+ * @type: registered #GType
+ * @type_info: #GTypeInfo used to build the @type
+ * @values: pointer to a static array of #GEnumValue elements
+ * @num_values: number of elements in the @values array, including the
+ *   terminator
+ *
+ * Structure that holds the required information to build a GEnum
+ * subset from the supplied @parent_type, i.e. a subset of its values.
+ */
+typedef struct {
+    GType parent_type;
+    GType type;
+    GTypeInfo type_info;
+    const gchar *type_name;
+    GEnumValue *values;
+    guint num_values;
+} GstVaapiEnumSubset;
+
+G_GNUC_INTERNAL
+GType
+gst_vaapi_type_define_enum_subset_from_mask(GstVaapiEnumSubset *subset,
+    guint32 mask);
+
+#define GST_VAAPI_TYPE_DEFINE_ENUM_SUBSET_FROM_MASK(NAME, name, TYPE, MASK) \
+static GType                                                            \
+G_PASTE(name,_get_type)(void)                                           \
+{                                                                       \
+    static GEnumValue enum_values[GST_VAAPI_POPCOUNT32(MASK) + 1];      \
+    static GstVaapiEnumSubset subset = {                                \
+        .type_name = G_STRINGIFY(NAME),                                 \
+        .values = enum_values,                                          \
+        .num_values = G_N_ELEMENTS(enum_values),                        \
+    };                                                                  \
+    if (g_once_init_enter(&subset.parent_type))                         \
+        g_once_init_leave(&subset.parent_type, TYPE);                   \
+    return gst_vaapi_type_define_enum_subset_from_mask(&subset, MASK);  \
+}
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_VALUE_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapivideopool.h b/lib/libv4l-hva/gst/vaapi/gstvaapivideopool.h
new file mode 100644
index 0000000..84210ed
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapivideopool.h
@@ -0,0 +1,94 @@
+/*
+ *  gstvaapivideopool.h - Video object pool abstraction
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2012-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_VIDEO_POOL_H
+#define GST_VAAPI_VIDEO_POOL_H
+
+#include <glib.h>
+#include <gst/vaapi/gstvaapidisplay.h>
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_VIDEO_POOL(obj) \
+    ((GstVaapiVideoPool *)(obj))
+
+typedef struct _GstVaapiVideoPool               GstVaapiVideoPool;
+
+/**
+ * GstVaapiVideoPoolObjectType:
+ * @GST_VAAPI_VIDEO_POOL_OBJECT_TYPE_IMAGE: #GstVaapiImage objects.
+ * @GST_VAAPI_VIDEO_POOL_OBJECT_TYPE_SURFACE: #GstVaapiSurface objects.
+ * @GST_VAAPI_VIDEO_POOL_OBJECT_TYPE_CODED_BUFFER: #GstVaapiCodedBuffer objects.
+ *
+ * The set of all supported #GstVaapiVideoPool object types.
+ */
+typedef enum {
+    GST_VAAPI_VIDEO_POOL_OBJECT_TYPE_IMAGE = 1,
+    GST_VAAPI_VIDEO_POOL_OBJECT_TYPE_SURFACE,
+    GST_VAAPI_VIDEO_POOL_OBJECT_TYPE_CODED_BUFFER
+} GstVaapiVideoPoolObjectType;
+
+GstVaapiVideoPool *
+gst_vaapi_video_pool_ref(GstVaapiVideoPool *pool);
+
+void
+gst_vaapi_video_pool_unref(GstVaapiVideoPool *pool);
+
+void
+gst_vaapi_video_pool_replace(GstVaapiVideoPool **old_pool_ptr,
+    GstVaapiVideoPool *new_pool);
+
+GstVaapiDisplay *
+gst_vaapi_video_pool_get_display(GstVaapiVideoPool *pool);
+
+GstVaapiVideoPoolObjectType
+gst_vaapi_video_pool_get_object_type(GstVaapiVideoPool *pool);
+
+gpointer
+gst_vaapi_video_pool_get_object(GstVaapiVideoPool *pool);
+
+void
+gst_vaapi_video_pool_put_object(GstVaapiVideoPool *pool, gpointer object);
+
+gboolean
+gst_vaapi_video_pool_add_object(GstVaapiVideoPool *pool, gpointer object);
+
+gboolean
+gst_vaapi_video_pool_add_objects(GstVaapiVideoPool *pool, GPtrArray *objects);
+
+guint
+gst_vaapi_video_pool_get_size(GstVaapiVideoPool *pool);
+
+gboolean
+gst_vaapi_video_pool_reserve(GstVaapiVideoPool *pool, guint n);
+
+guint
+gst_vaapi_video_pool_get_capacity(GstVaapiVideoPool *pool);
+
+void
+gst_vaapi_video_pool_set_capacity(GstVaapiVideoPool *pool, guint capacity);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_VIDEO_POOL_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapivideopool_priv.h b/lib/libv4l-hva/gst/vaapi/gstvaapivideopool_priv.h
new file mode 100644
index 0000000..1411952
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapivideopool_priv.h
@@ -0,0 +1,107 @@
+/*
+ *  gstvaapivideopool_priv.h - Video object pool abstraction (private defs)
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2012-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_VIDEO_POOL_PRIV_H
+#define GST_VAAPI_VIDEO_POOL_PRIV_H
+
+#include "gstvaapiminiobject.h"
+
+G_BEGIN_DECLS
+
+#define GST_VAAPI_VIDEO_POOL_CLASS(klass) \
+    ((GstVaapiVideoPoolClass *)(klass))
+
+#define GST_VAAPI_IS_VIDEO_POOL_CLASS(klass) \
+    ((klass) != NULL)
+
+typedef struct _GstVaapiVideoPoolClass          GstVaapiVideoPoolClass;
+
+/**
+ * GstVaapiVideoPool:
+ *
+ * A pool of lazily allocated video objects. e.g. surfaces, images.
+ */
+struct _GstVaapiVideoPool {
+    /*< private >*/
+    GstVaapiMiniObject  parent_instance;
+
+    guint               object_type;
+    GstVaapiDisplay    *display;
+    GQueue              free_objects;
+    GList              *used_objects;
+    guint               used_count;
+    guint               capacity;
+    GMutex              mutex;
+};
+
+/**
+ * GstVaapiVideoPoolClass:
+ * @alloc_object: virtual function for allocating a video pool object
+ *
+ * A pool base class used to hold video objects. e.g. surfaces, images.
+ */
+struct _GstVaapiVideoPoolClass {
+    /*< private >*/
+    GstVaapiMiniObjectClass parent_class;
+
+    /*< public >*/
+    gpointer (*alloc_object)(GstVaapiVideoPool *pool);
+};
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_video_pool_init(GstVaapiVideoPool *pool, GstVaapiDisplay *display,
+    GstVaapiVideoPoolObjectType object_type);
+
+G_GNUC_INTERNAL
+void
+gst_vaapi_video_pool_finalize(GstVaapiVideoPool *pool);
+
+/* Internal aliases */
+
+#define gst_vaapi_video_pool_ref_internal(pool) \
+    ((gpointer)gst_vaapi_mini_object_ref(GST_VAAPI_MINI_OBJECT(pool)))
+
+#define gst_vaapi_video_pool_unref_internal(pool) \
+    gst_vaapi_mini_object_unref(GST_VAAPI_MINI_OBJECT(pool))
+
+#define gst_vaapi_video_pool_replace_internal(old_pool_ptr, new_pool) \
+    gst_vaapi_mini_object_replace((GstVaapiMiniObject **)(old_pool_ptr), \
+        GST_VAAPI_MINI_OBJECT(new_pool))
+
+#undef  gst_vaapi_video_pool_ref
+#define gst_vaapi_video_pool_ref(pool) \
+    gst_vaapi_video_pool_ref_internal((pool))
+
+#undef  gst_vaapi_video_pool_unref
+#define gst_vaapi_video_pool_unref(pool) \
+    gst_vaapi_video_pool_unref_internal((pool))
+
+#undef  gst_vaapi_video_pool_replace
+#define gst_vaapi_video_pool_replace(old_pool_ptr, new_pool) \
+    gst_vaapi_video_pool_replace_internal((old_pool_ptr), (new_pool))
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_VIDEO_POOL_PRIV_H */
diff --git a/lib/libv4l-hva/gst/vaapi/gstvaapiworkarounds.h b/lib/libv4l-hva/gst/vaapi/gstvaapiworkarounds.h
new file mode 100644
index 0000000..967ef3e
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/gstvaapiworkarounds.h
@@ -0,0 +1,42 @@
+/*
+ *  gstvaapiworkaround.h - GStreamer/VA workarounds
+ *
+ *  Copyright (C) 2011-2012 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_WORKAROUNDS_H
+#define GST_VAAPI_WORKAROUNDS_H
+
+G_BEGIN_DECLS
+
+/*
+ * Workaround to expose H.263 Baseline decode profile for drivers that
+ * support MPEG-4:2 Simple profile decoding.
+ */
+#define WORKAROUND_H263_BASELINE_DECODE_PROFILE (1)
+
+/*
+ * Workaround for qtdemux that does not report profiles for
+ * video/x-h263. Assume H.263 Baseline profile in this case.
+ */
+#define WORKAROUND_QTDEMUX_NO_H263_PROFILES (1)
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_WORKAROUNDS_H */
diff --git a/lib/libv4l-hva/gst/vaapi/libgstvaapi_priv_check.h b/lib/libv4l-hva/gst/vaapi/libgstvaapi_priv_check.h
new file mode 100644
index 0000000..e7cf0e1
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/libgstvaapi_priv_check.h
@@ -0,0 +1,25 @@
+/*
+ *  libgstvaapi_priv_check.h - Check file is included from within libgstvaapi
+ *
+ *  Copyright (C) 2014 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef IN_LIBGSTVAAPI
+# error "This file is only meant to be included from within libgstvaapi"
+#endif
diff --git a/lib/libv4l-hva/gst/vaapi/video-format.h b/lib/libv4l-hva/gst/vaapi/video-format.h
new file mode 100644
index 0000000..acc333d
--- /dev/null
+++ b/lib/libv4l-hva/gst/vaapi/video-format.h
@@ -0,0 +1,61 @@
+/*
+ *  video-format.h - Video format helpers for VA-API
+ *
+ *  Copyright (C) 2010-2011 Splitted-Desktop Systems
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@splitted-desktop.com>
+ *  Copyright (C) 2011-2013 Intel Corporation
+ *    Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public License
+ *  as published by the Free Software Foundation; either version 2.1
+ *  of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301 USA
+ */
+
+#ifndef GST_VAAPI_VIDEO_FORMAT_H
+#define GST_VAAPI_VIDEO_FORMAT_H
+
+#include <gst/video/video.h>
+
+G_BEGIN_DECLS
+
+GstVideoFormat
+gst_vaapi_video_format_from_string (const gchar * str);
+
+const gchar *
+gst_vaapi_video_format_to_string (GstVideoFormat format);
+
+gboolean
+gst_vaapi_video_format_is_rgb (GstVideoFormat format);
+
+gboolean
+gst_vaapi_video_format_is_yuv (GstVideoFormat format);
+
+GstVideoFormat
+gst_vaapi_video_format_from_va_fourcc (guint32 fourcc);
+
+GstVideoFormat
+gst_vaapi_video_format_from_va_format (const VAImageFormat * va_format);
+
+const VAImageFormat *
+gst_vaapi_video_format_to_va_format (GstVideoFormat format);
+
+guint
+gst_vaapi_video_format_get_chroma_type (GstVideoFormat format);
+
+guint
+gst_vaapi_video_format_get_score (GstVideoFormat format);
+
+G_END_DECLS
+
+#endif /* GST_VAAPI_VIDEO_FORMAT_H */
diff --git a/lib/libv4l-hva/libv4l-hva-h264.c b/lib/libv4l-hva/libv4l-hva-h264.c
new file mode 100644
index 0000000..dc1bb05
--- /dev/null
+++ b/lib/libv4l-hva/libv4l-hva-h264.c
@@ -0,0 +1,404 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics SA
+ *
+ * License Terms:  GNU General Public License (GPL) version 2
+ *
+ * Author: <yannick.fertre@st.com> for STMicroelectronics.
+ */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "libv4l-hva.h"
+#include <gst/vaapi/gstvaapiencoder_objects.h>
+#include <gst/vaapi/gstvaapiencoder_h264.h>
+
+/**
+ * struct hva_h264_meta
+ *
+ * @level: video level
+ * @profile: video profile
+ * @entropy_mode: entropy mode (CABAC or CAVLC)
+ * @bitrate_mode: bitrate mode (constant bitrate or variable bitrate)
+ * @gop_size: groupe of picture size
+ * @bitrate: bitrate
+ * @cpb_size: coded picture buffer size
+ * @intra_refresh: activate intra refresh
+ * @dct8x8: enable transform mode 8x8
+ * @qpmin: defines the minimum quantizer
+ * @qpmax: defines the maximum quantizer
+ * @format: stream format
+ * @sar_idc: sample aspect ratio index
+ * @sar_enable: enable sample aspect ratio
+ * @sei_fp_type: frame packing arrangement type
+ * @sei_fp_enable: enable frame packing arrangement
+ */
+struct hva_h264_meta {
+	/* controls */
+	enum v4l2_mpeg_video_h264_level level;
+	enum v4l2_mpeg_video_h264_profile profile;
+	enum v4l2_mpeg_video_h264_entropy_mode entropy_mode;
+	enum v4l2_mpeg_video_bitrate_mode bitrate_mode;
+	uint32_t gop_size;
+	uint32_t bitrate;
+	uint32_t cpb_size;
+	int intra_refresh;
+	int dct8x8;
+	uint32_t qpmin;
+	uint32_t qpmax;
+	/* stream format  */
+	struct v4l2_format format;
+	enum v4l2_mpeg_video_h264_vui_sar_idc sar_idc;
+	int sar_enable;
+	/* Supplemental Enhancement Information */
+	enum v4l2_mpeg_video_h264_sei_fp_arrangement_type sei_fp_type;
+	int sei_fp_enable;
+};
+
+static const GstVaapiProfile
+to_vaapi_profile (enum v4l2_mpeg_video_h264_profile profile)
+{
+	switch (profile) {
+		case V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:
+			return GST_VAAPI_PROFILE_H264_BASELINE;
+		case V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:
+			return GST_VAAPI_PROFILE_H264_CONSTRAINED_BASELINE;
+		case V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:
+			return GST_VAAPI_PROFILE_H264_MAIN;
+		case V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED:
+			return GST_VAAPI_PROFILE_H264_EXTENDED;
+		case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:
+			return GST_VAAPI_PROFILE_H264_HIGH;
+		case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10:
+			return GST_VAAPI_PROFILE_H264_HIGH10;
+		case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422:
+			return GST_VAAPI_PROFILE_H264_HIGH_422;
+		case V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH:
+			return GST_VAAPI_PROFILE_H264_MULTIVIEW_HIGH;
+		case V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH:
+			return GST_VAAPI_PROFILE_H264_STEREO_HIGH;
+		default:
+			GST_WARNING ("Invalid V4L2 profile (%d), default to baseline"
+				" profile", profile);
+			return GST_VAAPI_PROFILE_H264_BASELINE;
+	}
+}
+
+static int
+to_vaapi_level_idc (enum v4l2_mpeg_video_h264_level level)
+{
+	switch (level) {
+		case V4L2_MPEG_VIDEO_H264_LEVEL_1_0: return 10;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_1B:  return  9;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_1_1: return 11;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_1_2: return 12;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_1_3: return 13;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_2_0: return 20;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_2_1: return 21;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_2_2: return 22;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_3_0: return 30;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_3_1: return 31;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_3_2: return 32;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_4_0: return 40;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_4_1: return 41;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_4_2: return 42;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_5_0: return 50;
+		case V4L2_MPEG_VIDEO_H264_LEVEL_5_1: return 51;
+		default:
+			GST_WARNING ("Invalid V4L2 level (%d), default to level 4.0", level);
+			return 40;
+		}
+}
+
+static int
+hva_h264_set_ctrl(void *priv, struct v4l2_ext_controls *ctrls)
+{
+	struct hva_h264_meta *meta;
+	int i = 0;
+
+	V4L2_LOG("> %s count %d\n", __func__, ctrls->count);
+
+	if (priv)
+		meta = (struct hva_h264_meta *)priv;
+	else
+		return -EINVAL;
+
+	for (i=0; i < ctrls->count; i++) {
+		switch (ctrls->controls[i].id) {
+		case V4L2_CID_MPEG_VIDEO_H264_LEVEL:
+			meta->level = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_LEVEL %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_H264_PROFILE:
+			meta->profile = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_PROFILE %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
+			meta->gop_size = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_GOP_SIZE %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:
+			meta->bitrate_mode = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_BITRATE_MODE %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:
+			meta->entropy_mode = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_BITRATE:
+			meta->bitrate = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_BITRATE %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE:
+			meta->cpb_size = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB:
+			meta->intra_refresh = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:
+			meta->dct8x8 = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_H264_MIN_QP:
+			meta->qpmin = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_MIN_QP %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_H264_MAX_QP:
+			meta->qpmax = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_MAX_QP %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:
+			meta->sar_idc = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:
+			meta->sar_enable = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING:
+			meta->sei_fp_enable = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING %d\n",
+				ctrls->controls[i].value);
+		break;
+		case V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE:
+			meta->sei_fp_type = ctrls->controls[i].value;
+			V4L2_LOG("V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE %d\n",
+				ctrls->controls[i].value);
+		break;
+		default:
+			V4L2_LOG_ERR("VIDIOC_S_EXT_CTRLS(): Unsupported control id %d\n",
+				ctrls->controls[i].id);
+		break;
+		}
+	}
+
+	V4L2_LOG("< %s\n", __func__);
+
+	return 0;
+}
+
+static int
+hva_h264_get_sps_pps(void *priv, uint8_t **data, size_t *size,
+	struct v4l2_format *format, struct v4l2_ext_controls *ctrls)
+{
+	struct hva_h264_meta *meta;
+	uint8_t *buf = *data;
+	size_t sps_size = 0;
+	size_t pps_size = 0;
+	int ret = 0;
+
+	GstVaapiEncoderH264 enc_h264;
+	GstVaapiEncPicture picture;
+	GstVaapiEncSequence sequence;
+	VAEncSequenceParameterBufferH264 seq_param;
+	VAEncPictureParameterBufferH264 pic_param;
+	GstMapInfo sps_info, pps_info;
+
+	V4L2_LOG("> %s \n", __func__);
+
+	if (priv)
+		meta = (struct hva_h264_meta *)priv;
+	else
+		return -EINVAL;
+
+	memset (&enc_h264, 0, sizeof(enc_h264));
+	memset (&picture, 0, sizeof(picture));
+	memset (&sequence, 0, sizeof(sequence));
+	memset (&seq_param, 0, sizeof(VAEncSequenceParameterBufferH264));
+	memset (&pic_param, 0, sizeof(VAEncPictureParameterBufferH264));
+
+	enc_h264.profile = to_vaapi_profile (meta->profile);
+	enc_h264.init_qp = 28;
+	enc_h264.min_qp = meta->qpmin;
+	enc_h264.num_slices = 1;
+	enc_h264.cpb_length = meta->cpb_size * 1000 / 8;
+	enc_h264.num_views = 1;
+	enc_h264.cpb_length_bits = meta->cpb_size * 1000;
+	enc_h264.bitrate_bits = meta->bitrate * 1000;
+	enc_h264.use_dct8x8 = meta->dct8x8;
+
+	if (meta->entropy_mode == V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC)
+		enc_h264.use_cabac = TRUE;
+	else
+		enc_h264.use_cabac = FALSE;
+
+	seq_param.level_idc = to_vaapi_level_idc (meta->level);
+
+	seq_param.intra_period = meta->gop_size;
+	seq_param.intra_idr_period = meta->gop_size;
+	seq_param.ip_period = meta->gop_size;
+	seq_param.bits_per_second = meta->bitrate*1000;
+	seq_param.max_num_ref_frames = 1;
+	seq_param.picture_width_in_mbs = (format->fmt.pix.width + 15) / 16;
+	seq_param.picture_height_in_mbs = (format->fmt.pix.height + 15) / 16;
+
+	/* set cropping parameters */
+	seq_param.frame_crop_right_offset = ((seq_param.picture_width_in_mbs * 16)
+										- format->fmt.pix.width) >> 1;
+	seq_param.frame_crop_bottom_offset = ((seq_param.picture_height_in_mbs * 16)
+										- format->fmt.pix.height) >> 1;
+
+	if (seq_param.frame_crop_right_offset || seq_param.frame_crop_bottom_offset)
+		seq_param.frame_cropping_flag = 1;
+
+	seq_param.vui_fields.bits.log2_max_mv_length_horizontal = 10;
+	seq_param.vui_fields.bits.log2_max_mv_length_vertical = 10;
+	seq_param.vui_parameters_present_flag = 1;
+	seq_param.vui_fields.bits.bitstream_restriction_flag = 1;
+	seq_param.seq_fields.bits.chroma_format_idc = 1;
+	seq_param.seq_fields.bits.pic_order_cnt_type = 2;
+	seq_param.seq_fields.bits.frame_mbs_only_flag = 1;
+	seq_param.vui_fields.bits.aspect_ratio_info_present_flag = meta->sar_enable;
+
+	if(meta->sar_enable)
+		seq_param.aspect_ratio_idc = meta->sar_idc;
+
+	sequence.param = &seq_param;
+
+	pic_param.chroma_qp_index_offset = 2;
+	pic_param.pic_init_qp = 26;
+
+	if (meta->entropy_mode == V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC)
+		pic_param.pic_fields.bits.entropy_coding_mode_flag = 1;
+	else
+		pic_param.pic_fields.bits.entropy_coding_mode_flag = 0;
+
+	pic_param.pic_fields.bits.transform_8x8_mode_flag = meta->dct8x8;
+	pic_param.pic_fields.bits.deblocking_filter_control_present_flag = 1;
+	pic_param.second_chroma_qp_index_offset = 2;
+
+	picture.param = &pic_param;
+
+	if (add_packed_sequence_header (&enc_h264, &picture, &sequence) == FALSE) {
+		V4L2_LOG_ERR ("%s: couldn't add sequence header", __func__);
+		return -EINVAL;
+	} else
+		V4L2_LOG("%s sequence header created\n", __func__);
+
+	if (add_packed_picture_header (&enc_h264, &picture) == FALSE) {
+		V4L2_LOG_ERR ("%s: couldn't add picture header", __func__);
+		return -EINVAL;
+	} else
+		V4L2_LOG("%s picture header created\n", __func__);
+
+	gst_buffer_map (enc_h264.sps_data, &sps_info, GST_MAP_READ);
+	gst_buffer_map (enc_h264.pps_data, &pps_info, GST_MAP_READ);
+
+	sps_size = 4 + sps_info.size;
+	pps_size = 4 + pps_info.size;
+
+	/* SPS */
+	V4L2_LOG("sps size %d\n", sps_info.size + 4);
+	memcpy (buf + 4, sps_info.data, sps_info.size);
+
+	/* start code */
+	buf[0] = 0x00; buf[1] = 0x00; buf[2] = 0x00;buf[3] = 0x01;
+
+	buf += sps_size;
+
+	/* PPS */
+	V4L2_LOG("pps size %d\n", pps_info.size + 4);
+	memcpy (buf + 4 , pps_info.data, pps_info.size);
+
+	/* start code */
+	buf[0] = 0x00; buf[1] = 0x00; buf[2] = 0x00;buf[3] = 0x01;
+
+	gst_buffer_unmap (enc_h264.sps_data, &sps_info);
+	gst_buffer_unmap (enc_h264.pps_data, &pps_info);
+
+	/* release the buffers (copy/paste from
+	 * gst_vaapi_encoder_h264_finalize)
+	 */
+	gst_buffer_replace (&enc_h264.sps_data, NULL);
+	gst_buffer_replace (&enc_h264.subset_sps_data, NULL);
+	gst_buffer_replace (&enc_h264.pps_data, NULL);
+
+	*size = sps_size + pps_size;
+
+	V4L2_LOG("< %s data %p size %d\n", __func__, *data, *size);
+
+	return ret;
+}
+
+static int hva_h264_start(void **priv)
+{
+	struct hva_h264_meta *meta;
+	int ret = 0;
+
+	V4L2_LOG("> %s\n", __func__);
+
+	/* allocate a private context for the H264 header encoder */
+	meta = calloc(1, sizeof(struct hva_h264_meta));
+	if (!meta) {
+		V4L2_LOG_ERR
+		    ("%s: couldn't allocate memory for the H264"
+		     " private context\n", __func__);
+		ret = -EINVAL;
+	}
+
+	/* initialize meta data */
+	meta->level = V4L2_MPEG_VIDEO_H264_LEVEL_4_2;
+	meta->profile = V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE;
+
+	*priv = meta;
+
+	V4L2_LOG("< %s: priv %p\n", __func__, *priv);
+	return ret;
+}
+
+static void hva_h264_stop(void *priv)
+{
+	V4L2_LOG("> %s\n", __func__);
+
+	if (priv) {
+		free(priv);
+	}
+
+	V4L2_LOG("< %s\n", __func__);
+}
+
+const struct hva_metadata h264meta = {
+	.name = "h264",
+	.stream_format = V4L2_PIX_FMT_H264,
+	.start = hva_h264_start,
+	.stop = hva_h264_stop,
+	.get_sps_pps = hva_h264_get_sps_pps,
+	.set_ctrl = hva_h264_set_ctrl,
+};
+
diff --git a/lib/libv4l-hva/libv4l-hva.c b/lib/libv4l-hva/libv4l-hva.c
new file mode 100644
index 0000000..11a8610
--- /dev/null
+++ b/lib/libv4l-hva/libv4l-hva.c
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics SA
+ *
+ * License Terms:  GNU General Public License (GPL) version 2
+ *
+ * Author: <yannick.fertre@st.com> for STMicroelectronics.
+ */
+
+#include <config.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <sys/mman.h>
+
+#include "libv4l-plugin.h"
+#include "libv4l-hva.h"
+
+#if HAVE_VISIBILITY
+#define PLUGIN_PUBLIC __attribute__ ((visibility("default")))
+#else
+#define PLUGIN_PUBLIC
+#endif
+
+#define type_to_str(type) ((type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ? "OUTPUT" : \
+	((type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ? "CAPTURE" : "?"))
+
+#define buf_to_str(buf) ((buf == VIDIOC_QBUF) ? "QBUF" : "DQBUF")
+
+/* registering of metadata builders */
+extern const struct hva_metadata h264meta;
+
+const struct hva_metadata *hva_meta[] = {
+	&h264meta
+};
+
+static int hva_querybuf(struct hva_plugin *hva, int fd, unsigned long int cmd,
+	struct v4l2_buffer *buffer)
+{
+	int ret;
+
+	V4L2_LOG("> %s: query buffer index %d on %s (%u) data stream\n", __func__,
+		buffer->index, type_to_str(buffer->type), buffer->type);
+
+	ret = SYS_IOCTL(fd, cmd, buffer);
+	if (ret) {
+		V4L2_LOG_ERR("%s: failed to query buffer on %s data stream\n",
+			__func__, type_to_str(buffer->type));
+		return ret;
+	}
+
+	if (buffer->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		/* mmap stream buffers (aka access unit buffer) */
+		struct hva_buffer *au = &hva->aus[buffer->index];
+
+		au->size = buffer->length;
+		au->vaddr = (void *)SYS_MMAP(NULL, buffer->length,
+			PROT_READ | PROT_WRITE, MAP_SHARED, fd, buffer->m.offset);
+
+		if (!au->vaddr) {
+			V4L2_LOG_ERR("%s: failed to mmap buffer %d on %s data stream\n",
+				__func__, buffer->index, type_to_str(buffer->type));
+			return -EINVAL;
+		}
+	}
+
+	V4L2_LOG("< %s\n", __func__);
+	return ret;
+}
+
+static int hva_dqbuf(struct hva_plugin *hva, int fd, unsigned long int cmd,
+					 struct v4l2_buffer *buffer)
+{
+	int ret;
+
+	V4L2_LOG("> %s\n", __func__);
+
+	ret = SYS_IOCTL(fd, cmd, buffer);
+	if (ret) {
+		V4L2_LOG_ERR("%s: failed to dequeue buffer on %s data stream\n",
+			__func__, type_to_str(buffer->type));
+		return ret;
+	}
+
+	V4L2_LOG("< %s: dequeue buffer index %d on %s (%u) data stream\n", __func__,
+			 buffer->index, type_to_str(buffer->type), buffer->type);
+	return ret;
+}
+
+static int hva_qbuf(struct hva_plugin *hva, int fd, unsigned long int cmd,
+	struct v4l2_buffer *buffer)
+{
+	int ret;
+
+	V4L2_LOG("> %s: queue buffer index %d on %s (%u) data stream\n", __func__,
+		buffer->index, type_to_str(buffer->type), buffer->type);
+
+	if (buffer->type  == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		uint8_t *b = hva->aus[buffer->index].vaddr;
+
+		/* copy sps/pps header only on source pad */
+		hva->meta->get_sps_pps(hva->meta_priv, &b, &buffer->bytesused,
+							   &hva->fmt, &hva->ctrls);
+	}
+
+	ret = SYS_IOCTL(fd, cmd, buffer);
+	if (ret) {
+		V4L2_LOG_ERR("%s: failed to queue buffer on %s data stream\n",
+			__func__, type_to_str(buffer->type));
+		return ret;
+	}
+
+	V4L2_LOG("< %s\n", __func__);
+	return ret;
+}
+
+static int hva_set_ext_ctrls(struct hva_plugin *hva, int fd,
+							 unsigned long int cmd,
+							 struct v4l2_ext_controls *ctrls)
+{
+	int ret;
+
+	V4L2_LOG("> %s: set external controls\n", __func__);
+
+	if (hva->ctrls.controls)
+		free(hva->ctrls.controls);
+
+	hva->ctrls.controls = calloc(ctrls->count, sizeof(struct v4l2_ext_control));
+	if (!hva->ctrls.controls) {
+		V4L2_LOG_ERR("%s: couldn't allocate memory for controls", __func__);
+		return -EINVAL;
+	}
+
+	memcpy(hva->ctrls.controls, ctrls->controls, ctrls->count *
+		   sizeof(struct v4l2_ext_control));
+
+	hva->ctrls.count = ctrls->count;
+
+	/* update ctrls  */
+	hva->meta->set_ctrl(hva->meta_priv, &hva->ctrls);
+	ret = SYS_IOCTL(fd, cmd, ctrls);
+	if (ret) {
+		V4L2_LOG_ERR("%s: failed to set controls\n", __func__);
+		return ret;
+	}
+
+	V4L2_LOG("< %s\n", __func__);
+	return ret;
+}
+
+static int hva_set_fmt(struct hva_plugin *hva, int fd, unsigned long int cmd,
+					   struct v4l2_format *fmt)
+{
+	int ret;
+	V4L2_LOG("> %s: set format\n", __func__);
+
+	/* copy only stream format */
+	if (fmt->type  == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		int i = 0;
+
+		for (i = 0; i < (sizeof(hva_meta) / sizeof(*hva_meta)); i++) {
+			if (hva_meta[i]->stream_format == fmt->fmt.pix.pixelformat) {
+				/* set the right metadata builder methods depending on format */
+				hva->meta = (struct hva_metadata *)hva_meta[i];
+				break;
+			}
+		}
+
+		if(!hva->meta){
+			V4L2_LOG_ERR("%s: Invalid metadata\n", __func__);
+			return -EINVAL;
+		}
+
+		/* copy stream format (w, h, fmt, ...) */
+		memcpy(&hva->fmt, fmt, sizeof(struct v4l2_format));
+
+		hva->meta->start(&hva->meta_priv);
+	}
+
+	ret = SYS_IOCTL(fd, cmd, fmt);
+	if (ret) {
+		V4L2_LOG_ERR("%s: failed to set format on %s data stream\n",
+			__func__, type_to_str(fmt->type));
+		return ret;
+	}
+
+	V4L2_LOG("< %s\n", __func__);
+	return ret;
+}
+
+static int hva_streamon(struct hva_plugin *hva, int fd, unsigned long int cmd,
+	enum v4l2_buf_type *type)
+{
+	int ret;
+	V4L2_LOG("> %s: streamon on %s (%u) data stream\n", __func__,
+		type_to_str(*type), *type);
+
+	ret = SYS_IOCTL(fd, cmd, type);
+	if (ret) {
+		V4L2_LOG_ERR("%s: failed to streamon on %s data stream\n",
+			__func__, type_to_str(*type));
+		return ret;
+	}
+
+	V4L2_LOG("< %s\n", __func__);
+	return ret;
+}
+
+static int hva_streamoff(struct hva_plugin *hva, int fd, unsigned long int cmd,
+	enum v4l2_buf_type *type)
+{
+	int ret;
+	V4L2_LOG("> %s: streamoff on %s (%u) data stream\n", __func__,
+		type_to_str(*type), *type);
+
+	ret = SYS_IOCTL(fd, cmd, type);
+	if (ret) {
+		V4L2_LOG_ERR("%s: failed to streamoff on %s data stream\n",
+			__func__, type_to_str(*type));
+		return ret;
+	}
+
+	V4L2_LOG("< %s\n", __func__);
+	return ret;
+}
+
+static void *hva_plugin_init(int fd)
+{
+	struct hva_plugin *hva = NULL;
+	struct v4l2_capability cap;
+	int ret;
+
+	V4L2_LOG("> %s\n", __func__);
+
+	/* check if device needs hva plugin */
+	memset(&cap, 0, sizeof(cap));
+	ret = SYS_IOCTL (fd, VIDIOC_QUERYCAP, &cap);
+	if (ret) {
+		V4L2_LOG_ERR("%s: failed to query video capabilities\n",
+			__func__);
+		return NULL;
+	}
+
+	/* device doesn't need it. return NULL to disable the plugin */
+	if (strstr((const char *)cap.driver, (const char *)HVA_NAME) == NULL) {
+		V4L2_LOG("%s: the %s device doesn't need the HVA libv4l"
+			" plugin\n", __func__, cap.driver);
+		return NULL;
+	}
+
+	V4L2_LOG("%s: the %s device needs the HVA libv4l plugin\n", __func__,
+		cap.driver);
+
+	/* allocate and initialize private data */
+	hva = calloc(1, sizeof(struct hva_plugin));
+	if (!hva) {
+		V4L2_LOG_ERR("%s: couldn't allocate memory for the HVA libv4l"
+			" plugin\n", __func__);
+		return NULL;
+	}
+
+	V4L2_LOG("< %s: hva %p\n", __func__, hva);
+	return hva;
+}
+
+static void hva_plugin_close(void *dev_ops_priv)
+{
+	struct hva_plugin *hva = dev_ops_priv;
+	unsigned int i;
+
+	V4L2_LOG("> %s: close the HVA libv4l plugin\n", __func__);
+
+	if (!hva)
+		goto close_ret;
+
+	/* unmap AUs */
+	for (i = 0; i < NB_MAX_BUF; i++) {
+		struct hva_buffer *au = &hva->aus[i];
+		if (au->vaddr)
+			SYS_MUNMAP(au->vaddr, au->size);
+	}
+
+	if (hva->ctrls.controls)
+		free(hva->ctrls.controls);
+
+	free(hva);
+
+close_ret:
+	V4L2_LOG("< %s\n", __func__);
+	return;
+}
+
+static int hva_plugin_ioctl(void *dev_ops_priv, int fd,
+			unsigned long int cmd, void *arg)
+{
+	struct hva_plugin *hva = dev_ops_priv;
+
+	switch (cmd) {
+	case VIDIOC_QUERYBUF:
+		return hva_querybuf(hva, fd, cmd, arg);
+	case VIDIOC_QBUF:
+		return hva_qbuf(hva, fd, cmd, arg);
+	case VIDIOC_DQBUF:
+		return hva_dqbuf(hva, fd, cmd, arg);
+	case VIDIOC_S_EXT_CTRLS:
+		return hva_set_ext_ctrls(hva, fd, cmd, arg);
+	case VIDIOC_S_FMT:
+		return hva_set_fmt(hva, fd, cmd, arg);
+	case VIDIOC_STREAMON:
+		return hva_streamon(hva, fd, cmd, arg);
+	case VIDIOC_STREAMOFF:
+		return hva_streamoff(hva, fd, cmd, arg);
+	default:
+		return SYS_IOCTL(fd, cmd, arg);
+	}
+}
+
+PLUGIN_PUBLIC const struct libv4l_dev_ops libv4l2_plugin = {
+	.init = &hva_plugin_init,
+	.close = &hva_plugin_close,
+	.ioctl = &hva_plugin_ioctl,
+};
diff --git a/lib/libv4l-hva/libv4l-hva.h b/lib/libv4l-hva/libv4l-hva.h
new file mode 100644
index 0000000..5564fb9
--- /dev/null
+++ b/lib/libv4l-hva/libv4l-hva.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics SA
+ *
+ * License Terms:  GNU General Public License (GPL) version 2
+ *
+ * Author: <yannick.fertre@st.com> for STMicroelectronics.
+ */
+
+#ifndef LIBV4L_HVA_H
+#define LIBV4L_HVA_H
+
+#include <stdio.h>
+#include <linux/videodev2.h>
+
+#include "libv4l2.h"
+#include "../libv4l2/libv4l2-priv.h"
+
+/* The following definition must be aligned with the ones specified by the
+ * HVA driver */
+#define HVA_NAME	"hva"
+
+#ifndef HVA_DEBUG
+#undef V4L2_LOG
+#define V4L2_LOG(...)
+#endif
+
+/* fix maximum of buffer to 32 */
+#define NB_MAX_BUF 32
+
+/**
+ * struct hva_buffer - structure.
+ *
+ * @size:	size of buffer
+ * @vaddr:	virtual address
+ */
+struct hva_buffer {
+	size_t size;
+	void *vaddr;
+};
+
+struct hva_metadata {
+	const char *name;
+	unsigned int stream_format;
+
+	/**
+	 * start() - start the header encoder
+	* @priv:      (in/out) pointer to a private context
+	*
+	* Initialize the header encoder. Return a pointer to the encoder
+	* private context.
+	*/
+	int (*start) (void **priv);
+
+	/**
+	 * stop() - stop the header encoder
+	 * @priv: (in/out) pointer to the encoder private context
+	 *
+	 * Release the header encoder.
+	 */
+	void (*stop) (void *priv);
+
+	/**
+	 * get_sps_pps() - get the sps/pps frame header
+	 * @priv: (in) pointer to the encoder private context
+	 * @data: (in/out) pointer to the sps/pps header
+	 * @size: (in/out) pointer to the size of sps/pps header
+	 * @format: (in) stream format
+	 * @ctrls: (in) external controls
+	 *
+	 * Fill sps/pps frame header & return size of frame header
+	 */
+	int (*get_sps_pps) (void *priv, uint8_t **data, size_t *size,
+						struct v4l2_format *format,
+						struct v4l2_ext_controls *ctrls);
+
+	/**
+	 * set_ctrl() - update the external ctrl values to header encoder
+	 * @ctrls: (in) external controls
+	 *
+	 */
+	int (*set_ctrl) (void *priv, struct v4l2_ext_controls *ctrls);
+};
+
+/**
+ * struct hva_plugin
+ *
+ * @aus: array of access unit
+ * @fmt: stream format
+ * @ctrls: external controls
+ * @meta: local metadata
+ * @meta_priv: private data
+ */
+
+struct hva_plugin {
+	struct hva_buffer aus[NB_MAX_BUF];
+	struct v4l2_format fmt;
+	struct v4l2_ext_controls ctrls;
+	struct hva_metadata *meta;
+	void *meta_priv;
+};
+
+#endif /* LIBV4L_HVA_H */
diff --git a/lib/libv4l-hva/va/sysdeps.h b/lib/libv4l-hva/va/sysdeps.h
new file mode 100644
index 0000000..4de764d
--- /dev/null
+++ b/lib/libv4l-hva/va/sysdeps.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2007-2009 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef SYSDEPS_H
+#define SYSDEPS_H
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <stdint.h>
+#include <assert.h>
+
+#ifdef ANDROID
+# define Bool  int
+# define True  1
+# define False 0
+
+/* Macros generated from configure */
+# define LIBVA_VERSION_S "1.1.0"
+
+/* Android logging utilities */
+# include <utils/Log.h>
+
+# ifdef ANDROID_ALOG
+#  define va_log_error(buffer)  do { ALOGE("%s", buffer); } while (0)
+#  define va_log_info(buffer)   do { ALOGI("%s", buffer); } while (0)
+# elif ANDROID_LOG
+#  define va_log_error(buffer)  do { LOGE("%s", buffer); } while (0)
+#  define va_log_info(buffer)   do { LOGI("%s", buffer); } while (0)
+# endif
+#endif
+
+#ifndef va_log_error
+#define va_log_error(buffer) do {                       \
+        fprintf(stderr, "libva error: %s", buffer);     \
+    } while (0)
+#endif
+
+#ifndef va_log_info
+#define va_log_info(buffer) do {                        \
+        fprintf(stderr, "libva info: %s", buffer);      \
+    } while (0)
+#endif
+
+#if defined __GNUC__ && defined HAVE_GNUC_VISIBILITY_ATTRIBUTE
+# define DLL_HIDDEN __attribute__((visibility("hidden")))
+# define DLL_EXPORT __attribute__((visibility("default")))
+#else
+# define DLL_HIDDEN
+# define DLL_EXPORT
+#endif
+
+#endif /* SYSDEPS_H */
diff --git a/lib/libv4l-hva/va/va.h b/lib/libv4l-hva/va/va.h
new file mode 100644
index 0000000..01694a9
--- /dev/null
+++ b/lib/libv4l-hva/va/va.h
@@ -0,0 +1,2666 @@
+/*
+ * Copyright (c) 2007-2009 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+/*
+ * Video Acceleration (VA) API Specification
+ *
+ * Rev. 0.30
+ * <jonathan.bian@intel.com>
+ *
+ * Revision History:
+ * rev 0.10 (12/10/2006 Jonathan Bian) - Initial draft
+ * rev 0.11 (12/15/2006 Jonathan Bian) - Fixed some errors
+ * rev 0.12 (02/05/2007 Jonathan Bian) - Added VC-1 data structures for slice level decode
+ * rev 0.13 (02/28/2007 Jonathan Bian) - Added GetDisplay()
+ * rev 0.14 (04/13/2007 Jonathan Bian) - Fixed MPEG-2 PictureParameter structure, cleaned up a few funcs.
+ * rev 0.15 (04/20/2007 Jonathan Bian) - Overhauled buffer management
+ * rev 0.16 (05/02/2007 Jonathan Bian) - Added error codes and fixed some issues with configuration
+ * rev 0.17 (05/07/2007 Jonathan Bian) - Added H.264/AVC data structures for slice level decode.
+ * rev 0.18 (05/14/2007 Jonathan Bian) - Added data structures for MPEG-4 slice level decode 
+ *                                       and MPEG-2 motion compensation.
+ * rev 0.19 (08/06/2007 Jonathan Bian) - Removed extra type for bitplane data.
+ * rev 0.20 (08/08/2007 Jonathan Bian) - Added missing fields to VC-1 PictureParameter structure.
+ * rev 0.21 (08/20/2007 Jonathan Bian) - Added image and subpicture support.
+ * rev 0.22 (08/27/2007 Jonathan Bian) - Added support for chroma-keying and global alpha.
+ * rev 0.23 (09/11/2007 Jonathan Bian) - Fixed some issues with images and subpictures.
+ * rev 0.24 (09/18/2007 Jonathan Bian) - Added display attributes.
+ * rev 0.25 (10/18/2007 Jonathan Bian) - Changed to use IDs only for some types.
+ * rev 0.26 (11/07/2007 Waldo Bastian) - Change vaCreateBuffer semantics
+ * rev 0.27 (11/19/2007 Matt Sottek)   - Added DeriveImage
+ * rev 0.28 (12/06/2007 Jonathan Bian) - Added new versions of PutImage and AssociateSubpicture 
+ *                                       to enable scaling
+ * rev 0.29 (02/07/2008 Jonathan Bian) - VC1 parameter fixes,
+ *                                       added VA_STATUS_ERROR_RESOLUTION_NOT_SUPPORTED
+ * rev 0.30 (03/01/2009 Jonathan Bian) - Added encoding support for H.264 BP and MPEG-4 SP and fixes
+ *                                       for ISO C conformance.
+ * rev 0.31 (09/02/2009 Gwenole Beauchesne) - VC-1/H264 fields change for VDPAU and XvBA backend
+ *                                       Application needs to relink with the new library.
+ *
+ * rev 0.31.1 (03/29/2009)              - Data structure for JPEG encode
+ * rev 0.31.2 (01/13/2011 Anthony Pabon)- Added a flag to indicate Subpicture coordinates are screen
+ *                                        screen relative rather than source video relative.
+ * rev 0.32.0 (01/13/2011 Xiang Haihao) - Add profile into VAPictureParameterBufferVC1
+ *                                        update VAAPI to 0.32.0
+ *
+ * Acknowledgements:
+ *  Some concepts borrowed from XvMC and XvImage.
+ *  Waldo Bastian (Intel), Matt Sottek (Intel),  Austin Yuan (Intel), and Gwenole Beauchesne (SDS)
+ *  contributed to various aspects of the API.
+ */
+
+/**
+ * \file va.h
+ * \brief The Core API
+ *
+ * This file contains the \ref api_core "Core API".
+ */
+
+#ifndef _VA_H_
+#define _VA_H_
+
+#include <stddef.h>
+#include <stdint.h>
+#include <va/va_version.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \mainpage Video Acceleration (VA) API
+ *
+ * \section intro Introduction
+ *
+ * The main motivation for VA-API (Video Acceleration API) is to
+ * enable hardware accelerated video decode and encode at various
+ * entry-points (VLD, IDCT, Motion Compensation etc.) for the
+ * prevailing coding standards today (MPEG-2, MPEG-4 ASP/H.263, MPEG-4
+ * AVC/H.264, VC-1/VMW3, and JPEG).
+ *
+ * VA-API is split into several modules:
+ * - \ref api_core
+ * - \ref api_enc_h264
+ * - \ref api_vpp
+ */
+
+/**
+ * \defgroup api_core Core API
+ *
+ * @{
+ */
+
+/**
+Overview 
+
+The VA API is intended to provide an interface between a video decode/encode/display
+application (client) and a hardware accelerator (server), to off-load 
+video decode/encode/display operations from the host to the hardware accelerator at various 
+entry-points.
+
+The basic operation steps are:
+
+- Negotiate a mutually acceptable configuration with the server to lock
+  down profile, entrypoints, and other attributes that will not change on 
+  a frame-by-frame basis.
+- Create a decode context which represents a "virtualized" hardware decode 
+  device
+- Get and fill decode buffers with picture level, slice level and macroblock 
+  level data (depending on entrypoints)
+- Pass the decode buffers to the server to decode the current frame
+
+Initialization & Configuration Management 
+
+- Find out supported profiles
+- Find out entrypoints for a given profile
+- Find out configuration attributes for a given profile/entrypoint pair
+- Create a configuration for use by the decoder
+
+*/
+
+typedef void* VADisplay;	/* window system dependent */
+
+typedef int VAStatus;	/** Return status type from functions */
+/** Values for the return status */
+#define VA_STATUS_SUCCESS			0x00000000
+#define VA_STATUS_ERROR_OPERATION_FAILED	0x00000001
+#define VA_STATUS_ERROR_ALLOCATION_FAILED	0x00000002
+#define VA_STATUS_ERROR_INVALID_DISPLAY		0x00000003
+#define VA_STATUS_ERROR_INVALID_CONFIG		0x00000004
+#define VA_STATUS_ERROR_INVALID_CONTEXT		0x00000005
+#define VA_STATUS_ERROR_INVALID_SURFACE		0x00000006
+#define VA_STATUS_ERROR_INVALID_BUFFER		0x00000007
+#define VA_STATUS_ERROR_INVALID_IMAGE		0x00000008
+#define VA_STATUS_ERROR_INVALID_SUBPICTURE	0x00000009
+#define VA_STATUS_ERROR_ATTR_NOT_SUPPORTED	0x0000000a
+#define VA_STATUS_ERROR_MAX_NUM_EXCEEDED	0x0000000b
+#define VA_STATUS_ERROR_UNSUPPORTED_PROFILE	0x0000000c
+#define VA_STATUS_ERROR_UNSUPPORTED_ENTRYPOINT	0x0000000d
+#define VA_STATUS_ERROR_UNSUPPORTED_RT_FORMAT	0x0000000e
+#define VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE	0x0000000f
+#define VA_STATUS_ERROR_SURFACE_BUSY		0x00000010
+#define VA_STATUS_ERROR_FLAG_NOT_SUPPORTED      0x00000011
+#define VA_STATUS_ERROR_INVALID_PARAMETER	0x00000012
+#define VA_STATUS_ERROR_RESOLUTION_NOT_SUPPORTED 0x00000013
+#define VA_STATUS_ERROR_UNIMPLEMENTED           0x00000014
+#define VA_STATUS_ERROR_SURFACE_IN_DISPLAYING   0x00000015
+#define VA_STATUS_ERROR_INVALID_IMAGE_FORMAT    0x00000016
+#define VA_STATUS_ERROR_DECODING_ERROR          0x00000017
+#define VA_STATUS_ERROR_ENCODING_ERROR          0x00000018
+/**
+ * \brief An invalid/unsupported value was supplied.
+ *
+ * This is a catch-all error code for invalid or unsupported values.
+ * e.g. value exceeding the valid range, invalid type in the context
+ * of generic attribute values.
+ */
+#define VA_STATUS_ERROR_INVALID_VALUE           0x00000019
+/** \brief An unsupported filter was supplied. */
+#define VA_STATUS_ERROR_UNSUPPORTED_FILTER      0x00000020
+/** \brief An invalid filter chain was supplied. */
+#define VA_STATUS_ERROR_INVALID_FILTER_CHAIN    0x00000021
+/** \brief Indicate HW busy (e.g. run multiple encoding simultaneously). */
+#define VA_STATUS_ERROR_HW_BUSY	                0x00000022
+/** \brief An unsupported memory type was supplied. */
+#define VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE 0x00000024
+#define VA_STATUS_ERROR_UNKNOWN			0xFFFFFFFF
+
+/** De-interlacing flags for vaPutSurface() */
+#define VA_FRAME_PICTURE        0x00000000 
+#define VA_TOP_FIELD            0x00000001
+#define VA_BOTTOM_FIELD         0x00000002
+
+/**
+ * Enabled the positioning/cropping/blending feature:
+ * 1, specify the video playback position in the isurface
+ * 2, specify the cropping info for video playback
+ * 3, encoded video will blend with background color
+ */
+#define VA_ENABLE_BLEND         0x00000004 /* video area blend with the constant color */ 
+    
+/**
+ * Clears the drawable with background color.
+ * for hardware overlay based implementation this flag
+ * can be used to turn off the overlay
+ */
+#define VA_CLEAR_DRAWABLE       0x00000008
+
+/** Color space conversion flags for vaPutSurface() */
+#define VA_SRC_BT601            0x00000010
+#define VA_SRC_BT709            0x00000020
+#define VA_SRC_SMPTE_240        0x00000040
+
+/** Scaling flags for vaPutSurface() */
+#define VA_FILTER_SCALING_DEFAULT       0x00000000
+#define VA_FILTER_SCALING_FAST          0x00000100
+#define VA_FILTER_SCALING_HQ            0x00000200
+#define VA_FILTER_SCALING_NL_ANAMORPHIC 0x00000300
+#define VA_FILTER_SCALING_MASK          0x00000f00
+
+/**
+ * Returns a short english description of error_status
+ */
+const char *vaErrorStr(VAStatus error_status);
+
+/**
+ * Initialization:
+ * A display must be obtained by calling vaGetDisplay() before calling
+ * vaInitialize() and other functions. This connects the API to the 
+ * native window system.
+ * For X Windows, native_dpy would be from XOpenDisplay()
+ */
+typedef void* VANativeDisplay;	/* window system dependent */
+
+int vaDisplayIsValid(VADisplay dpy);
+    
+/**
+ * Initialize the library 
+ */
+VAStatus vaInitialize (
+    VADisplay dpy,
+    int *major_version,	 /* out */
+    int *minor_version 	 /* out */
+);
+
+/**
+ * After this call, all library internal resources will be cleaned up
+ */ 
+VAStatus vaTerminate (
+    VADisplay dpy
+);
+
+/**
+ * vaQueryVendorString returns a pointer to a zero-terminated string
+ * describing some aspects of the VA implemenation on a specific    
+ * hardware accelerator. The format of the returned string is vendor
+ * specific and at the discretion of the implementer.
+ * e.g. for the Intel GMA500 implementation, an example would be:
+ * "Intel GMA500 - 2.0.0.32L.0005"
+ */
+const char *vaQueryVendorString (
+    VADisplay dpy
+);
+
+typedef int (*VAPrivFunc)();
+
+/**
+ * Return a function pointer given a function name in the library.
+ * This allows private interfaces into the library
+ */ 
+VAPrivFunc vaGetLibFunc (
+    VADisplay dpy,
+    const char *func
+);
+
+/** Currently defined profiles */
+typedef enum
+{
+    /** \brief Profile ID used for video processing. */
+    VAProfileNone                       = -1,
+    VAProfileMPEG2Simple		= 0,
+    VAProfileMPEG2Main			= 1,
+    VAProfileMPEG4Simple		= 2,
+    VAProfileMPEG4AdvancedSimple	= 3,
+    VAProfileMPEG4Main			= 4,
+    VAProfileH264Baseline		= 5,
+    VAProfileH264Main			= 6,
+    VAProfileH264High			= 7,
+    VAProfileVC1Simple			= 8,
+    VAProfileVC1Main			= 9,
+    VAProfileVC1Advanced		= 10,
+    VAProfileH263Baseline		= 11,
+    VAProfileJPEGBaseline               = 12,
+    VAProfileH264ConstrainedBaseline    = 13,
+    VAProfileVP8Version0_3              = 14,
+    VAProfileH264MultiviewHigh          = 15,
+    VAProfileH264StereoHigh             = 16
+} VAProfile;
+
+/**
+ *  Currently defined entrypoints 
+ */
+typedef enum
+{
+    VAEntrypointVLD		= 1,
+    VAEntrypointIZZ		= 2,
+    VAEntrypointIDCT		= 3,
+    VAEntrypointMoComp		= 4,
+    VAEntrypointDeblocking	= 5,
+    VAEntrypointEncSlice	= 6,	/* slice level encode */
+    VAEntrypointEncPicture 	= 7,	/* pictuer encode, JPEG, etc */
+    VAEntrypointVideoProc       = 10,   /**< Video pre/post-processing. */
+} VAEntrypoint;
+
+/** Currently defined configuration attribute types */
+typedef enum
+{
+    VAConfigAttribRTFormat		= 0,
+    VAConfigAttribSpatialResidual	= 1,
+    VAConfigAttribSpatialClipping	= 2,
+    VAConfigAttribIntraResidual		= 3,
+    VAConfigAttribEncryption		= 4,
+    VAConfigAttribRateControl		= 5,
+
+    /** @name Attributes for encoding */
+    /**@{*/
+    /**
+     * \brief Packed headers mode. Read/write.
+     *
+     * This attribute determines what packed headers the driver supports,
+     * through vaGetConfigAttributes(); and what packed headers the user
+     * will be providing to the driver, through vaCreateConfig(), if the
+     * driver supports those.
+     *
+     * See \c VA_ENC_PACKED_HEADER_xxx for the list of packed headers.
+     */
+    VAConfigAttribEncPackedHeaders      = 10,
+    /**
+     * \brief Interlaced mode. Read/write.
+     *
+     * This attribute determines what kind of interlaced encoding mode
+     * the driver supports.
+     *
+     * See \c VA_ENC_INTERLACED_xxx for the list of interlaced modes.
+     */
+    VAConfigAttribEncInterlaced         = 11,
+    /**
+     * \brief Maximum number of reference frames. Read-only.
+     *
+     * This attribute determines the maximum number of reference
+     * frames supported for encoding.
+     *
+     * Note: for H.264 encoding, the value represents the maximum number
+     * of reference frames for both the reference picture list 0 (bottom
+     * 16 bits) and the reference picture list 1 (top 16 bits).
+     */
+    VAConfigAttribEncMaxRefFrames       = 13,
+    /**
+     * \brief Maximum number of slices per frame. Read-only.
+     *
+     * This attribute determines the maximum number of slices the
+     * driver can support to encode a single frame.
+     */
+    VAConfigAttribEncMaxSlices          = 14,
+    /**
+     * \brief Slice structure. Read-only.
+     *
+     * This attribute determines slice structures supported by the
+     * driver for encoding. This attribute is a hint to the user so
+     * that he can choose a suitable surface size and how to arrange
+     * the encoding process of multiple slices per frame.
+     *
+     * More specifically, for H.264 encoding, this attribute
+     * determines the range of accepted values to
+     * VAEncSliceParameterBufferH264::macroblock_address and
+     * VAEncSliceParameterBufferH264::num_macroblocks.
+     *
+     * See \c VA_ENC_SLICE_STRUCTURE_xxx for the supported slice
+     * structure types.
+     */
+    VAConfigAttribEncSliceStructure     = 15,
+    /**
+     * \brief Macroblock information. Read-only.
+     *
+     * This attribute determines whether the driver supports extra
+     * encoding information per-macroblock. e.g. QP.
+     *
+     * More specifically, for H.264 encoding, if the driver returns a non-zero
+     * value for this attribute, this means the application can create
+     * additional #VAEncMacroblockParameterBufferH264 buffers referenced
+     * through VAEncSliceParameterBufferH264::macroblock_info.
+     */
+    VAConfigAttribEncMacroblockInfo     = 16,
+    /**
+     * \brief Encoding quality range attribute. Read-only.
+     *
+     * This attribute conveys whether the driver supports different quality level settings
+     * for encoding. A value less than or equal to 1 means that the encoder only has a single
+     * quality setting, and a value greater than 1 represents the number of quality levels 
+     * that can be configured. e.g. a value of 2 means there are two distinct quality levels. 
+     */
+    VAConfigAttribEncQualityRange     = 21,
+    /**@}*/
+    VAConfigAttribTypeMax
+} VAConfigAttribType;
+
+/**
+ * Configuration attributes
+ * If there is more than one value for an attribute, a default
+ * value will be assigned to the attribute if the client does not
+ * specify the attribute when creating a configuration
+ */
+typedef struct _VAConfigAttrib {
+    VAConfigAttribType type;
+    unsigned int value; /* OR'd flags (bits) for this attribute */
+} VAConfigAttrib;
+
+/** attribute value for VAConfigAttribRTFormat */
+#define VA_RT_FORMAT_YUV420	0x00000001	
+#define VA_RT_FORMAT_YUV422	0x00000002
+#define VA_RT_FORMAT_YUV444	0x00000004
+#define VA_RT_FORMAT_YUV411	0x00000008
+#define VA_RT_FORMAT_YUV400	0x00000010
+#define VA_RT_FORMAT_RGB16	0x00010000
+#define VA_RT_FORMAT_RGB32	0x00020000
+/* RGBP covers RGBP and BGRP fourcc */ 
+#define VA_RT_FORMAT_RGBP	0x00100000
+#define VA_RT_FORMAT_PROTECTED	0x80000000
+
+/** @name Attribute values for VAConfigAttribRateControl */
+/**@{*/
+/** \brief Driver does not support any form of rate control. */
+#define VA_RC_NONE                      0x00000001
+/** \brief Constant bitrate. */
+#define VA_RC_CBR                       0x00000002
+/** \brief Variable bitrate. */
+#define VA_RC_VBR                       0x00000004
+/** \brief Video conference mode. */
+#define VA_RC_VCM                       0x00000008
+/** \brief Constant QP. */
+#define VA_RC_CQP                       0x00000010
+/** \brief Variable bitrate with peak rate higher than average bitrate. */
+#define VA_RC_VBR_CONSTRAINED           0x00000020
+/**@}*/
+
+/** @name Attribute values for VAConfigAttribEncPackedHeaders */
+/**@{*/
+/** \brief Driver does not support any packed headers mode. */
+#define VA_ENC_PACKED_HEADER_NONE       0x00000000
+/** \brief Driver supports packed sequence headers. e.g. SPS for H.264. */
+#define VA_ENC_PACKED_HEADER_SEQUENCE   0x00000001
+/** \brief Driver supports packed picture headers. e.g. PPS for H.264. */
+#define VA_ENC_PACKED_HEADER_PICTURE    0x00000002
+/** \brief Driver supports packed slice headers. e.g. \c slice_header() for H.264. */
+#define VA_ENC_PACKED_HEADER_SLICE      0x00000004
+/** \brief Driver supports misc packed headers. e.g. SEI for H.264. */
+#define VA_ENC_PACKED_HEADER_MISC       0x00000008
+/** \brief Driver supports raw packed header, see VAEncPackedHeaderRawData */
+#define VA_ENC_PACKED_HEADER_RAW_DATA   0x00000010
+/**@}*/
+
+/** @name Attribute values for VAConfigAttribEncInterlaced */
+/**@{*/
+/** \brief Driver does not support interlaced coding. */
+#define VA_ENC_INTERLACED_NONE          0x00000000
+/** \brief Driver supports interlaced frame coding. */
+#define VA_ENC_INTERLACED_FRAME         0x00000001
+/** \brief Driver supports interlaced field coding. */
+#define VA_ENC_INTERLACED_FIELD         0x00000002
+/** \brief Driver supports macroblock adaptive frame field coding. */
+#define VA_ENC_INTERLACED_MBAFF         0x00000004
+/** \brief Driver supports picture adaptive frame field coding. */
+#define VA_ENC_INTERLACED_PAFF          0x00000008
+/**@}*/
+
+/** @name Attribute values for VAConfigAttribEncSliceStructure */
+/**@{*/
+/** \brief Driver supports an arbitrary number of rows per slice. */
+#define VA_ENC_SLICE_STRUCTURE_ARBITRARY_ROWS           0x00000000
+/** \brief Driver supports a power-of-two number of rows per slice. */
+#define VA_ENC_SLICE_STRUCTURE_POWER_OF_TWO_ROWS        0x00000001
+/** \brief Driver supports an arbitrary number of rows per slice. */
+#define VA_ENC_SLICE_STRUCTURE_ARBITRARY_MACROBLOCKS    0x00000002
+/**@}*/
+
+/**
+ * if an attribute is not applicable for a given
+ * profile/entrypoint pair, then set the value to the following 
+ */
+#define VA_ATTRIB_NOT_SUPPORTED 0x80000000
+
+/** Get maximum number of profiles supported by the implementation */
+int vaMaxNumProfiles (
+    VADisplay dpy
+);
+
+/** Get maximum number of entrypoints supported by the implementation */
+int vaMaxNumEntrypoints (
+    VADisplay dpy
+);
+
+/** Get maximum number of attributs supported by the implementation */
+int vaMaxNumConfigAttributes (
+    VADisplay dpy
+);
+
+/**
+ * Query supported profiles 
+ * The caller must provide a "profile_list" array that can hold at
+ * least vaMaxNumProfile() entries. The actual number of profiles
+ * returned in "profile_list" is returned in "num_profile".
+ */
+VAStatus vaQueryConfigProfiles (
+    VADisplay dpy,
+    VAProfile *profile_list,	/* out */
+    int *num_profiles		/* out */
+);
+
+/**
+ * Query supported entrypoints for a given profile 
+ * The caller must provide an "entrypoint_list" array that can hold at
+ * least vaMaxNumEntrypoints() entries. The actual number of entrypoints 
+ * returned in "entrypoint_list" is returned in "num_entrypoints".
+ */
+VAStatus vaQueryConfigEntrypoints (
+    VADisplay dpy,
+    VAProfile profile,
+    VAEntrypoint *entrypoint_list,	/* out */
+    int *num_entrypoints		/* out */
+);
+
+/**
+ * Get attributes for a given profile/entrypoint pair 
+ * The caller must provide an "attrib_list" with all attributes to be 
+ * retrieved.  Upon return, the attributes in "attrib_list" have been 
+ * updated with their value.  Unknown attributes or attributes that are 
+ * not supported for the given profile/entrypoint pair will have their 
+ * value set to VA_ATTRIB_NOT_SUPPORTED
+ */
+VAStatus vaGetConfigAttributes (
+    VADisplay dpy,
+    VAProfile profile,
+    VAEntrypoint entrypoint,
+    VAConfigAttrib *attrib_list, /* in/out */
+    int num_attribs
+);
+
+/** Generic ID type, can be re-typed for specific implementation */
+typedef unsigned int VAGenericID;
+
+typedef VAGenericID VAConfigID;
+
+/**
+ * Create a configuration for the decode pipeline 
+ * it passes in the attribute list that specifies the attributes it cares 
+ * about, with the rest taking default values.  
+ */
+VAStatus vaCreateConfig (
+    VADisplay dpy,
+    VAProfile profile, 
+    VAEntrypoint entrypoint, 
+    VAConfigAttrib *attrib_list,
+    int num_attribs,
+    VAConfigID *config_id /* out */
+);
+
+/**
+ * Free resources associdated with a given config 
+ */
+VAStatus vaDestroyConfig (
+    VADisplay dpy,
+    VAConfigID config_id
+);
+
+/**
+ * Query all attributes for a given configuration 
+ * The profile of the configuration is returned in "profile"
+ * The entrypoint of the configuration is returned in "entrypoint"
+ * The caller must provide an "attrib_list" array that can hold at least 
+ * vaMaxNumConfigAttributes() entries. The actual number of attributes 
+ * returned in "attrib_list" is returned in "num_attribs"
+ */
+VAStatus vaQueryConfigAttributes (
+    VADisplay dpy,
+    VAConfigID config_id, 
+    VAProfile *profile, 	/* out */
+    VAEntrypoint *entrypoint, 	/* out */
+    VAConfigAttrib *attrib_list,/* out */
+    int *num_attribs 		/* out */
+);
+
+
+/**
+ * Contexts and Surfaces
+ *
+ * Context represents a "virtual" video decode pipeline. Surfaces are render 
+ * targets for a given context. The data in the surfaces are not accessible  
+ * to the client and the internal data format of the surface is implementatin 
+ * specific. 
+ *
+ * Surfaces will be bound to a context when the context is created. Once
+ * a surface is bound to a given context, it can not be used to create  
+ * another context. The association is removed when the context is destroyed
+ * 
+ * Both contexts and surfaces are identified by unique IDs and its
+ * implementation specific internals are kept opaque to the clients
+ */
+
+typedef VAGenericID VAContextID;
+
+typedef VAGenericID VASurfaceID;
+
+#define VA_INVALID_ID		0xffffffff
+#define VA_INVALID_SURFACE	VA_INVALID_ID
+
+/** \brief Generic value types. */
+typedef enum  {
+    VAGenericValueTypeInteger = 1,      /**< 32-bit signed integer. */
+    VAGenericValueTypeFloat,            /**< 32-bit floating-point value. */
+    VAGenericValueTypePointer,          /**< Generic pointer type */
+    VAGenericValueTypeFunc              /**< Pointer to function */
+} VAGenericValueType;
+
+/** \brief Generic function type. */
+typedef void (*VAGenericFunc)(void);
+
+/** \brief Generic value. */
+typedef struct _VAGenericValue {
+    /** \brief Value type. See #VAGenericValueType. */
+    VAGenericValueType  type;
+    /** \brief Value holder. */
+    union {
+        /** \brief 32-bit signed integer. */
+        int             i;
+        /** \brief 32-bit float. */
+        float           f;
+        /** \brief Generic pointer. */
+        void           *p;
+        /** \brief Pointer to function. */
+        VAGenericFunc   fn;
+    }                   value;
+} VAGenericValue;
+
+/** @name Surface attribute flags */
+/**@{*/
+/** \brief Surface attribute is not supported. */
+#define VA_SURFACE_ATTRIB_NOT_SUPPORTED 0x00000000
+/** \brief Surface attribute can be got through vaQuerySurfaceAttributes(). */
+#define VA_SURFACE_ATTRIB_GETTABLE      0x00000001
+/** \brief Surface attribute can be set through vaCreateSurfaces(). */
+#define VA_SURFACE_ATTRIB_SETTABLE      0x00000002
+/**@}*/
+
+/** \brief Surface attribute types. */
+typedef enum {
+    VASurfaceAttribNone = 0,
+    /**
+     * \brief Pixel format (fourcc).
+     *
+     * The value is meaningful as input to vaQuerySurfaceAttributes().
+     * If zero, the driver returns the optimal pixel format for the
+     * specified config. Otherwise, if non-zero, the value represents
+     * a pixel format (FOURCC) that is kept as is on output, if the
+     * driver supports it. Otherwise, the driver sets the value to
+     * zero and drops the \c VA_SURFACE_ATTRIB_SETTABLE flag.
+     */
+    VASurfaceAttribPixelFormat,
+    /** \brief Minimal width in pixels (int, read-only). */
+    VASurfaceAttribMinWidth,
+    /** \brief Maximal width in pixels (int, read-only). */
+    VASurfaceAttribMaxWidth,
+    /** \brief Minimal height in pixels (int, read-only). */
+    VASurfaceAttribMinHeight,
+    /** \brief Maximal height in pixels (int, read-only). */
+    VASurfaceAttribMaxHeight,
+    /** \brief Surface memory type expressed in bit fields (int, read/write). */
+    VASurfaceAttribMemoryType,
+    /** \brief External buffer descriptor (pointer, write). */
+    VASurfaceAttribExternalBufferDescriptor,
+    /** \brief Surface usage hint, gives the driver a hint of intended usage 
+     *  to optimize allocation (e.g. tiling) (int, read/write). */
+    VASurfaceAttribUsageHint,
+    /** \brief Number of surface attributes. */
+    VASurfaceAttribCount
+} VASurfaceAttribType;
+
+/** \brief Surface attribute. */
+typedef struct _VASurfaceAttrib {
+    /** \brief Type. */
+    VASurfaceAttribType type;
+    /** \brief Flags. See "Surface attribute flags". */
+    unsigned int        flags;
+    /** \brief Value. See "Surface attribute types" for the expected types. */
+    VAGenericValue      value;
+} VASurfaceAttrib;
+
+/** 
+ * @name VASurfaceAttribMemoryType values in bit fields. 
+ * Bit 0:7 are reserved for generic types, Bit 31:28 are reserved for 
+ * Linux DRM, Bit 23:20 are reserved for Android. DRM and Android specific
+ * types are defined in DRM and Android header files.
+ */
+/**@{*/
+/** \brief VA memory type (default) is supported. */
+#define VA_SURFACE_ATTRIB_MEM_TYPE_VA			0x00000001
+/** \brief V4L2 buffer memory type is supported. */
+#define VA_SURFACE_ATTRIB_MEM_TYPE_V4L2			0x00000002
+/** \brief User pointer memory type is supported. */
+#define VA_SURFACE_ATTRIB_MEM_TYPE_USER_PTR		0x00000004
+/**@}*/
+
+/** 
+ * \brief VASurfaceAttribExternalBuffers structure for 
+ * the VASurfaceAttribExternalBufferDescriptor attribute.
+ */
+typedef struct _VASurfaceAttribExternalBuffers {
+    /** \brief pixel format in fourcc. */
+    unsigned int pixel_format;
+    /** \brief width in pixels. */
+    unsigned int width;
+    /** \brief height in pixels. */
+    unsigned int height;
+    /** \brief total size of the buffer in bytes. */
+    unsigned int data_size;
+    /** \brief number of planes for planar layout */
+    unsigned int num_planes;
+    /** \brief pitch for each plane in bytes */
+    unsigned int pitches[4];
+    /** \brief offset for each plane in bytes */
+    unsigned int offsets[4];
+    /** \brief buffer handles or user pointers */
+    unsigned long *buffers;
+    /** \brief number of elements in the "buffers" array */
+    unsigned int num_buffers;
+    /** \brief flags. See "Surface external buffer descriptor flags". */
+    unsigned int flags;
+    /** \brief reserved for passing private data */
+    void *private_data;
+} VASurfaceAttribExternalBuffers;
+
+/** @name VASurfaceAttribExternalBuffers flags */
+/**@{*/
+/** \brief Enable memory tiling */
+#define VA_SURFACE_EXTBUF_DESC_ENABLE_TILING	0x00000001
+/** \brief Memory is cacheable */
+#define VA_SURFACE_EXTBUF_DESC_CACHED		0x00000002
+/** \brief Memory is non-cacheable */
+#define VA_SURFACE_EXTBUF_DESC_UNCACHED		0x00000004
+/** \brief Memory is write-combined */
+#define VA_SURFACE_EXTBUF_DESC_WC		0x00000008
+/** \brief Memory is protected */
+#define VA_SURFACE_EXTBUF_DESC_PROTECTED        0x80000000
+
+/** @name VASurfaceAttribUsageHint attribute usage hint flags */
+/**@{*/
+/** \brief Surface usage not indicated. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_GENERIC 	0x00000000
+/** \brief Surface used by video decoder. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_DECODER 	0x00000001
+/** \brief Surface used by video encoder. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_ENCODER 	0x00000002
+/** \brief Surface read by video post-processing. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_VPP_READ 	0x00000004
+/** \brief Surface written by video post-processing. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_VPP_WRITE 	0x00000008
+/** \brief Surface used for display. */
+#define VA_SURFACE_ATTRIB_USAGE_HINT_DISPLAY 	0x00000010
+
+/**@}*/
+
+/**
+ * \brief Queries surface attributes for the supplied config.
+ *
+ * Unlike vaGetSurfaceAttributes(), this function queries for all
+ * supported attributes for the supplied VA @config. In particular, if
+ * the underlying hardware supports the creation of VA surfaces in
+ * various formats, then this function will enumerate all pixel
+ * formats that are supported.
+ *
+ * The \c attrib_list array is allocated by the user and \c
+ * num_attribs shall be initialized to the number of allocated
+ * elements in that array. Upon successful return, the actual number
+ * of attributes will be overwritten into \c num_attribs. Otherwise,
+ * \c VA_STATUS_ERROR_MAX_NUM_EXCEEDED is returned and \c num_attribs
+ * is adjusted to the number of elements that would be returned if
+ * enough space was available.
+ *
+ * Note: it is perfectly valid to pass NULL to the \c attrib_list
+ * argument when vaQuerySurfaceAttributes() is used to determine the
+ * actual number of elements that need to be allocated.
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] config            the config identifying a codec or a video
+ *     processing pipeline
+ * @param[out] attrib_list      the output array of #VASurfaceAttrib elements
+ * @param[in,out] num_attribs   the number of elements allocated on
+ *      input, the number of elements actually filled in output
+ */
+VAStatus
+vaQuerySurfaceAttributes(
+    VADisplay           dpy,
+    VAConfigID          config,
+    VASurfaceAttrib    *attrib_list,
+    unsigned int       *num_attribs
+);
+
+/**
+ * \brief Creates an array of surfaces
+ *
+ * Creates an array of surfaces. The optional list of attributes shall
+ * be constructed and validated through vaGetSurfaceAttributes() or
+ * constructed based based on what the underlying hardware could
+ * expose through vaQuerySurfaceAttributes().
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] format            the desired surface format. See \c VA_RT_FORMAT_*
+ * @param[in] width             the surface width
+ * @param[in] height            the surface height
+ * @param[out] surfaces         the array of newly created surfaces
+ * @param[in] num_surfaces      the number of surfaces to create
+ * @param[in] attrib_list       the list of (optional) attributes, or \c NULL
+ * @param[in] num_attribs       the number of attributes supplied in
+ *     \c attrib_list, or zero
+ */
+VAStatus
+vaCreateSurfaces(
+    VADisplay           dpy,
+    unsigned int        format,
+    unsigned int        width,
+    unsigned int        height,
+    VASurfaceID        *surfaces,
+    unsigned int        num_surfaces,
+    VASurfaceAttrib    *attrib_list,
+    unsigned int        num_attribs
+);
+    
+/**
+ * vaDestroySurfaces - Destroy resources associated with surfaces. 
+ *  Surfaces can only be destroyed after the context associated has been 
+ *  destroyed.  
+ *  dpy: display
+ *  surfaces: array of surfaces to destroy
+ *  num_surfaces: number of surfaces in the array to be destroyed.
+ */
+VAStatus vaDestroySurfaces (
+    VADisplay dpy,
+    VASurfaceID *surfaces,
+    int num_surfaces
+);
+
+#define VA_PROGRESSIVE 0x1
+/**
+ * vaCreateContext - Create a context
+ *  dpy: display
+ *  config_id: configuration for the context
+ *  picture_width: coded picture width
+ *  picture_height: coded picture height
+ *  flag: any combination of the following:
+ *    VA_PROGRESSIVE (only progressive frame pictures in the sequence when set)
+ *  render_targets: render targets (surfaces) tied to the context
+ *  num_render_targets: number of render targets in the above array
+ *  context: created context id upon return
+ */
+VAStatus vaCreateContext (
+    VADisplay dpy,
+    VAConfigID config_id,
+    int picture_width,
+    int picture_height,
+    int flag,
+    VASurfaceID *render_targets,
+    int num_render_targets,
+    VAContextID *context		/* out */
+);
+
+/**
+ * vaDestroyContext - Destroy a context 
+ *  dpy: display
+ *  context: context to be destroyed
+ */
+VAStatus vaDestroyContext (
+    VADisplay dpy,
+    VAContextID context
+);
+
+/**
+ * Buffers 
+ * Buffers are used to pass various types of data from the
+ * client to the server. The server maintains a data store
+ * for each buffer created, and the client idenfies a buffer
+ * through a unique buffer id assigned by the server.
+ */
+
+typedef VAGenericID VABufferID;
+
+typedef enum
+{
+    VAPictureParameterBufferType	= 0,
+    VAIQMatrixBufferType		= 1,
+    VABitPlaneBufferType		= 2,
+    VASliceGroupMapBufferType		= 3,
+    VASliceParameterBufferType		= 4,
+    VASliceDataBufferType		= 5,
+    VAMacroblockParameterBufferType	= 6,
+    VAResidualDataBufferType		= 7,
+    VADeblockingParameterBufferType	= 8,
+    VAImageBufferType			= 9,
+    VAProtectedSliceDataBufferType	= 10,
+    VAQMatrixBufferType                 = 11,
+    VAHuffmanTableBufferType            = 12,
+    VAProbabilityBufferType             = 13,
+
+/* Following are encode buffer types */
+    VAEncCodedBufferType		= 21,
+    VAEncSequenceParameterBufferType	= 22,
+    VAEncPictureParameterBufferType	= 23,
+    VAEncSliceParameterBufferType	= 24,
+    VAEncPackedHeaderParameterBufferType = 25,
+    VAEncPackedHeaderDataBufferType     = 26,
+    VAEncMiscParameterBufferType	= 27,
+    VAEncMacroblockParameterBufferType	= 28,
+    VAEncMacroblockMapBufferType        = 29,
+/* Following are video processing buffer types */
+    /**
+     * \brief Video processing pipeline parameter buffer.
+     *
+     * This buffer describes the video processing pipeline. See
+     * #VAProcPipelineParameterBuffer for details.
+     */
+    VAProcPipelineParameterBufferType   = 41,
+    /**
+     * \brief Video filter parameter buffer.
+     *
+     * This buffer describes the video filter parameters. All buffers
+     * inherit from #VAProcFilterParameterBufferBase, thus including
+     * a unique filter buffer type.
+     *
+     * The default buffer used by most filters is #VAProcFilterParameterBuffer.
+     * Filters requiring advanced parameters include, but are not limited to,
+     * deinterlacing (#VAProcFilterParameterBufferDeinterlacing),
+     * color balance (#VAProcFilterParameterBufferColorBalance), etc.
+     */
+    VAProcFilterParameterBufferType     = 42,
+    VABufferTypeMax
+} VABufferType;
+
+typedef enum
+{
+    VAEncMiscParameterTypeFrameRate 	= 0,
+    VAEncMiscParameterTypeRateControl  	= 1,
+    VAEncMiscParameterTypeMaxSliceSize	= 2,
+    VAEncMiscParameterTypeAIR    	= 3,
+    /** \brief Buffer type used to express a maximum frame size (in bits). */
+    VAEncMiscParameterTypeMaxFrameSize  = 4,
+    /** \brief Buffer type used for HRD parameters. */
+    VAEncMiscParameterTypeHRD           = 5,
+    VAEncMiscParameterTypeQualityLevel  = 6,
+} VAEncMiscParameterType;
+
+/** \brief Packed header type. */
+typedef enum {
+    /** \brief Packed sequence header. */
+    VAEncPackedHeaderSequence   = 1,
+    /** \brief Packed picture header. */
+    VAEncPackedHeaderPicture    = 2,
+    /** \brief Packed slice header. */
+    VAEncPackedHeaderSlice      = 3,
+    /** 
+     * \brief Packed raw header. 
+     * 
+     * Packed raw data header can be used by the client to insert a header  
+     * into the bitstream data buffer at the point it is passed, the driver 
+     * will handle the raw packed header based on "has_emulation_bytes" field
+     * in the packed header parameter structure.
+     */
+    VAEncPackedHeaderRawData    = 4,
+    /** \brief Misc packed header. See codec-specific definitions. */
+    VAEncPackedHeaderMiscMask   = 0x80000000,
+} VAEncPackedHeaderType;
+
+/** \brief Packed header parameter. */
+typedef struct _VAEncPackedHeaderParameterBuffer {
+    /** Type of the packed header buffer. See #VAEncPackedHeaderType. */
+    unsigned int                type;
+    /** \brief Size of the #VAEncPackedHeaderDataBuffer in bits. */
+    unsigned int                bit_length;
+    /** \brief Flag: buffer contains start code emulation prevention bytes? */
+    unsigned char               has_emulation_bytes;
+} VAEncPackedHeaderParameterBuffer;
+
+/**
+ *  For application, e.g. set a new bitrate
+ *    VABufferID buf_id;
+ *    VAEncMiscParameterBuffer *misc_param;
+ *    VAEncMiscParameterRateControl *misc_rate_ctrl;
+ * 
+ *    vaCreateBuffer(dpy, context, VAEncMiscParameterBufferType,
+ *              sizeof(VAEncMiscParameterBuffer) + sizeof(VAEncMiscParameterRateControl),
+ *              1, NULL, &buf_id);
+ *
+ *    vaMapBuffer(dpy,buf_id,(void **)&misc_param);
+ *    misc_param->type = VAEncMiscParameterTypeRateControl;
+ *    misc_rate_ctrl= (VAEncMiscParameterRateControl *)misc_param->data;
+ *    misc_rate_ctrl->bits_per_second = 6400000;
+ *    vaUnmapBuffer(dpy, buf_id);
+ *    vaRenderPicture(dpy, context, &buf_id, 1);
+ */
+typedef struct _VAEncMiscParameterBuffer
+{
+    VAEncMiscParameterType type;
+    unsigned int data[0];
+} VAEncMiscParameterBuffer;
+
+
+/** \brief Rate control parameters */
+typedef struct _VAEncMiscParameterRateControl
+{
+    /* this is the maximum bit-rate to be constrained by the rate control implementation */
+    unsigned int bits_per_second;
+    /* this is the bit-rate the rate control is targeting, as a percentage of the maximum
+     * bit-rate for example if target_percentage is 95 then the rate control will target
+     * a bit-rate that is 95% of the maximum bit-rate
+     */
+    unsigned int target_percentage;
+    /* windows size in milliseconds. For example if this is set to 500,
+     * then the rate control will guarantee the target bit-rate over a 500 ms window
+     */
+    unsigned int window_size;
+    /* initial QP at I frames */
+    unsigned int initial_qp;
+    unsigned int min_qp;
+    unsigned int basic_unit_size;
+    union
+    {
+        struct
+        {
+            unsigned int reset : 1;
+            unsigned int disable_frame_skip : 1; /* Disable frame skip in rate control mode */
+            unsigned int disable_bit_stuffing : 1; /* Disable bit stuffing in rate control mode */
+        } bits;
+        unsigned int value;
+    } rc_flags;
+} VAEncMiscParameterRateControl;
+
+typedef struct _VAEncMiscParameterFrameRate
+{
+    unsigned int framerate;
+} VAEncMiscParameterFrameRate;
+
+/**
+ * Allow a maximum slice size to be specified (in bits).
+ * The encoder will attempt to make sure that individual slices do not exceed this size
+ * Or to signal applicate if the slice size exceed this size, see "status" of VACodedBufferSegment
+ */
+typedef struct _VAEncMiscParameterMaxSliceSize
+{
+    unsigned int max_slice_size;
+} VAEncMiscParameterMaxSliceSize;
+
+typedef struct _VAEncMiscParameterAIR
+{
+    unsigned int air_num_mbs;
+    unsigned int air_threshold;
+    unsigned int air_auto; /* if set to 1 then hardware auto-tune the AIR threshold */
+} VAEncMiscParameterAIR;
+
+typedef struct _VAEncMiscParameterHRD
+{
+    unsigned int initial_buffer_fullness;       /* in bits */
+    unsigned int buffer_size;                   /* in bits */
+} VAEncMiscParameterHRD;
+
+/**
+ * \brief Defines a maximum frame size (in bits).
+ *
+ * This misc parameter buffer defines the maximum size of a frame (in
+ * bits). The encoder will try to make sure that each frame does not
+ * exceed this size. Otherwise, if the frame size exceeds this size,
+ * the \c status flag of #VACodedBufferSegment will contain
+ * #VA_CODED_BUF_STATUS_FRAME_SIZE_OVERFLOW.
+ */
+typedef struct _VAEncMiscParameterBufferMaxFrameSize {
+    /** \brief Type. Shall be set to #VAEncMiscParameterTypeMaxFrameSize. */
+    VAEncMiscParameterType      type;
+    /** \brief Maximum size of a frame (in bits). */
+    unsigned int                max_frame_size;
+} VAEncMiscParameterBufferMaxFrameSize;
+
+/**
+ * \brief Encoding quality level.
+ *
+ * The encoding quality could be set through this structure, if the implementation  
+ * supports multiple quality levels. The quality level set through this structure is 
+ * persistent over the entire coded sequence, or until a new structure is being sent.
+ * The quality level range can be queried through the VAConfigAttribEncQualityRange 
+ * attribute. A lower value means higher quality, and a value of 1 represents the highest 
+ * quality. The quality level setting is used as a trade-off between quality and speed/power 
+ * consumption, with higher quality corresponds to lower speed and higher power consumption. 
+ */
+typedef struct _VAEncMiscParameterBufferQualityLevel {
+    /** \brief Encoding quality level setting. When set to 0, default quality
+     * level is used.
+     */
+    unsigned int                quality_level;
+} VAEncMiscParameterBufferQualityLevel;
+
+/* 
+ * There will be cases where the bitstream buffer will not have enough room to hold
+ * the data for the entire slice, and the following flags will be used in the slice
+ * parameter to signal to the server for the possible cases.
+ * If a slice parameter buffer and slice data buffer pair is sent to the server with 
+ * the slice data partially in the slice data buffer (BEGIN and MIDDLE cases below), 
+ * then a slice parameter and data buffer needs to be sent again to complete this slice. 
+ */
+#define VA_SLICE_DATA_FLAG_ALL		0x00	/* whole slice is in the buffer */
+#define VA_SLICE_DATA_FLAG_BEGIN	0x01	/* The beginning of the slice is in the buffer but the end if not */
+#define VA_SLICE_DATA_FLAG_MIDDLE	0x02	/* Neither beginning nor end of the slice is in the buffer */
+#define VA_SLICE_DATA_FLAG_END		0x04	/* end of the slice is in the buffer */
+
+/* Codec-independent Slice Parameter Buffer base */
+typedef struct _VASliceParameterBufferBase
+{
+    unsigned int slice_data_size;	/* number of bytes in the slice data buffer for this slice */
+    unsigned int slice_data_offset;	/* the offset to the first byte of slice data */
+    unsigned int slice_data_flag;	/* see VA_SLICE_DATA_FLAG_XXX definitions */
+} VASliceParameterBufferBase;
+
+
+/****************************
+ * JEPG data structure
+ ***************************/
+typedef struct _VAQMatrixBufferJPEG
+{
+    int load_lum_quantiser_matrix;
+    int load_chroma_quantiser_matrix;
+    unsigned char lum_quantiser_matrix[64];
+    unsigned char chroma_quantiser_matrix[64];
+} VAQMatrixBufferJPEG;
+
+typedef struct _VAEncPictureParameterBufferJPEG
+{
+    VASurfaceID reconstructed_picture;
+    unsigned short picture_width;
+    unsigned short picture_height;
+    VABufferID coded_buf;
+} VAEncPictureParameterBufferJPEG;
+
+#include <va/va_dec_jpeg.h>
+
+/****************************
+ * MPEG-2 data structures
+ ****************************/
+ 
+/* MPEG-2 Picture Parameter Buffer */
+/* 
+ * For each frame or field, and before any slice data, a single
+ * picture parameter buffer must be send.
+ */
+typedef struct _VAPictureParameterBufferMPEG2
+{
+    unsigned short horizontal_size;
+    unsigned short vertical_size;
+    VASurfaceID forward_reference_picture;
+    VASurfaceID backward_reference_picture;
+    /* meanings of the following fields are the same as in the standard */
+    int picture_coding_type;
+    int f_code; /* pack all four fcode into this */
+    union {
+        struct {
+            unsigned int intra_dc_precision		: 2; 
+            unsigned int picture_structure		: 2; 
+            unsigned int top_field_first		: 1; 
+            unsigned int frame_pred_frame_dct		: 1; 
+            unsigned int concealment_motion_vectors	: 1;
+            unsigned int q_scale_type			: 1;
+            unsigned int intra_vlc_format		: 1;
+            unsigned int alternate_scan			: 1;
+            unsigned int repeat_first_field		: 1;
+            unsigned int progressive_frame		: 1;
+            unsigned int is_first_field			: 1; /* indicate whether the current field
+                                                              * is the first field for field picture
+                                                              */
+        } bits;
+        unsigned int value;
+    } picture_coding_extension;
+} VAPictureParameterBufferMPEG2;
+
+/** MPEG-2 Inverse Quantization Matrix Buffer */
+typedef struct _VAIQMatrixBufferMPEG2
+{
+    /** \brief Same as the MPEG-2 bitstream syntax element. */
+    int load_intra_quantiser_matrix;
+    /** \brief Same as the MPEG-2 bitstream syntax element. */
+    int load_non_intra_quantiser_matrix;
+    /** \brief Same as the MPEG-2 bitstream syntax element. */
+    int load_chroma_intra_quantiser_matrix;
+    /** \brief Same as the MPEG-2 bitstream syntax element. */
+    int load_chroma_non_intra_quantiser_matrix;
+    /** \brief Luminance intra matrix, in zig-zag scan order. */
+    unsigned char intra_quantiser_matrix[64];
+    /** \brief Luminance non-intra matrix, in zig-zag scan order. */
+    unsigned char non_intra_quantiser_matrix[64];
+    /** \brief Chroma intra matrix, in zig-zag scan order. */
+    unsigned char chroma_intra_quantiser_matrix[64];
+    /** \brief Chroma non-intra matrix, in zig-zag scan order. */
+    unsigned char chroma_non_intra_quantiser_matrix[64];
+} VAIQMatrixBufferMPEG2;
+
+/** MPEG-2 Slice Parameter Buffer */
+typedef struct _VASliceParameterBufferMPEG2
+{
+    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
+    unsigned int slice_data_offset;/* the offset to the first byte of slice data */
+    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
+    unsigned int macroblock_offset;/* the offset to the first bit of MB from the first byte of slice data */
+    unsigned int slice_horizontal_position;
+    unsigned int slice_vertical_position;
+    int quantiser_scale_code;
+    int intra_slice_flag;
+} VASliceParameterBufferMPEG2;
+
+/** MPEG-2 Macroblock Parameter Buffer */
+typedef struct _VAMacroblockParameterBufferMPEG2
+{
+    unsigned short macroblock_address;
+    /* 
+     * macroblock_address (in raster scan order)
+     * top-left: 0
+     * bottom-right: picture-height-in-mb*picture-width-in-mb - 1
+     */
+    unsigned char macroblock_type;  /* see definition below */
+    union {
+        struct {
+            unsigned int frame_motion_type		: 2; 
+            unsigned int field_motion_type		: 2; 
+            unsigned int dct_type			: 1; 
+        } bits;
+        unsigned int value;
+    } macroblock_modes;
+    unsigned char motion_vertical_field_select; 
+    /* 
+     * motion_vertical_field_select:
+     * see section 6.3.17.2 in the spec
+     * only the lower 4 bits are used
+     * bit 0: first vector forward
+     * bit 1: first vector backward
+     * bit 2: second vector forward
+     * bit 3: second vector backward
+     */
+    short PMV[2][2][2]; /* see Table 7-7 in the spec */
+    unsigned short coded_block_pattern;
+    /* 
+     * The bitplanes for coded_block_pattern are described 
+     * in Figure 6.10-12 in the spec
+     */
+     
+    /* Number of skipped macroblocks after this macroblock */
+    unsigned short num_skipped_macroblocks;
+} VAMacroblockParameterBufferMPEG2;
+
+/* 
+ * OR'd flags for macroblock_type (section 6.3.17.1 in the spec)
+ */
+#define VA_MB_TYPE_MOTION_FORWARD	0x02
+#define VA_MB_TYPE_MOTION_BACKWARD	0x04
+#define VA_MB_TYPE_MOTION_PATTERN	0x08
+#define VA_MB_TYPE_MOTION_INTRA		0x10
+
+/**
+ * MPEG-2 Residual Data Buffer 
+ * For each macroblock, there wil be 64 shorts (16-bit) in the 
+ * residual data buffer
+ */
+
+/****************************
+ * MPEG-4 Part 2 data structures
+ ****************************/
+ 
+/* MPEG-4 Picture Parameter Buffer */
+/* 
+ * For each frame or field, and before any slice data, a single
+ * picture parameter buffer must be send.
+ */
+typedef struct _VAPictureParameterBufferMPEG4
+{
+    unsigned short vop_width;
+    unsigned short vop_height;
+    VASurfaceID forward_reference_picture;
+    VASurfaceID backward_reference_picture;
+    union {
+        struct {
+            unsigned int short_video_header		: 1; 
+            unsigned int chroma_format			: 2; 
+            unsigned int interlaced			: 1; 
+            unsigned int obmc_disable			: 1; 
+            unsigned int sprite_enable			: 2; 
+            unsigned int sprite_warping_accuracy	: 2; 
+            unsigned int quant_type			: 1; 
+            unsigned int quarter_sample			: 1; 
+            unsigned int data_partitioned		: 1; 
+            unsigned int reversible_vlc			: 1; 
+            unsigned int resync_marker_disable		: 1; 
+        } bits;
+        unsigned int value;
+    } vol_fields;
+    unsigned char no_of_sprite_warping_points;
+    short sprite_trajectory_du[3];
+    short sprite_trajectory_dv[3];
+    unsigned char quant_precision;
+    union {
+        struct {
+            unsigned int vop_coding_type		: 2; 
+            unsigned int backward_reference_vop_coding_type	: 2; 
+            unsigned int vop_rounding_type		: 1; 
+            unsigned int intra_dc_vlc_thr		: 3; 
+            unsigned int top_field_first		: 1; 
+            unsigned int alternate_vertical_scan_flag	: 1; 
+        } bits;
+        unsigned int value;
+    } vop_fields;
+    unsigned char vop_fcode_forward;
+    unsigned char vop_fcode_backward;
+    unsigned short vop_time_increment_resolution;
+    /* short header related */
+    unsigned char num_gobs_in_vop;
+    unsigned char num_macroblocks_in_gob;
+    /* for direct mode prediction */
+    short TRB;
+    short TRD;
+} VAPictureParameterBufferMPEG4;
+
+/** MPEG-4 Inverse Quantization Matrix Buffer */
+typedef struct _VAIQMatrixBufferMPEG4
+{
+    /** Same as the MPEG-4:2 bitstream syntax element. */
+    int load_intra_quant_mat;
+    /** Same as the MPEG-4:2 bitstream syntax element. */
+    int load_non_intra_quant_mat;
+    /** The matrix for intra blocks, in zig-zag scan order. */
+    unsigned char intra_quant_mat[64];
+    /** The matrix for non-intra blocks, in zig-zag scan order. */
+    unsigned char non_intra_quant_mat[64];
+} VAIQMatrixBufferMPEG4;
+
+/** MPEG-4 Slice Parameter Buffer */
+typedef struct _VASliceParameterBufferMPEG4
+{
+    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
+    unsigned int slice_data_offset;/* the offset to the first byte of slice data */
+    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
+    unsigned int macroblock_offset;/* the offset to the first bit of MB from the first byte of slice data */
+    unsigned int macroblock_number;
+    int quant_scale;
+} VASliceParameterBufferMPEG4;
+
+/**
+ VC-1 data structures
+*/
+
+typedef enum   /* see 7.1.1.32 */
+{
+    VAMvMode1Mv                        = 0,
+    VAMvMode1MvHalfPel                 = 1,
+    VAMvMode1MvHalfPelBilinear         = 2,
+    VAMvModeMixedMv                    = 3,
+    VAMvModeIntensityCompensation      = 4 
+} VAMvModeVC1;
+
+/** VC-1 Picture Parameter Buffer */
+/* 
+ * For each picture, and before any slice data, a picture parameter
+ * buffer must be send. Multiple picture parameter buffers may be
+ * sent for a single picture. In that case picture parameters will
+ * apply to all slice data that follow it until a new picture
+ * parameter buffer is sent.
+ *
+ * Notes:
+ *   pic_quantizer_type should be set to the applicable quantizer
+ *   type as defined by QUANTIZER (J.1.19) and either
+ *   PQUANTIZER (7.1.1.8) or PQINDEX (7.1.1.6)
+ */
+typedef struct _VAPictureParameterBufferVC1
+{
+    VASurfaceID forward_reference_picture;
+    VASurfaceID backward_reference_picture;
+    /* if out-of-loop post-processing is done on the render
+       target, then we need to keep the in-loop decoded 
+       picture as a reference picture */
+    VASurfaceID inloop_decoded_picture;
+
+    /* sequence layer for AP or meta data for SP and MP */
+    union {
+        struct {
+            unsigned int pulldown	: 1; /* SEQUENCE_LAYER::PULLDOWN */
+            unsigned int interlace	: 1; /* SEQUENCE_LAYER::INTERLACE */
+            unsigned int tfcntrflag	: 1; /* SEQUENCE_LAYER::TFCNTRFLAG */
+            unsigned int finterpflag	: 1; /* SEQUENCE_LAYER::FINTERPFLAG */
+            unsigned int psf		: 1; /* SEQUENCE_LAYER::PSF */
+            unsigned int multires	: 1; /* METADATA::MULTIRES */
+            unsigned int overlap	: 1; /* METADATA::OVERLAP */
+            unsigned int syncmarker	: 1; /* METADATA::SYNCMARKER */
+            unsigned int rangered	: 1; /* METADATA::RANGERED */
+            unsigned int max_b_frames	: 3; /* METADATA::MAXBFRAMES */
+            unsigned int profile	: 2; /* SEQUENCE_LAYER::PROFILE or The MSB of METADATA::PROFILE */
+        } bits;
+        unsigned int value;
+    } sequence_fields;
+
+    unsigned short coded_width;		/* ENTRY_POINT_LAYER::CODED_WIDTH */
+    unsigned short coded_height;	/* ENTRY_POINT_LAYER::CODED_HEIGHT */
+    union {
+	struct {
+            unsigned int broken_link	: 1; /* ENTRY_POINT_LAYER::BROKEN_LINK */
+            unsigned int closed_entry	: 1; /* ENTRY_POINT_LAYER::CLOSED_ENTRY */
+            unsigned int panscan_flag	: 1; /* ENTRY_POINT_LAYER::PANSCAN_FLAG */
+            unsigned int loopfilter	: 1; /* ENTRY_POINT_LAYER::LOOPFILTER */
+	} bits;
+	unsigned int value;
+    } entrypoint_fields;
+    unsigned char conditional_overlap_flag; /* ENTRY_POINT_LAYER::CONDOVER */
+    unsigned char fast_uvmc_flag;	/* ENTRY_POINT_LAYER::FASTUVMC */
+    union {
+        struct {
+            unsigned int luma_flag	: 1; /* ENTRY_POINT_LAYER::RANGE_MAPY_FLAG */
+            unsigned int luma		: 3; /* ENTRY_POINT_LAYER::RANGE_MAPY */
+            unsigned int chroma_flag	: 1; /* ENTRY_POINT_LAYER::RANGE_MAPUV_FLAG */
+            unsigned int chroma		: 3; /* ENTRY_POINT_LAYER::RANGE_MAPUV */
+        } bits;
+        unsigned int value;
+    } range_mapping_fields;
+
+    unsigned char b_picture_fraction;	/* PICTURE_LAYER::BFRACTION */
+    unsigned char cbp_table;		/* PICTURE_LAYER::CBPTAB/ICBPTAB */
+    unsigned char mb_mode_table;	/* PICTURE_LAYER::MBMODETAB */
+    unsigned char range_reduction_frame;/* PICTURE_LAYER::RANGEREDFRM */
+    unsigned char rounding_control;	/* PICTURE_LAYER::RNDCTRL */
+    unsigned char post_processing;	/* PICTURE_LAYER::POSTPROC */
+    unsigned char picture_resolution_index;	/* PICTURE_LAYER::RESPIC */
+    unsigned char luma_scale;		/* PICTURE_LAYER::LUMSCALE */
+    unsigned char luma_shift;		/* PICTURE_LAYER::LUMSHIFT */
+    union {
+        struct {
+            unsigned int picture_type		: 3; /* PICTURE_LAYER::PTYPE */
+            unsigned int frame_coding_mode	: 3; /* PICTURE_LAYER::FCM */
+            unsigned int top_field_first	: 1; /* PICTURE_LAYER::TFF */
+            unsigned int is_first_field		: 1; /* set to 1 if it is the first field */
+            unsigned int intensity_compensation	: 1; /* PICTURE_LAYER::INTCOMP */
+        } bits;
+        unsigned int value;
+    } picture_fields;
+    union {
+        struct {
+            unsigned int mv_type_mb	: 1; 	/* PICTURE::MVTYPEMB */
+            unsigned int direct_mb	: 1; 	/* PICTURE::DIRECTMB */
+            unsigned int skip_mb	: 1; 	/* PICTURE::SKIPMB */
+            unsigned int field_tx	: 1; 	/* PICTURE::FIELDTX */
+            unsigned int forward_mb	: 1;	/* PICTURE::FORWARDMB */
+            unsigned int ac_pred	: 1;	/* PICTURE::ACPRED */
+            unsigned int overflags	: 1;	/* PICTURE::OVERFLAGS */
+        } flags;
+        unsigned int value;
+    } raw_coding;
+    union {
+        struct {
+            unsigned int bp_mv_type_mb   : 1;    /* PICTURE::MVTYPEMB */
+            unsigned int bp_direct_mb    : 1;    /* PICTURE::DIRECTMB */
+            unsigned int bp_skip_mb      : 1;    /* PICTURE::SKIPMB */  
+            unsigned int bp_field_tx     : 1;    /* PICTURE::FIELDTX */ 
+            unsigned int bp_forward_mb   : 1;    /* PICTURE::FORWARDMB */
+            unsigned int bp_ac_pred      : 1;    /* PICTURE::ACPRED */   
+            unsigned int bp_overflags    : 1;    /* PICTURE::OVERFLAGS */
+        } flags;
+        unsigned int value;
+    } bitplane_present; /* signal what bitplane is being passed via the bitplane buffer */
+    union {
+        struct {
+            unsigned int reference_distance_flag : 1;/* PICTURE_LAYER::REFDIST_FLAG */
+            unsigned int reference_distance	: 5;/* PICTURE_LAYER::REFDIST */
+            unsigned int num_reference_pictures: 1;/* PICTURE_LAYER::NUMREF */
+            unsigned int reference_field_pic_indicator	: 1;/* PICTURE_LAYER::REFFIELD */
+        } bits;
+        unsigned int value;
+    } reference_fields;
+    union {
+        struct {
+            unsigned int mv_mode		: 3; /* PICTURE_LAYER::MVMODE */
+            unsigned int mv_mode2		: 3; /* PICTURE_LAYER::MVMODE2 */
+            unsigned int mv_table		: 3; /* PICTURE_LAYER::MVTAB/IMVTAB */
+            unsigned int two_mv_block_pattern_table: 2; /* PICTURE_LAYER::2MVBPTAB */
+            unsigned int four_mv_switch		: 1; /* PICTURE_LAYER::4MVSWITCH */
+            unsigned int four_mv_block_pattern_table : 2; /* PICTURE_LAYER::4MVBPTAB */
+            unsigned int extended_mv_flag	: 1; /* ENTRY_POINT_LAYER::EXTENDED_MV */
+            unsigned int extended_mv_range	: 2; /* PICTURE_LAYER::MVRANGE */
+            unsigned int extended_dmv_flag	: 1; /* ENTRY_POINT_LAYER::EXTENDED_DMV */
+            unsigned int extended_dmv_range	: 2; /* PICTURE_LAYER::DMVRANGE */
+        } bits;
+        unsigned int value;
+    } mv_fields;
+    union {
+        struct {
+            unsigned int dquant	: 2; 	/* ENTRY_POINT_LAYER::DQUANT */
+            unsigned int quantizer     : 2; 	/* ENTRY_POINT_LAYER::QUANTIZER */
+            unsigned int half_qp	: 1; 	/* PICTURE_LAYER::HALFQP */
+            unsigned int pic_quantizer_scale : 5;/* PICTURE_LAYER::PQUANT */
+            unsigned int pic_quantizer_type : 1;/* PICTURE_LAYER::PQUANTIZER */
+            unsigned int dq_frame	: 1; 	/* VOPDQUANT::DQUANTFRM */
+            unsigned int dq_profile	: 2; 	/* VOPDQUANT::DQPROFILE */
+            unsigned int dq_sb_edge	: 2; 	/* VOPDQUANT::DQSBEDGE */
+            unsigned int dq_db_edge 	: 2; 	/* VOPDQUANT::DQDBEDGE */
+            unsigned int dq_binary_level : 1; 	/* VOPDQUANT::DQBILEVEL */
+            unsigned int alt_pic_quantizer : 5;/* VOPDQUANT::ALTPQUANT */
+        } bits;
+        unsigned int value;
+    } pic_quantizer_fields;
+    union {
+        struct {
+            unsigned int variable_sized_transform_flag	: 1;/* ENTRY_POINT_LAYER::VSTRANSFORM */
+            unsigned int mb_level_transform_type_flag	: 1;/* PICTURE_LAYER::TTMBF */
+            unsigned int frame_level_transform_type	: 2;/* PICTURE_LAYER::TTFRM */
+            unsigned int transform_ac_codingset_idx1	: 2;/* PICTURE_LAYER::TRANSACFRM */
+            unsigned int transform_ac_codingset_idx2	: 2;/* PICTURE_LAYER::TRANSACFRM2 */
+            unsigned int intra_transform_dc_table	: 1;/* PICTURE_LAYER::TRANSDCTAB */
+        } bits;
+        unsigned int value;
+    } transform_fields;
+} VAPictureParameterBufferVC1;
+
+/** VC-1 Bitplane Buffer
+There will be at most three bitplanes coded in any picture header. To send 
+the bitplane data more efficiently, each byte is divided in two nibbles, with
+each nibble carrying three bitplanes for one macroblock.  The following table
+shows the bitplane data arrangement within each nibble based on the picture
+type.
+
+Picture Type	Bit3		Bit2		Bit1		Bit0
+I or BI				OVERFLAGS	ACPRED		FIELDTX
+P				MYTYPEMB	SKIPMB		DIRECTMB
+B				FORWARDMB	SKIPMB		DIRECTMB
+
+Within each byte, the lower nibble is for the first MB and the upper nibble is 
+for the second MB.  E.g. the lower nibble of the first byte in the bitplane
+buffer is for Macroblock #1 and the upper nibble of the first byte is for 
+Macroblock #2 in the first row.
+*/
+
+/* VC-1 Slice Parameter Buffer */
+typedef struct _VASliceParameterBufferVC1
+{
+    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
+    unsigned int slice_data_offset;/* the offset to the first byte of slice data */
+    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
+    unsigned int macroblock_offset;/* the offset to the first bit of MB from the first byte of slice data */
+    unsigned int slice_vertical_position;
+} VASliceParameterBufferVC1;
+
+/* VC-1 Slice Data Buffer */
+/* 
+This is simplely a buffer containing raw bit-stream bytes 
+*/
+
+/****************************
+ * H.264/AVC data structures
+ ****************************/
+
+typedef struct _VAPictureH264
+{
+    VASurfaceID picture_id;
+    unsigned int frame_idx;
+    unsigned int flags;
+    signed int TopFieldOrderCnt;
+    signed int BottomFieldOrderCnt;
+} VAPictureH264;
+/* flags in VAPictureH264 could be OR of the following */
+#define VA_PICTURE_H264_INVALID			0x00000001
+#define VA_PICTURE_H264_TOP_FIELD		0x00000002
+#define VA_PICTURE_H264_BOTTOM_FIELD		0x00000004
+#define VA_PICTURE_H264_SHORT_TERM_REFERENCE	0x00000008
+#define VA_PICTURE_H264_LONG_TERM_REFERENCE	0x00000010
+
+/** H.264 Picture Parameter Buffer */
+/* 
+ * For each picture, and before any slice data, a single
+ * picture parameter buffer must be send.
+ */
+typedef struct _VAPictureParameterBufferH264
+{
+    VAPictureH264 CurrPic;
+    VAPictureH264 ReferenceFrames[16];	/* in DPB */
+    unsigned short picture_width_in_mbs_minus1;
+    unsigned short picture_height_in_mbs_minus1;
+    unsigned char bit_depth_luma_minus8;
+    unsigned char bit_depth_chroma_minus8;
+    unsigned char num_ref_frames;
+    union {
+        struct {
+            unsigned int chroma_format_idc			: 2; 
+            unsigned int residual_colour_transform_flag		: 1; 
+            unsigned int gaps_in_frame_num_value_allowed_flag	: 1; 
+            unsigned int frame_mbs_only_flag			: 1; 
+            unsigned int mb_adaptive_frame_field_flag		: 1; 
+            unsigned int direct_8x8_inference_flag		: 1; 
+            unsigned int MinLumaBiPredSize8x8			: 1; /* see A.3.3.2 */
+            unsigned int log2_max_frame_num_minus4		: 4;
+            unsigned int pic_order_cnt_type			: 2;
+            unsigned int log2_max_pic_order_cnt_lsb_minus4	: 4;
+            unsigned int delta_pic_order_always_zero_flag	: 1;
+        } bits;
+        unsigned int value;
+    } seq_fields;
+    unsigned char num_slice_groups_minus1;
+    unsigned char slice_group_map_type;
+    unsigned short slice_group_change_rate_minus1;
+    signed char pic_init_qp_minus26;
+    signed char pic_init_qs_minus26;
+    signed char chroma_qp_index_offset;
+    signed char second_chroma_qp_index_offset;
+    union {
+        struct {
+            unsigned int entropy_coding_mode_flag	: 1;
+            unsigned int weighted_pred_flag		: 1;
+            unsigned int weighted_bipred_idc		: 2;
+            unsigned int transform_8x8_mode_flag	: 1;
+            unsigned int field_pic_flag			: 1;
+            unsigned int constrained_intra_pred_flag	: 1;
+            unsigned int pic_order_present_flag			: 1;
+            unsigned int deblocking_filter_control_present_flag : 1;
+            unsigned int redundant_pic_cnt_present_flag		: 1;
+            unsigned int reference_pic_flag			: 1; /* nal_ref_idc != 0 */
+        } bits;
+        unsigned int value;
+    } pic_fields;
+    unsigned short frame_num;
+} VAPictureParameterBufferH264;
+
+/** H.264 Inverse Quantization Matrix Buffer */
+typedef struct _VAIQMatrixBufferH264
+{
+    /** \brief 4x4 scaling list, in raster scan order. */
+    unsigned char ScalingList4x4[6][16];
+    /** \brief 8x8 scaling list, in raster scan order. */
+    unsigned char ScalingList8x8[2][64];
+} VAIQMatrixBufferH264;
+
+/**
+ * H.264 Slice Group Map Buffer 
+ * When VAPictureParameterBufferH264::num_slice_group_minus1 is not equal to 0,
+ * A slice group map buffer should be sent for each picture if required. The buffer
+ * is sent only when there is a change in the mapping values.
+ * The slice group map buffer map "map units" to slice groups as specified in 
+ * section 8.2.2 of the H.264 spec. The buffer will contain one byte for each macroblock 
+ * in raster scan order
+ */ 
+
+/** H.264 Slice Parameter Buffer */
+typedef struct _VASliceParameterBufferH264
+{
+    unsigned int slice_data_size;/* number of bytes in the slice data buffer for this slice */
+    /** \brief Byte offset to the NAL Header Unit for this slice. */
+    unsigned int slice_data_offset;
+    unsigned int slice_data_flag; /* see VA_SLICE_DATA_FLAG_XXX defintions */
+    /**
+     * \brief Bit offset from NAL Header Unit to the begining of slice_data().
+     *
+     * This bit offset is relative to and includes the NAL unit byte
+     * and represents the number of bits parsed in the slice_header()
+     * after the removal of any emulation prevention bytes in
+     * there. However, the slice data buffer passed to the hardware is
+     * the original bitstream, thus including any emulation prevention
+     * bytes.
+     */
+    unsigned short slice_data_bit_offset;
+    unsigned short first_mb_in_slice;
+    unsigned char slice_type;
+    unsigned char direct_spatial_mv_pred_flag;
+    unsigned char num_ref_idx_l0_active_minus1;
+    unsigned char num_ref_idx_l1_active_minus1;
+    unsigned char cabac_init_idc;
+    char slice_qp_delta;
+    unsigned char disable_deblocking_filter_idc;
+    char slice_alpha_c0_offset_div2;
+    char slice_beta_offset_div2;
+    VAPictureH264 RefPicList0[32];	/* See 8.2.4.2 */
+    VAPictureH264 RefPicList1[32];	/* See 8.2.4.2 */
+    unsigned char luma_log2_weight_denom;
+    unsigned char chroma_log2_weight_denom;
+    unsigned char luma_weight_l0_flag;
+    short luma_weight_l0[32];
+    short luma_offset_l0[32];
+    unsigned char chroma_weight_l0_flag;
+    short chroma_weight_l0[32][2];
+    short chroma_offset_l0[32][2];
+    unsigned char luma_weight_l1_flag;
+    short luma_weight_l1[32];
+    short luma_offset_l1[32];
+    unsigned char chroma_weight_l1_flag;
+    short chroma_weight_l1[32][2];
+    short chroma_offset_l1[32][2];
+} VASliceParameterBufferH264;
+
+/****************************
+ * Common encode data structures 
+ ****************************/
+typedef enum
+{
+    VAEncPictureTypeIntra		= 0,
+    VAEncPictureTypePredictive		= 1,
+    VAEncPictureTypeBidirectional	= 2,
+} VAEncPictureType;
+
+/* Encode Slice Parameter Buffer */
+typedef struct _VAEncSliceParameterBuffer
+{
+    unsigned int start_row_number;	/* starting MB row number for this slice */
+    unsigned int slice_height;	/* slice height measured in MB */
+    union {
+        struct {
+            unsigned int is_intra	: 1;
+            unsigned int disable_deblocking_filter_idc : 2;
+            unsigned int uses_long_term_ref		:1;
+            unsigned int is_long_term_ref		:1;
+        } bits;
+        unsigned int value;
+    } slice_flags;
+} VAEncSliceParameterBuffer;
+
+
+/****************************
+ * H.263 specific encode data structures
+ ****************************/
+
+typedef struct _VAEncSequenceParameterBufferH263
+{
+    unsigned int intra_period;
+    unsigned int bits_per_second;
+    unsigned int frame_rate;
+    unsigned int initial_qp;
+    unsigned int min_qp;
+} VAEncSequenceParameterBufferH263;
+
+typedef struct _VAEncPictureParameterBufferH263
+{
+    VASurfaceID reference_picture;
+    VASurfaceID reconstructed_picture;
+    VABufferID coded_buf;
+    unsigned short picture_width;
+    unsigned short picture_height;
+    VAEncPictureType picture_type;
+} VAEncPictureParameterBufferH263;
+
+/****************************
+ * MPEG-4 specific encode data structures
+ ****************************/
+
+typedef struct _VAEncSequenceParameterBufferMPEG4
+{
+    unsigned char profile_and_level_indication;
+    unsigned int intra_period;
+    unsigned int video_object_layer_width;
+    unsigned int video_object_layer_height;
+    unsigned int vop_time_increment_resolution;
+    unsigned int fixed_vop_rate;
+    unsigned int fixed_vop_time_increment;
+    unsigned int bits_per_second;
+    unsigned int frame_rate;
+    unsigned int initial_qp;
+    unsigned int min_qp;
+} VAEncSequenceParameterBufferMPEG4;
+
+typedef struct _VAEncPictureParameterBufferMPEG4
+{
+    VASurfaceID reference_picture;
+    VASurfaceID reconstructed_picture;
+    VABufferID coded_buf;
+    unsigned short picture_width;
+    unsigned short picture_height;
+    unsigned int modulo_time_base; /* number of 1s */
+    unsigned int vop_time_increment;
+    VAEncPictureType picture_type;
+} VAEncPictureParameterBufferMPEG4;
+
+
+
+/** Buffer functions */
+
+/**
+ * Creates a buffer for "num_elements" elements of "size" bytes and 
+ * initalize with "data".
+ * if "data" is null, then the contents of the buffer data store
+ * are undefined.
+ * Basically there are two ways to get buffer data to the server side. One is 
+ * to call vaCreateBuffer() with a non-null "data", which results the data being
+ * copied to the data store on the server side.  A different method that 
+ * eliminates this copy is to pass null as "data" when calling vaCreateBuffer(),
+ * and then use vaMapBuffer() to map the data store from the server side to the
+ * client address space for access.
+ *  Note: image buffers are created by the library, not the client. Please see 
+ *        vaCreateImage on how image buffers are managed.
+ */
+VAStatus vaCreateBuffer (
+    VADisplay dpy,
+    VAContextID context,
+    VABufferType type,	/* in */
+    unsigned int size,	/* in */
+    unsigned int num_elements, /* in */
+    void *data,		/* in */
+    VABufferID *buf_id	/* out */
+);
+
+/**
+ * Convey to the server how many valid elements are in the buffer. 
+ * e.g. if multiple slice parameters are being held in a single buffer,
+ * this will communicate to the server the number of slice parameters
+ * that are valid in the buffer.
+ */
+VAStatus vaBufferSetNumElements (
+    VADisplay dpy,
+    VABufferID buf_id,	/* in */
+    unsigned int num_elements /* in */
+);
+
+
+/**
+ * device independent data structure for codedbuffer
+ */
+
+/* 
+ * FICTURE_AVE_QP(bit7-0): The average Qp value used during this frame
+ * LARGE_SLICE(bit8):At least one slice in the current frame was large
+ *              enough for the encoder to attempt to limit its size.
+ * SLICE_OVERFLOW(bit9): At least one slice in the current frame has
+ *              exceeded the maximum slice size specified.
+ * BITRATE_OVERFLOW(bit10): The peak bitrate was exceeded for this frame.
+ * BITRATE_HIGH(bit11): The frame size got within the safety margin of the maximum size (VCM only)
+ * AIR_MB_OVER_THRESHOLD: the number of MBs adapted to Intra MB
+ */
+#define VA_CODED_BUF_STATUS_PICTURE_AVE_QP_MASK         0xff
+#define VA_CODED_BUF_STATUS_LARGE_SLICE_MASK            0x100
+#define VA_CODED_BUF_STATUS_SLICE_OVERFLOW_MASK         0x200
+#define VA_CODED_BUF_STATUS_BITRATE_OVERFLOW		0x400
+#define VA_CODED_BUF_STATUS_BITRATE_HIGH		0x800
+/**
+ * \brief The frame has exceeded the maximum requested size.
+ *
+ * This flag indicates that the encoded frame size exceeds the value
+ * specified through a misc parameter buffer of type
+ * #VAEncMiscParameterTypeMaxFrameSize.
+ */
+#define VA_CODED_BUF_STATUS_FRAME_SIZE_OVERFLOW         0x1000
+#define VA_CODED_BUF_STATUS_AIR_MB_OVER_THRESHOLD	0xff0000
+
+/**
+ * \brief The coded buffer segment contains a single NAL unit. 
+ *
+ * This flag indicates that the coded buffer segment contains a
+ * single NAL unit. This flag might be useful to the user for 
+ * processing the coded buffer.
+ */
+#define VA_CODED_BUF_STATUS_SINGLE_NALU                 0x10000000	
+
+/**
+ * \brief Coded buffer segment.
+ *
+ * #VACodedBufferSegment is an element of a linked list describing
+ * some information on the coded buffer. The coded buffer segment
+ * could contain either a single NAL unit, or more than one NAL unit. 
+ * It is recommended (but not required) to return a single NAL unit 
+ * in a coded buffer segment, and the implementation should set the 
+ * VA_CODED_BUF_STATUS_SINGLE_NALU status flag if that is the case.
+ */
+typedef  struct _VACodedBufferSegment  {
+    /**
+     * \brief Size of the data buffer in this segment (in bytes).
+     */
+    unsigned int        size;
+    /** \brief Bit offset into the data buffer where the video data starts. */
+    unsigned int        bit_offset;
+    /** \brief Status set by the driver. See \c VA_CODED_BUF_STATUS_*. */
+    unsigned int        status;
+    /** \brief Reserved for future use. */
+    unsigned int        reserved;
+    /** \brief Pointer to the start of the data buffer. */
+    void               *buf;
+    /**
+     * \brief Pointer to the next #VACodedBufferSegment element,
+     * or \c NULL if there is none.
+     */
+    void               *next;
+} VACodedBufferSegment;
+     
+/**
+ * Map data store of the buffer into the client's address space
+ * vaCreateBuffer() needs to be called with "data" set to NULL before
+ * calling vaMapBuffer()
+ *
+ * if buffer type is VAEncCodedBufferType, pbuf points to link-list of
+ * VACodedBufferSegment, and the list is terminated if "next" is NULL
+ */
+VAStatus vaMapBuffer (
+    VADisplay dpy,
+    VABufferID buf_id,	/* in */
+    void **pbuf 	/* out */
+);
+
+/**
+ * After client making changes to a mapped data store, it needs to
+ * "Unmap" it to let the server know that the data is ready to be
+ * consumed by the server
+ */
+VAStatus vaUnmapBuffer (
+    VADisplay dpy,
+    VABufferID buf_id	/* in */
+);
+
+/**
+ * After this call, the buffer is deleted and this buffer_id is no longer valid
+ * Only call this if the buffer is not going to be passed to vaRenderBuffer
+ */
+VAStatus vaDestroyBuffer (
+    VADisplay dpy,
+    VABufferID buffer_id
+);
+
+/** \brief VA buffer information */
+typedef struct {
+    /** \brief Buffer handle */
+    uintptr_t           handle;
+    /** \brief Buffer type (See \ref VABufferType). */
+    uint32_t            type;
+    /**
+     * \brief Buffer memory type (See \ref VASurfaceAttribMemoryType).
+     *
+     * On input to vaAcquireBufferHandle(), this field can serve as a hint
+     * to specify the set of memory types the caller is interested in.
+     * On successful return from vaAcquireBufferHandle(), the field is
+     * updated with the best matching memory type.
+     */
+    uint32_t            mem_type;
+    /** \brief Size of the underlying buffer. */
+    size_t              mem_size;
+} VABufferInfo;
+
+/**
+ * \brief Acquires buffer handle for external API usage
+ *
+ * Locks the VA buffer object \ref buf_id for external API usage like
+ * EGL or OpenCL (OCL). This function is a synchronization point. This
+ * means that any pending operation is guaranteed to be completed
+ * prior to returning from the function.
+ *
+ * If the referenced VA buffer object is the backing store of a VA
+ * surface, then this function acts as if vaSyncSurface() on the
+ * parent surface was called first.
+ *
+ * The \ref VABufferInfo argument shall be zero'ed on input. On
+ * successful output, the data structure is filled in with all the
+ * necessary buffer level implementation details like handle, type,
+ * memory type and memory size.
+ *
+ * Note: the external API implementation, or the application, can
+ * express the memory types it is interested in by filling in the \ref
+ * mem_type field accordingly. On successful output, the memory type
+ * that fits best the request and that was used is updated in the \ref
+ * VABufferInfo data structure. If none of the supplied memory types
+ * is supported, then a \ref VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE
+ * error is returned.
+ *
+ * The \ref VABufferInfo data is valid until vaReleaseBufferHandle()
+ * is called. Besides, no additional operation is allowed on any of
+ * the buffer parent object until vaReleaseBufferHandle() is called.
+ * e.g. decoding into a VA surface backed with the supplied VA buffer
+ * object \ref buf_id would fail with a \ref VA_STATUS_ERROR_SURFACE_BUSY
+ * error.
+ *
+ * Possible errors:
+ * - \ref VA_STATUS_ERROR_UNIMPLEMENTED: the VA driver implementation
+ *   does not support this interface
+ * - \ref VA_STATUS_ERROR_INVALID_DISPLAY: an invalid display was supplied
+ * - \ref VA_STATUS_ERROR_INVALID_BUFFER: an invalid buffer was supplied
+ * - \ref VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE: the implementation
+ *   does not support exporting buffers of the specified type
+ * - \ref VA_STATUS_ERROR_UNSUPPORTED_MEMORY_TYPE: none of the requested
+ *   memory types in \ref VABufferInfo.mem_type was supported
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] buf_id            the VA buffer
+ * @param[in,out] buf_info      the associated VA buffer information
+ * @return VA_STATUS_SUCCESS if successful
+ */
+VAStatus
+vaAcquireBufferHandle(VADisplay dpy, VABufferID buf_id, VABufferInfo *buf_info);
+
+/**
+ * \brief Releases buffer after usage from external API
+ *
+ * Unlocks the VA buffer object \ref buf_id from external API usage like
+ * EGL or OpenCL (OCL). This function is a synchronization point. This
+ * means that any pending operation is guaranteed to be completed
+ * prior to returning from the function.
+ *
+ * The \ref VABufferInfo argument shall point to the original data
+ * structure that was obtained from vaAcquireBufferHandle(), unaltered.
+ * This is necessary so that the VA driver implementation could
+ * deallocate any resources that were needed.
+ *
+ * In any case, returning from this function invalidates any contents
+ * in \ref VABufferInfo. i.e. the underlyng buffer handle is no longer
+ * valid. Therefore, VA driver implementations are free to reset this
+ * data structure to safe defaults.
+ *
+ * Possible errors:
+ * - \ref VA_STATUS_ERROR_UNIMPLEMENTED: the VA driver implementation
+ *   does not support this interface
+ * - \ref VA_STATUS_ERROR_INVALID_DISPLAY: an invalid display was supplied
+ * - \ref VA_STATUS_ERROR_INVALID_BUFFER: an invalid buffer was supplied
+ * - \ref VA_STATUS_ERROR_UNSUPPORTED_BUFFERTYPE: the implementation
+ *   does not support exporting buffers of the specified type
+ *
+ * @param[in] dpy               the VA display
+ * @param[in] buf_id            the VA buffer
+ * @return VA_STATUS_SUCCESS if successful
+ */
+VAStatus
+vaReleaseBufferHandle(VADisplay dpy, VABufferID buf_id);
+
+/*
+Render (Decode) Pictures
+
+A picture represents either a frame or a field.
+
+The Begin/Render/End sequence sends the decode buffers to the server
+*/
+
+/**
+ * Get ready to decode a picture to a target surface
+ */
+VAStatus vaBeginPicture (
+    VADisplay dpy,
+    VAContextID context,
+    VASurfaceID render_target
+);
+
+/**
+ * Send decode buffers to the server.
+ * Buffers are automatically destroyed afterwards
+ */
+VAStatus vaRenderPicture (
+    VADisplay dpy,
+    VAContextID context,
+    VABufferID *buffers,
+    int num_buffers
+);
+
+/**
+ * Make the end of rendering for a picture. 
+ * The server should start processing all pending operations for this 
+ * surface. This call is non-blocking. The client can start another 
+ * Begin/Render/End sequence on a different render target.
+ */
+VAStatus vaEndPicture (
+    VADisplay dpy,
+    VAContextID context
+);
+
+/*
+
+Synchronization 
+
+*/
+
+/**
+ * This function blocks until all pending operations on the render target
+ * have been completed.  Upon return it is safe to use the render target for a 
+ * different picture. 
+ */
+VAStatus vaSyncSurface (
+    VADisplay dpy,
+    VASurfaceID render_target
+);
+
+typedef enum
+{
+    VASurfaceRendering	= 1, /* Rendering in progress */ 
+    VASurfaceDisplaying	= 2, /* Displaying in progress (not safe to render into it) */ 
+                             /* this status is useful if surface is used as the source */
+                             /* of an overlay */
+    VASurfaceReady	= 4, /* not being rendered or displayed */
+    VASurfaceSkipped	= 8  /* Indicate a skipped frame during encode */
+} VASurfaceStatus;
+
+/**
+ * Find out any pending ops on the render target 
+ */
+VAStatus vaQuerySurfaceStatus (
+    VADisplay dpy,
+    VASurfaceID render_target,
+    VASurfaceStatus *status	/* out */
+);
+
+typedef enum
+{
+    VADecodeSliceMissing            = 0,
+    VADecodeMBError                 = 1,
+} VADecodeErrorType;
+
+/**
+ * Client calls vaQuerySurfaceError with VA_STATUS_ERROR_DECODING_ERROR, server side returns
+ * an array of structure VASurfaceDecodeMBErrors, and the array is terminated by setting status=-1
+*/
+typedef struct _VASurfaceDecodeMBErrors
+{
+    int status; /* 1 if hardware has returned detailed info below, -1 means this record is invalid */
+    unsigned int start_mb; /* start mb address with errors */
+    unsigned int end_mb;  /* end mb address with errors */
+    VADecodeErrorType decode_error_type;
+} VASurfaceDecodeMBErrors;
+
+/**
+ * After the application gets VA_STATUS_ERROR_DECODING_ERROR after calling vaSyncSurface(),
+ * it can call vaQuerySurfaceError to find out further details on the particular error.
+ * VA_STATUS_ERROR_DECODING_ERROR should be passed in as "error_status",
+ * upon the return, error_info will point to an array of _VASurfaceDecodeMBErrors structure,
+ * which is allocated and filled by libVA with detailed information on the missing or error macroblocks.
+ * The array is terminated if "status==-1" is detected.
+ */
+VAStatus vaQuerySurfaceError(
+    VADisplay dpy,
+    VASurfaceID surface,
+    VAStatus error_status,
+    void **error_info
+);
+
+/**
+ * Images and Subpictures
+ * VAImage is used to either get the surface data to client memory, or 
+ * to copy image data in client memory to a surface. 
+ * Both images, subpictures and surfaces follow the same 2D coordinate system where origin 
+ * is at the upper left corner with positive X to the right and positive Y down
+ */
+#define VA_FOURCC(ch0, ch1, ch2, ch3) \
+    ((unsigned long)(unsigned char) (ch0) | ((unsigned long)(unsigned char) (ch1) << 8) | \
+    ((unsigned long)(unsigned char) (ch2) << 16) | ((unsigned long)(unsigned char) (ch3) << 24 ))
+
+/* 
+ * Pre-defined fourcc codes
+ */
+#define VA_FOURCC_NV12		0x3231564E
+#define VA_FOURCC_AI44		0x34344149
+#define VA_FOURCC_RGBA		0x41424752
+#define VA_FOURCC_RGBX		0x58424752
+#define VA_FOURCC_BGRA		0x41524742
+#define VA_FOURCC_BGRX		0x58524742
+#define VA_FOURCC_ARGB		0x42475241
+#define VA_FOURCC_XRGB		0x42475258
+#define VA_FOURCC_ABGR          0x52474241
+#define VA_FOURCC_XBGR          0x52474258
+#define VA_FOURCC_UYVY          0x59565955
+#define VA_FOURCC_YUY2          0x32595559
+#define VA_FOURCC_AYUV          0x56555941
+#define VA_FOURCC_NV11          0x3131564e
+#define VA_FOURCC_YV12          0x32315659
+#define VA_FOURCC_P208          0x38303250
+#define VA_FOURCC_IYUV          0x56555949
+#define VA_FOURCC_YV24          0x34325659
+#define VA_FOURCC_YV32          0x32335659
+#define VA_FOURCC_Y800          0x30303859
+#define VA_FOURCC_IMC3          0x33434D49
+#define VA_FOURCC_411P          0x50313134
+#define VA_FOURCC_422H          0x48323234
+#define VA_FOURCC_422V          0x56323234
+#define VA_FOURCC_444P          0x50343434
+#define VA_FOURCC_RGBP          0x50424752
+#define VA_FOURCC_BGRP          0x50524742
+#define VA_FOURCC_411R          0x52313134 /* rotated 411P */
+
+/* byte order */
+#define VA_LSB_FIRST		1
+#define VA_MSB_FIRST		2
+
+typedef struct _VAImageFormat
+{
+    unsigned int	fourcc;
+    unsigned int	byte_order; /* VA_LSB_FIRST, VA_MSB_FIRST */
+    unsigned int	bits_per_pixel;
+    /* for RGB formats */
+    unsigned int	depth; /* significant bits per pixel */
+    unsigned int	red_mask;
+    unsigned int	green_mask;
+    unsigned int	blue_mask;
+    unsigned int	alpha_mask;
+} VAImageFormat;
+
+typedef VAGenericID VAImageID;
+
+typedef struct _VAImage
+{
+    VAImageID		image_id; /* uniquely identify this image */
+    VAImageFormat	format;
+    VABufferID		buf;	/* image data buffer */
+    /*
+     * Image data will be stored in a buffer of type VAImageBufferType to facilitate
+     * data store on the server side for optimal performance. The buffer will be 
+     * created by the CreateImage function, and proper storage allocated based on the image
+     * size and format. This buffer is managed by the library implementation, and 
+     * accessed by the client through the buffer Map/Unmap functions.
+     */
+    unsigned short	width; 
+    unsigned short	height;
+    unsigned int	data_size;
+    unsigned int	num_planes;	/* can not be greater than 3 */
+    /* 
+     * An array indicating the scanline pitch in bytes for each plane.
+     * Each plane may have a different pitch. Maximum 3 planes for planar formats
+     */
+    unsigned int	pitches[3];
+    /* 
+     * An array indicating the byte offset from the beginning of the image data 
+     * to the start of each plane.
+     */
+    unsigned int	offsets[3];
+
+    /* The following fields are only needed for paletted formats */
+    int num_palette_entries;   /* set to zero for non-palette images */
+    /* 
+     * Each component is one byte and entry_bytes indicates the number of components in 
+     * each entry (eg. 3 for YUV palette entries). set to zero for non-palette images   
+     */
+    int entry_bytes; 
+    /*
+     * An array of ascii characters describing the order of the components within the bytes.
+     * Only entry_bytes characters of the string are used.
+     */
+    char component_order[4];
+} VAImage;
+
+/** Get maximum number of image formats supported by the implementation */
+int vaMaxNumImageFormats (
+    VADisplay dpy
+);
+
+/**
+ * Query supported image formats 
+ * The caller must provide a "format_list" array that can hold at
+ * least vaMaxNumImageFormats() entries. The actual number of formats
+ * returned in "format_list" is returned in "num_formats".
+ */
+VAStatus vaQueryImageFormats (
+    VADisplay dpy,
+    VAImageFormat *format_list,	/* out */
+    int *num_formats		/* out */
+);
+
+/**
+ * Create a VAImage structure
+ * The width and height fields returned in the VAImage structure may get 
+ * enlarged for some YUV formats. Upon return from this function, 
+ * image->buf has been created and proper storage allocated by the library. 
+ * The client can access the image through the Map/Unmap calls.
+ */
+VAStatus vaCreateImage (
+    VADisplay dpy,
+    VAImageFormat *format,
+    int width,
+    int height,
+    VAImage *image	/* out */
+);
+
+/**
+ * Should call DestroyImage before destroying the surface it is bound to
+ */
+VAStatus vaDestroyImage (
+    VADisplay dpy,
+    VAImageID image
+);
+
+VAStatus vaSetImagePalette (
+    VADisplay dpy,
+    VAImageID image,
+    /* 
+     * pointer to an array holding the palette data.  The size of the array is 
+     * num_palette_entries * entry_bytes in size.  The order of the components 
+     * in the palette is described by the component_order in VAImage struct    
+     */
+    unsigned char *palette 
+);
+
+/**
+ * Retrive surface data into a VAImage
+ * Image must be in a format supported by the implementation
+ */
+VAStatus vaGetImage (
+    VADisplay dpy,
+    VASurfaceID surface,
+    int x,	/* coordinates of the upper left source pixel */
+    int y,
+    unsigned int width, /* width and height of the region */
+    unsigned int height,
+    VAImageID image
+);
+
+/**
+ * Copy data from a VAImage to a surface
+ * Image must be in a format supported by the implementation
+ * Returns a VA_STATUS_ERROR_SURFACE_BUSY if the surface
+ * shouldn't be rendered into when this is called
+ */
+VAStatus vaPutImage (
+    VADisplay dpy,
+    VASurfaceID surface,
+    VAImageID image,
+    int src_x,
+    int src_y,
+    unsigned int src_width,
+    unsigned int src_height,
+    int dest_x,
+    int dest_y,
+    unsigned int dest_width,
+    unsigned int dest_height
+);
+
+/**
+ * Derive an VAImage from an existing surface.
+ * This interface will derive a VAImage and corresponding image buffer from
+ * an existing VA Surface. The image buffer can then be mapped/unmapped for
+ * direct CPU access. This operation is only possible on implementations with
+ * direct rendering capabilities and internal surface formats that can be
+ * represented with a VAImage. When the operation is not possible this interface
+ * will return VA_STATUS_ERROR_OPERATION_FAILED. Clients should then fall back
+ * to using vaCreateImage + vaPutImage to accomplish the same task in an
+ * indirect manner.
+ *
+ * Implementations should only return success when the resulting image buffer
+ * would be useable with vaMap/Unmap.
+ *
+ * When directly accessing a surface special care must be taken to insure
+ * proper synchronization with the graphics hardware. Clients should call
+ * vaQuerySurfaceStatus to insure that a surface is not the target of concurrent
+ * rendering or currently being displayed by an overlay.
+ *
+ * Additionally nothing about the contents of a surface should be assumed
+ * following a vaPutSurface. Implementations are free to modify the surface for
+ * scaling or subpicture blending within a call to vaPutImage.
+ *
+ * Calls to vaPutImage or vaGetImage using the same surface from which the image
+ * has been derived will return VA_STATUS_ERROR_SURFACE_BUSY. vaPutImage or
+ * vaGetImage with other surfaces is supported.
+ *
+ * An image created with vaDeriveImage should be freed with vaDestroyImage. The
+ * image and image buffer structures will be destroyed; however, the underlying
+ * surface will remain unchanged until freed with vaDestroySurfaces.
+ */
+VAStatus vaDeriveImage (
+    VADisplay dpy,
+    VASurfaceID surface,
+    VAImage *image	/* out */
+);
+
+/**
+ * Subpictures 
+ * Subpicture is a special type of image that can be blended 
+ * with a surface during vaPutSurface(). Subpicture can be used to render
+ * DVD sub-titles or closed captioning text etc.  
+ */
+
+typedef VAGenericID VASubpictureID;
+
+/** Get maximum number of subpicture formats supported by the implementation */
+int vaMaxNumSubpictureFormats (
+    VADisplay dpy
+);
+
+/** flags for subpictures */
+#define VA_SUBPICTURE_CHROMA_KEYING			0x0001
+#define VA_SUBPICTURE_GLOBAL_ALPHA			0x0002
+#define VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD	0x0004
+/**
+ * Query supported subpicture formats 
+ * The caller must provide a "format_list" array that can hold at
+ * least vaMaxNumSubpictureFormats() entries. The flags arrary holds the flag 
+ * for each format to indicate additional capabilities for that format. The actual 
+ * number of formats returned in "format_list" is returned in "num_formats".
+ *  flags: returned value to indicate addtional capabilities
+ *         VA_SUBPICTURE_CHROMA_KEYING - supports chroma-keying
+ *         VA_SUBPICTURE_GLOBAL_ALPHA - supports global alpha
+ * 	   VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD - supports unscaled screen relative subpictures for On Screen Display
+ */
+
+VAStatus vaQuerySubpictureFormats (
+    VADisplay dpy,
+    VAImageFormat *format_list,	/* out */
+    unsigned int *flags,	/* out */
+    unsigned int *num_formats	/* out */
+);
+
+/**
+ * Subpictures are created with an image associated. 
+ */
+VAStatus vaCreateSubpicture (
+    VADisplay dpy,
+    VAImageID image,
+    VASubpictureID *subpicture	/* out */
+);
+
+/**
+ * Destroy the subpicture before destroying the image it is assocated to
+ */
+VAStatus vaDestroySubpicture (
+    VADisplay dpy,
+    VASubpictureID subpicture
+);
+
+/**
+ * Bind an image to the subpicture. This image will now be associated with 
+ * the subpicture instead of the one at creation.
+ */
+VAStatus vaSetSubpictureImage (
+    VADisplay dpy,
+    VASubpictureID subpicture,
+    VAImageID image
+);
+
+/**
+ * If chromakey is enabled, then the area where the source value falls within
+ * the chromakey [min, max] range is transparent
+ * The chromakey component format is the following:
+ *  For RGB: [0:7] Red [8:15] Blue [16:23] Green   
+ *  For YUV: [0:7] V [8:15] U [16:23] Y
+ * The chromakey mask can be used to mask out certain components for chromakey
+ * comparision
+ */
+VAStatus vaSetSubpictureChromakey (
+    VADisplay dpy,
+    VASubpictureID subpicture,
+    unsigned int chromakey_min,
+    unsigned int chromakey_max,
+    unsigned int chromakey_mask
+);
+
+/**
+ * Global alpha value is between 0 and 1. A value of 1 means fully opaque and 
+ * a value of 0 means fully transparent. If per-pixel alpha is also specified then
+ * the overall alpha is per-pixel alpha multiplied by the global alpha
+ */
+VAStatus vaSetSubpictureGlobalAlpha (
+    VADisplay dpy,
+    VASubpictureID subpicture,
+    float global_alpha 
+);
+
+/**
+ * vaAssociateSubpicture associates the subpicture with target_surfaces.
+ * It defines the region mapping between the subpicture and the target  
+ * surfaces through source and destination rectangles (with the same width and height).
+ * Both will be displayed at the next call to vaPutSurface.  Additional
+ * associations before the call to vaPutSurface simply overrides the association.
+ */
+VAStatus vaAssociateSubpicture (
+    VADisplay dpy,
+    VASubpictureID subpicture,
+    VASurfaceID *target_surfaces,
+    int num_surfaces,
+    short src_x, /* upper left offset in subpicture */
+    short src_y,
+    unsigned short src_width,
+    unsigned short src_height,
+    short dest_x, /* upper left offset in surface */
+    short dest_y,
+    unsigned short dest_width,
+    unsigned short dest_height,
+    /*
+     * whether to enable chroma-keying, global-alpha, or screen relative mode
+     * see VA_SUBPICTURE_XXX values
+     */
+    unsigned int flags
+);
+
+/**
+ * vaDeassociateSubpicture removes the association of the subpicture with target_surfaces.
+ */
+VAStatus vaDeassociateSubpicture (
+    VADisplay dpy,
+    VASubpictureID subpicture,
+    VASurfaceID *target_surfaces,
+    int num_surfaces
+);
+
+typedef struct _VARectangle
+{
+    short x;
+    short y;
+    unsigned short width;
+    unsigned short height;
+} VARectangle;
+
+/**
+ * Display attributes
+ * Display attributes are used to control things such as contrast, hue, saturation,
+ * brightness etc. in the rendering process.  The application can query what
+ * attributes are supported by the driver, and then set the appropriate attributes
+ * before calling vaPutSurface()
+ */
+/* PowerVR IEP Lite attributes */
+typedef enum
+{
+    VADISPLAYATTRIB_BLE_OFF              = 0x00,
+    VADISPLAYATTRIB_BLE_LOW,
+    VADISPLAYATTRIB_BLE_MEDIUM,
+    VADISPLAYATTRIB_BLE_HIGH,
+    VADISPLAYATTRIB_BLE_NONE,
+} VADisplayAttribBLEMode;
+
+/** attribute value for VADisplayAttribRotation   */
+#define VA_ROTATION_NONE        0x00000000
+#define VA_ROTATION_90          0x00000001
+#define VA_ROTATION_180         0x00000002
+#define VA_ROTATION_270         0x00000003
+
+/** attribute value for VADisplayAttribOutOfLoopDeblock */
+#define VA_OOL_DEBLOCKING_FALSE 0x00000000
+#define VA_OOL_DEBLOCKING_TRUE  0x00000001
+
+/** Render mode */
+#define VA_RENDER_MODE_UNDEFINED           0
+#define VA_RENDER_MODE_LOCAL_OVERLAY       1
+#define VA_RENDER_MODE_LOCAL_GPU           2
+#define VA_RENDER_MODE_EXTERNAL_OVERLAY    4
+#define VA_RENDER_MODE_EXTERNAL_GPU        8
+
+/** Render device */
+#define VA_RENDER_DEVICE_UNDEFINED  0
+#define VA_RENDER_DEVICE_LOCAL      1
+#define VA_RENDER_DEVICE_EXTERNAL   2
+
+/** Currently defined display attribute types */
+typedef enum
+{
+    VADisplayAttribBrightness		= 0,
+    VADisplayAttribContrast		= 1,
+    VADisplayAttribHue			= 2,
+    VADisplayAttribSaturation		= 3,
+    /* client can specifiy a background color for the target window
+     * the new feature of video conference,
+     * the uncovered area of the surface is filled by this color
+     * also it will blend with the decoded video color
+     */
+    VADisplayAttribBackgroundColor      = 4,
+    /*
+     * this is a gettable only attribute. For some implementations that use the
+     * hardware overlay, after PutSurface is called, the surface can not be    
+     * re-used until after the subsequent PutSurface call. If this is the case 
+     * then the value for this attribute will be set to 1 so that the client   
+     * will not attempt to re-use the surface right after returning from a call
+     * to PutSurface.
+     *
+     * Don't use it, use flag VASurfaceDisplaying of vaQuerySurfaceStatus since
+     * driver may use overlay or GPU alternatively
+     */
+    VADisplayAttribDirectSurface       = 5,
+    VADisplayAttribRotation            = 6,	
+    VADisplayAttribOutofLoopDeblock    = 7,
+
+    /* PowerVR IEP Lite specific attributes */
+    VADisplayAttribBLEBlackMode        = 8,
+    VADisplayAttribBLEWhiteMode        = 9,
+    VADisplayAttribBlueStretch         = 10,
+    VADisplayAttribSkinColorCorrection = 11,
+    /*
+     * For type VADisplayAttribCSCMatrix, "value" field is a pointer to the color
+     * conversion matrix. Each element in the matrix is float-point
+     */
+    VADisplayAttribCSCMatrix           = 12,
+    /* specify the constant color used to blend with video surface
+     * Cd = Cv*Cc*Ac + Cb *(1 - Ac) C means the constant RGB
+     *      d: the final color to overwrite into the frame buffer 
+     *      v: decoded video after color conversion, 
+     *      c: video color specified by VADisplayAttribBlendColor
+     *      b: background color of the drawable
+     */
+    VADisplayAttribBlendColor          = 13,
+    /*
+     * Indicate driver to skip painting color key or not.
+     * only applicable if the render is overlay
+     */
+    VADisplayAttribOverlayAutoPaintColorKey   = 14,
+    /*
+     * customized overlay color key, the format is RGB888
+     * [23:16] = Red, [15:08] = Green, [07:00] = Blue.
+     */
+    VADisplayAttribOverlayColorKey	= 15,
+    /*
+     * The hint for the implementation of vaPutSurface
+     * normally, the driver could use an overlay or GPU to render the surface on the screen
+     * this flag provides APP the flexibity to switch the render dynamically
+     */
+    VADisplayAttribRenderMode           = 16,
+    /*
+     * specify if vaPutSurface needs to render into specified monitors
+     * one example is that one external monitor (e.g. HDMI) is enabled, 
+     * but the window manager is not aware of it, and there is no associated drawable
+     */
+    VADisplayAttribRenderDevice        = 17,
+    /*
+     * specify vaPutSurface render area if there is no drawable on the monitor
+     */
+    VADisplayAttribRenderRect          = 18,
+} VADisplayAttribType;
+
+/* flags for VADisplayAttribute */
+#define VA_DISPLAY_ATTRIB_NOT_SUPPORTED	0x0000
+#define VA_DISPLAY_ATTRIB_GETTABLE	0x0001
+#define VA_DISPLAY_ATTRIB_SETTABLE	0x0002
+
+typedef struct _VADisplayAttribute
+{
+    VADisplayAttribType type;
+    int min_value;
+    int max_value;
+    int value;	/* used by the set/get attribute functions */
+/* flags can be VA_DISPLAY_ATTRIB_GETTABLE or VA_DISPLAY_ATTRIB_SETTABLE or OR'd together */
+    unsigned int flags;
+} VADisplayAttribute;
+
+/** Get maximum number of display attributs supported by the implementation */
+int vaMaxNumDisplayAttributes (
+    VADisplay dpy
+);
+
+/**
+ * Query display attributes 
+ * The caller must provide a "attr_list" array that can hold at
+ * least vaMaxNumDisplayAttributes() entries. The actual number of attributes
+ * returned in "attr_list" is returned in "num_attributes".
+ */
+VAStatus vaQueryDisplayAttributes (
+    VADisplay dpy,
+    VADisplayAttribute *attr_list,	/* out */
+    int *num_attributes			/* out */
+);
+
+/**
+ * Get display attributes 
+ * This function returns the current attribute values in "attr_list".
+ * Only attributes returned with VA_DISPLAY_ATTRIB_GETTABLE set in the "flags" field
+ * from vaQueryDisplayAttributes() can have their values retrieved.  
+ */
+VAStatus vaGetDisplayAttributes (
+    VADisplay dpy,
+    VADisplayAttribute *attr_list,	/* in/out */
+    int num_attributes
+);
+
+/**
+ * Set display attributes 
+ * Only attributes returned with VA_DISPLAY_ATTRIB_SETTABLE set in the "flags" field
+ * from vaQueryDisplayAttributes() can be set.  If the attribute is not settable or 
+ * the value is out of range, the function returns VA_STATUS_ERROR_ATTR_NOT_SUPPORTED
+ */
+VAStatus vaSetDisplayAttributes (
+    VADisplay dpy,
+    VADisplayAttribute *attr_list,
+    int num_attributes
+);
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _VA_H_ */
diff --git a/lib/libv4l-hva/va/va_compat.h b/lib/libv4l-hva/va/va_compat.h
new file mode 100644
index 0000000..41a3f73
--- /dev/null
+++ b/lib/libv4l-hva/va/va_compat.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2007-2011 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_compat.h
+ * \brief The Compatibility API
+ *
+ * This file contains the \ref api_compat "Compatibility API".
+ */
+
+#ifndef VA_COMPAT_H
+#define VA_COMPAT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_compat Compatibility API
+ *
+ * The Compatibility API allows older programs that are not ported to
+ * the current API to still build and run correctly. In particular,
+ * this exposes older API to allow for backwards source compatibility.
+ *
+ * @{
+ */
+
+/**
+ * Makes a string literal out of the macro argument
+ */
+#define VA_CPP_HELPER_STRINGIFY(x) \
+    VA_CPP_HELPER_STRINGIFY_(x)
+#define VA_CPP_HELPER_STRINGIFY_(x) \
+    #x
+
+/**
+ * Concatenates two macro arguments at preprocessing time.
+ */
+#define VA_CPP_HELPER_CONCAT(a, b) \
+    VA_CPP_HELPER_CONCAT_(a, b)
+#define VA_CPP_HELPER_CONCAT_(a, b) \
+    a ## b
+
+/**
+ * Generates the number of macro arguments at preprocessing time.
+ * <http://groups.google.com/group/comp.std.c/browse_thread/thread/77ee8c8f92e4a3fb/346fc464319b1ee5>
+ *
+ * Note: this doesn't work for macros with no arguments
+ */
+#define VA_CPP_HELPER_N_ARGS(...) \
+    VA_CPP_HELPER_N_ARGS_(__VA_ARGS__, VA_CPP_HELPER_N_ARGS_LIST_REV())
+#define VA_CPP_HELPER_N_ARGS_(...) \
+    VA_CPP_HELPER_N_ARGS_LIST(__VA_ARGS__)
+#define VA_CPP_HELPER_N_ARGS_LIST(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a12, a13, a14, a15, a16, N, ...) N
+#define VA_CPP_HELPER_N_ARGS_LIST_REV() \
+    15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+
+/**
+ * Generates a versioned function alias.
+ *
+ * VA_CPP_HELPER_ALIAS(vaSomeFunction, 0,32,0) will generate
+ *   .symber vaSomeFunction_0_32_0, vaSomeFunction@VA_API_0.32.0
+ */
+#define VA_CPP_HELPER_ALIAS(func, major, minor, micro) \
+    VA_CPP_HELPER_ALIAS_(func, major, minor, micro, "@")
+#define VA_CPP_HELPER_ALIAS_DEFAULT(func, major, minor, micro) \
+    VA_CPP_HELPER_ALIAS_(func, major, minor, micro, "@@")
+#define VA_CPP_HELPER_ALIAS_(func, major, minor, micro, binding)        \
+    asm(".symver " #func "_" #major "_" #minor "_" #micro ", "          \
+        #func binding "VA_API_" #major "." #minor "." #micro)
+
+/* vaCreateSurfaces() */
+
+#ifndef VA_COMPAT_DISABLED
+#define vaCreateSurfaces(dpy, ...)                                      \
+    VA_CPP_HELPER_CONCAT(vaCreateSurfaces,                              \
+                         VA_CPP_HELPER_N_ARGS(dpy, __VA_ARGS__))        \
+    (dpy, __VA_ARGS__)
+#endif
+
+#define vaCreateSurfaces6(dpy, width, height, format, num_surfaces, surfaces) \
+    (vaCreateSurfaces)(dpy, format, width, height, surfaces, num_surfaces, \
+                       NULL, 0)
+
+#define vaCreateSurfaces8(dpy, format, width, height, surfaces, num_surfaces, attribs, num_attribs) \
+    (vaCreateSurfaces)(dpy, format, width, height, surfaces, num_surfaces, \
+                       attribs, num_attribs)
+
+/*@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_COMPAT_H */
diff --git a/lib/libv4l-hva/va/va_dec_jpeg.h b/lib/libv4l-hva/va/va_dec_jpeg.h
new file mode 100644
index 0000000..380e0fe
--- /dev/null
+++ b/lib/libv4l-hva/va/va_dec_jpeg.h
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2007-2012 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_dec_jpeg.h
+ * \brief The JPEG decoding API
+ *
+ * This file contains the \ref api_dec_jpeg "JPEG decoding API".
+ */
+
+#ifndef VA_DEC_JPEG_H
+#define VA_DEC_JPEG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <va/va.h>
+
+/**
+ * \defgroup api_dec_jpeg JPEG decoding API
+ *
+ * This JPEG decoding API supports Baseline profile only.
+ *
+ * @{
+ */
+
+/**
+ * \brief Picture parameter for JPEG decoding.
+ *
+ * This structure holds information from the frame header, along with
+ * definitions from additional segments.
+ */
+typedef struct _VAPictureParameterBufferJPEGBaseline {
+    /** \brief Picture width in pixels. */
+    unsigned short      picture_width;
+    /** \brief Picture height in pixels. */
+    unsigned short      picture_height;
+
+    struct {
+        /** \brief Component identifier (Ci). */
+        unsigned char   component_id;
+        /** \brief Horizontal sampling factor (Hi). */
+        unsigned char   h_sampling_factor;
+        /** \brief Vertical sampling factor (Vi). */
+        unsigned char   v_sampling_factor;
+        /* \brief Quantization table selector (Tqi). */
+        unsigned char   quantiser_table_selector;
+    }                   components[255];
+    /** \brief Number of components in frame (Nf). */
+    unsigned char       num_components;
+} VAPictureParameterBufferJPEGBaseline;
+
+/**
+ * \brief Quantization table for JPEG decoding.
+ *
+ * This structure holds the complete quantization tables. This is an
+ * aggregation of all quantization table (DQT) segments maintained by
+ * the application. i.e. up to 4 quantization tables are stored in
+ * there for baseline profile.
+ *
+ * The #load_quantization_table array can be used as a hint to notify
+ * the VA driver implementation about which table(s) actually changed
+ * since the last submission of this buffer.
+ *
+ * The #quantiser_table values are specified in zig-zag scan order.
+ */
+typedef struct _VAIQMatrixBufferJPEGBaseline {
+    /** \brief Specifies which #quantiser_table is valid. */
+    unsigned char       load_quantiser_table[4];
+    /** \brief Quanziation tables indexed by table identifier (Tqi). */
+    unsigned char       quantiser_table[4][64];
+} VAIQMatrixBufferJPEGBaseline;
+
+/**
+ * \brief Huffman table for JPEG decoding.
+ *
+ * This structure holds the complete Huffman tables. This is an
+ * aggregation of all Huffman table (DHT) segments maintained by the
+ * application. i.e. up to 2 Huffman tables are stored in there for
+ * baseline profile.
+ *
+ * The #load_huffman_table array can be used as a hint to notify the
+ * VA driver implementation about which table(s) actually changed
+ * since the last submission of this buffer.
+ */
+typedef struct _VAHuffmanTableBufferJPEGBaseline {
+    /** \brief Specifies which #huffman_table is valid. */
+    unsigned char       load_huffman_table[2];
+    /** \brief Huffman tables indexed by table identifier (Th). */
+    struct {
+        /** @name DC table (up to 12 categories) */
+        /**@{*/
+        /** \brief Number of Huffman codes of length i + 1 (Li). */
+        unsigned char   num_dc_codes[16];
+        /** \brief Value associated with each Huffman code (Vij). */
+        unsigned char   dc_values[12];
+        /**@}*/
+        /** @name AC table (2 special codes + up to 16 * 10 codes) */
+        /**@{*/
+        /** \brief Number of Huffman codes of length i + 1 (Li). */
+        unsigned char   num_ac_codes[16];
+        /** \brief Value associated with each Huffman code (Vij). */
+        unsigned char   ac_values[162];
+        /** \brief Padding to 4-byte boundaries. Must be set to zero. */
+        unsigned char   pad[2];
+        /**@}*/
+    }                   huffman_table[2];
+} VAHuffmanTableBufferJPEGBaseline;
+
+/**
+ * \brief Slice parameter for JPEG decoding.
+ *
+ * This structure holds information from the scan header, along with
+ * definitions from additional segments. The associated slice data
+ * buffer holds all entropy coded segments (ECS) in the scan.
+ */
+typedef struct _VASliceParameterBufferJPEGBaseline {
+    /** @name Codec-independent Slice Parameter Buffer base. */
+    /**@{*/
+    /** \brief Number of bytes in the slice data buffer for this slice. */
+    unsigned int        slice_data_size;
+    /** \brief The offset to the first byte of the first MCU. */
+    unsigned int        slice_data_offset;
+    /** \brief Slice data buffer flags. See \c VA_SLICE_DATA_FLAG_xxx. */
+    unsigned int        slice_data_flag;
+    /**@}*/
+
+    /** \brief Scan horizontal position. */
+    unsigned int        slice_horizontal_position;
+    /** \brief Scan vertical position. */
+    unsigned int        slice_vertical_position;
+
+    struct {
+        /** \brief Scan component selector (Csj). */
+        unsigned char   component_selector;
+        /** \brief DC entropy coding table selector (Tdj). */
+        unsigned char   dc_table_selector;
+        /** \brief AC entropy coding table selector (Taj). */
+        unsigned char   ac_table_selector;
+    }                   components[4];
+    /** \brief Number of components in scan (Ns). */
+    unsigned char       num_components;
+
+    /** \brief Restart interval definition (Ri). */
+    unsigned short      restart_interval;
+    /** \brief Number of MCUs in a scan. */
+    unsigned int        num_mcus;
+} VASliceParameterBufferJPEGBaseline;
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_DEC_JPEG_H */
diff --git a/lib/libv4l-hva/va/va_enc_h264.h b/lib/libv4l-hva/va/va_enc_h264.h
new file mode 100644
index 0000000..604877f
--- /dev/null
+++ b/lib/libv4l-hva/va/va_enc_h264.h
@@ -0,0 +1,592 @@
+/*
+ * Copyright (c) 2007-2011 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_enc_h264.h
+ * \brief The H.264 encoding API
+ *
+ * This file contains the \ref api_enc_h264 "H.264 encoding API".
+ */
+
+#ifndef VA_ENC_H264_H
+#define VA_ENC_H264_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_enc_h264 H.264 encoding API
+ *
+ * @{
+ */
+
+/**
+ * @name Picture flags
+ *
+ * Those flags flags are meant to signal when a picture marks the end
+ * of a sequence, a stream, or even both at once.
+ *
+ * @{
+ */
+/**
+ * \brief Marks the last picture in the sequence.
+ *
+ * i.e. the driver appends \c end_of_seq() NAL unit to the encoded frame.
+ */
+#define H264_LAST_PICTURE_EOSEQ     0x01
+/**
+ * \brief Marks the last picture in the stream.
+ *
+ * i.e. the driver appends \c end_of_stream() NAL unit to the encoded frame.
+ */
+#define H264_LAST_PICTURE_EOSTREAM  0x02
+/**@}*/
+
+/**
+ * \brief Packed header types specific to H.264 encoding.
+ *
+ * Types of packed headers generally used for H.264 encoding. Each
+ * associated packed header data buffer shall contain the start code
+ * prefix 0x000001 followed by the complete NAL unit, thus also
+ * including the \c nal_unit_type.
+ *
+ * Note: the start code prefix can contain an arbitrary number of leading
+ * zeros. The driver will skip them for emulation prevention bytes insertion,
+ * if necessary.
+ */
+typedef enum {
+    /**
+     * \brief Packed Sequence Parameter Set (SPS).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete seq_parameter_set_rbsp() syntax element.
+     *
+     * Note: packed \c nal_unit_type shall be equal to 7.
+     */
+    VAEncPackedHeaderH264_SPS   = VAEncPackedHeaderSequence,
+    /**
+     * \brief Packed Picture Parameter Set (PPS).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete pic_parameter_set_rbsp() syntax element.
+     *
+     * Note: packed \c nal_unit_type shall be equal to 8.
+     */
+    VAEncPackedHeaderH264_PPS   = VAEncPackedHeaderPicture,
+    /**
+     * \brief Packed slice header.
+     *
+     * The corresponding packed header data buffer shall contain the
+     * \c slice_header() syntax element only, along with any start
+     * code prefix and NAL unit type preceeding it. i.e. this means
+     * that the buffer does not contain any of the \c slice_data() or
+     * the \c rbsp_slice_trailing_bits().
+     *
+     * Note: packed \c nal_unit_type shall be equal to 1 (non-IDR
+     * picture), or 5 (IDR picture).
+     */
+    VAEncPackedHeaderH264_Slice = VAEncPackedHeaderSlice,
+    /**
+     * \brief Packed Supplemental Enhancement Information (SEI).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete sei_rbsp() syntax element, thus including several
+     * sei_message() elements if necessary.
+     *
+     * Note: packed \c nal_unit_type shall be equal to 6.
+     */
+    VAEncPackedHeaderH264_SEI   = (VAEncPackedHeaderMiscMask | 1),
+} VAEncPackedHeaderTypeH264;
+
+/**
+ * \brief Sequence parameter for H.264 encoding in baseline, main & high 
+ * profiles.
+ *
+ * This structure holds information for \c seq_parameter_set_data() as
+ * defined by the H.264 specification.
+ *
+ * If packed sequence headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_SEQUENCE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderSequence ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ * If \c seq_scaling_matrix_present_flag is set to \c 1, then a
+ * #VAIQMatrixBufferH264 buffer shall also be provided within the same
+ * \c vaRenderPicture() call as this sequence parameter buffer.
+ */
+typedef struct _VAEncSequenceParameterBufferH264 {
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   seq_parameter_set_id;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   level_idc;
+    /** \brief Period between I frames. */
+    unsigned int    intra_period;
+    /** \brief Period between IDR frames. */
+    unsigned int    intra_idr_period;
+    /** \brief Period between I/P frames. */
+    unsigned int    ip_period;
+    /**
+     * \brief Initial bitrate set for this sequence in CBR or VBR modes.
+     *
+     * This field represents the initial bitrate value for this
+     * sequence if CBR or VBR mode is used, i.e. if the encoder
+     * pipeline was created with a #VAConfigAttribRateControl
+     * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
+     *
+     * The bitrate can be modified later on through
+     * #VAEncMiscParameterRateControl buffers.
+     */
+    unsigned int    bits_per_second;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    max_num_ref_frames;
+    /** \brief Picture width in macroblocks. */
+    unsigned short  picture_width_in_mbs;
+    /** \brief Picture height in macroblocks. */
+    unsigned short  picture_height_in_mbs;
+
+    union {
+        struct {
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int chroma_format_idc                      : 2;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int frame_mbs_only_flag                    : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int mb_adaptive_frame_field_flag           : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int seq_scaling_matrix_present_flag        : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int direct_8x8_inference_flag              : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int log2_max_frame_num_minus4              : 4;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int pic_order_cnt_type                     : 2;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int log2_max_pic_order_cnt_lsb_minus4      : 4;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int delta_pic_order_always_zero_flag       : 1;
+        } bits;
+        unsigned int value;
+    } seq_fields;
+
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   bit_depth_luma_minus8;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   bit_depth_chroma_minus8;
+
+    /** if pic_order_cnt_type == 1 */
+    /**@{*/
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   num_ref_frames_in_pic_order_cnt_cycle;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    int             offset_for_non_ref_pic;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    int             offset_for_top_to_bottom_field;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    int             offset_for_ref_frame[256];
+    /**@}*/
+
+    /** @name Cropping (optional) */
+    /**@{*/
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   frame_cropping_flag;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    frame_crop_left_offset;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    frame_crop_right_offset;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    frame_crop_top_offset;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    frame_crop_bottom_offset;
+    /**@}*/
+
+    /** @name VUI parameters (optional) */
+    /**@{*/
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   vui_parameters_present_flag;
+    union {
+        struct {
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int aspect_ratio_info_present_flag         : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int timing_info_present_flag               : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int bitstream_restriction_flag             : 1;
+            /** \brief Range: 0 to 16, inclusive. */
+            unsigned int log2_max_mv_length_horizontal          : 5;
+            /** \brief Range: 0 to 16, inclusive. */
+            unsigned int log2_max_mv_length_vertical            : 5;
+        } bits;
+        unsigned int value;
+    } vui_fields;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   aspect_ratio_idc;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    sar_width;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    sar_height;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    num_units_in_tick;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned int    time_scale;
+    /**@}*/
+} VAEncSequenceParameterBufferH264;
+
+/**
+ * \brief Picture parameter for H.264 encoding in baseline, main & high 
+ * profiles.
+ *
+ * This structure holds information for \c pic_parameter_set_rbsp() as
+ * defined by the H.264 specification.
+ *
+ * If packed picture headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_PICTURE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderPicture ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ * If \c pic_scaling_matrix_present_flag is set to \c 1, then a
+ * #VAIQMatrixBufferH264 buffer shall also be provided within the same
+ * \c vaRenderPicture() call as this picture parameter buffer.
+ */
+typedef struct _VAEncPictureParameterBufferH264 {
+    /**
+     * \brief Information about the picture to be encoded.
+     *
+     * See #VAPictureH264 for further description of each field.
+     * Note that CurrPic.picture_id represents the reconstructed
+     * (decoded) picture. User provides a scratch VA surface ID here.
+     */
+    VAPictureH264   CurrPic;
+    /**
+     * \brief Decoded Picture Buffer (DPB).
+     *
+     * This array represents the list of reconstructed (decoded)
+     * frames used as reference. It is important to keep track of
+     * reconstructed frames so that they can be used later on as
+     * reference for P or B-frames encoding.
+     */
+    VAPictureH264   ReferenceFrames[16];
+    /**
+     * \brief Output encoded bitstream.
+     *
+     * \ref coded_buf has type #VAEncCodedBufferType. It should be
+     * large enough to hold the compressed NAL slice and possibly SPS
+     * and PPS NAL units.
+     */
+    VABufferID      coded_buf;
+
+    /** \brief The picture parameter set referred to in the slice header. */
+    unsigned char   pic_parameter_set_id;
+    /** \brief The active sequence parameter set. Range: 0 to 31, inclusive. */
+    unsigned char   seq_parameter_set_id;
+
+    /**
+     * \brief OR'd flags describing whether the picture is the last one or not.
+     *
+     * This fields holds 0 if the picture to be encoded is not the last
+     * one in the stream or sequence. Otherwise, it is a combination of
+     * \ref H264_LAST_PICTURE_EOSEQ or \ref H264_LAST_PICTURE_EOSTREAM.
+     */
+    unsigned char   last_picture;
+
+    /** \brief The picture identifier.
+     *   Range: 0 to \f$2^{log2\_max\_frame\_num\_minus4 + 4} - 1\f$, inclusive.
+     */
+    unsigned short  frame_num;
+
+    /** \brief \c pic_init_qp_minus26 + 26. */
+    unsigned char   pic_init_qp;
+    /** \brief Maximum reference index for reference picture list 0.
+     *   Range: 0 to 31, inclusive.
+     */
+    unsigned char   num_ref_idx_l0_active_minus1;
+    /** \brief Maximum reference index for reference picture list 1.
+     *  Range: 0 to 31, inclusive.
+     */
+    unsigned char   num_ref_idx_l1_active_minus1;
+
+    /** \brief Range: -12 to 12, inclusive. */
+    signed char     chroma_qp_index_offset;
+    /** \brief Range: -12 to 12, inclusive. */
+    signed char     second_chroma_qp_index_offset;
+
+    union {
+        struct {
+            /** \brief Is picture an IDR picture? */
+            unsigned int idr_pic_flag                           : 1;
+            /** \brief Is picture a reference picture? */
+            unsigned int reference_pic_flag                     : 2;
+            /** \brief Selects CAVLC (0) or CABAC (1) entropy coding mode. */
+            unsigned int entropy_coding_mode_flag               : 1;
+            /** \brief Is weighted prediction applied to P slices? */
+            unsigned int weighted_pred_flag                     : 1;
+            /** \brief Range: 0 to 2, inclusive. */
+            unsigned int weighted_bipred_idc                    : 2;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int constrained_intra_pred_flag            : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int transform_8x8_mode_flag                : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int deblocking_filter_control_present_flag : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int redundant_pic_cnt_present_flag         : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int pic_order_present_flag                 : 1;
+            /** \brief Same as the H.264 bitstream syntax element. */
+            unsigned int pic_scaling_matrix_present_flag        : 1;
+        } bits;
+        unsigned int value;
+    } pic_fields;
+} VAEncPictureParameterBufferH264;
+
+/**
+ * \brief Slice parameter for H.264 encoding in baseline, main & high profiles.
+ *
+ * This structure holds information for \c
+ * slice_layer_without_partitioning_rbsp() as defined by the H.264
+ * specification.
+ *
+ * If packed slice headers mode is used, i.e. if the encoding
+ * pipeline was configured with the #VA_ENC_PACKED_HEADER_SLICE
+ * flag, then the driver expects two more buffers to be provided to
+ * the same \c vaRenderPicture() as this buffer:
+ * - a #VAEncPackedHeaderParameterBuffer with type set to
+ *   VAEncPackedHeaderType::VAEncPackedHeaderSlice ;
+ * - a #VAEncPackedHeaderDataBuffer which holds the actual packed
+ *   header data.
+ *
+ * If per-macroblock encoder configuration is needed, \c macroblock_info
+ * references a buffer of type #VAEncMacroblockParameterBufferH264. This
+ * buffer is not passed to vaRenderPicture(). i.e. it is not destroyed
+ * by subsequent calls to vaRenderPicture() and then can be re-used
+ * without re-allocating the whole buffer.
+ */
+typedef struct _VAEncSliceParameterBufferH264 {
+    /** \brief Starting MB address for this slice. */
+    unsigned int    macroblock_address;
+    /** \brief Number of macroblocks in this slice. */
+    unsigned int    num_macroblocks;
+    /**
+     * \brief Per-MB encoder configuration buffer, or \c VA_INVALID_ID.
+     *
+     * If per-MB encoder configuration is needed, then \ref macroblock_info
+     * references a buffer of type #VAEncMacroblockParameterBufferH264
+     * (\c VAEncMacroblockParameterBufferType). Otherwise, buffer id
+     * is set to \c VA_INVALID_ID and per-MB configuration is derived
+     * from this slice parameter.
+     *
+     * The \c macroblock_info buffer must hold \ref num_macroblocks
+     * elements.
+     */
+    VABufferID      macroblock_info;
+    /** \brief Slice type.
+     *  Range: 0..2, 5..7, i.e. no switching slices.
+     */
+    unsigned char   slice_type;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   pic_parameter_set_id;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned short  idr_pic_id;
+
+    /** @name If pic_order_cnt_type == 0 */
+    /**@{*/
+    /** \brief The picture order count modulo MaxPicOrderCntLsb. */
+    unsigned short  pic_order_cnt_lsb;
+    /** \brief Valid if \c pic_order_present_flag and this is a bottom field. */
+    int             delta_pic_order_cnt_bottom;
+    /**@}*/
+    /** @name If pic_order_cnt_type == 1 && !delta_pic_order_always_zero_flag */
+    /**@{*/
+    /** \brief [0]: top, [1]: bottom. */
+    int             delta_pic_order_cnt[2];
+    /**@}*/
+
+    /** @name If slice_type == B */
+    /**@{*/
+    unsigned char   direct_spatial_mv_pred_flag;
+    /**@}*/
+
+    /** @name If slice_type == P */
+    /**@{*/
+    /** \brief Specifies if
+     * \ref _VAEncPictureParameterBufferH264::num_ref_idx_l0_active_minus1 or
+     * \ref _VAEncPictureParameterBufferH264::num_ref_idx_l1_active_minus1 are
+     * overriden by the values for this slice.
+     */
+    unsigned char   num_ref_idx_active_override_flag;
+    /** \brief Maximum reference index for reference picture list 0.
+     *  Range: 0 to 31, inclusive.
+     */
+    unsigned char   num_ref_idx_l0_active_minus1;
+    /** \brief Maximum reference index for reference picture list 1.
+     *  Range: 0 to 31, inclusive.
+     */
+    unsigned char   num_ref_idx_l1_active_minus1;
+    /** \brief Reference picture list 0 (for P slices). */
+    VAPictureH264   RefPicList0[32];
+    /** \brief Reference picture list 1 (for B slices). */
+    VAPictureH264   RefPicList1[32];
+    /**@}*/
+
+    /** @name pred_weight_table() */
+    /**@{*/
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   luma_log2_weight_denom;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   chroma_log2_weight_denom;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   luma_weight_l0_flag;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    luma_weight_l0[32];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    luma_offset_l0[32];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   chroma_weight_l0_flag;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    chroma_weight_l0[32][2];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    chroma_offset_l0[32][2];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   luma_weight_l1_flag;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    luma_weight_l1[32];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    luma_offset_l1[32];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    unsigned char   chroma_weight_l1_flag;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    chroma_weight_l1[32][2];
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed short    chroma_offset_l1[32][2];
+    /**@}*/
+
+    /** \brief Range: 0 to 2, inclusive. */
+    unsigned char   cabac_init_idc;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed char     slice_qp_delta;
+    /** @name If deblocking_filter_control_present_flag */
+    /**@{*/
+    /** \brief Range: 0 to 2, inclusive. */
+    unsigned char   disable_deblocking_filter_idc;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed char     slice_alpha_c0_offset_div2;
+    /** \brief Same as the H.264 bitstream syntax element. */
+    signed char     slice_beta_offset_div2;
+    /**@}*/
+} VAEncSliceParameterBufferH264;
+
+/**
+ * @name Macroblock neighbour availability bits
+ *
+ * \anchor api_enc_h264_mb_pred_avail_bits
+ * Definitions for macroblock neighbour availability bits used in
+ * intra prediction mode (non MBAFF only).
+ *
+ * @{
+ */
+/** \brief References macroblock in the top-left corner. */
+#define VA_MB_PRED_AVAIL_TOP_LEFT         (1 << 2)
+/** \brief References macroblock above the current macroblock. */
+#define VA_MB_PRED_AVAIL_TOP              (1 << 4)
+/** \brief References macroblock in the top-right corner. */
+#define VA_MB_PRED_AVAIL_TOP_RIGHT        (1 << 3)
+/** \brief References macroblock on the left of the current macroblock. */
+#define VA_MB_PRED_AVAIL_LEFT             (1 << 6)
+/**@}*/
+
+/**
+ * \brief Macroblock parameter for H.264 encoding in baseline, main & high 
+ * profiles.
+ *
+ * This structure holds per-macroblock information. The buffer must be
+ * allocated with as many elements (macroblocks) as necessary to fit
+ * the slice to be encoded. Besides, the per-macroblock records must
+ * be written in a strict raster order and with no gap. i.e. every
+ * macroblock, regardless of its type, shall have an entry.
+ */
+typedef struct _VAEncMacroblockParameterBufferH264 {
+    /**
+     * \brief Quantization parameter.
+     *
+     * Requested quantization parameter. Range: 0 to 51, inclusive.
+     * If \ref qp is set to 0xff, then the actual value is derived
+     * from the slice-level value: \c pic_init_qp + \c slice_qp_delta.
+     */
+    unsigned char   qp;
+
+    union {
+        /** @name Data for intra macroblock */
+        /**@{*/
+        struct {
+            union {
+                /**
+                 * \brief Flag specified to override MB neighbour
+                 * availability bits from VME stage.
+                 *
+                 * This flag specifies that macroblock neighbour
+                 * availability bits from the VME stage are overriden
+                 * by the \ref pred_avail_flags hereunder.
+                 */
+                unsigned int    pred_avail_override_flag        : 1;
+                /**
+                 * \brief Bitwise representation of which macroblocks
+                 * are available for intra prediction.
+                 *
+                 * If the slice is intra-coded, this field represents
+                 * the macroblocks available for intra prediction.
+                 * See \ref api_enc_h264_mb_pred_avail_bits
+                 * "macroblock neighbour availability" bit definitions.
+                 */
+                unsigned int    pred_avail_flags                : 8;
+            } bits;
+            unsigned int value;
+        } intra_fields;
+        /**@}*/
+
+        /** @name Data for inter macroblock */
+        /**@{*/
+        struct {
+            union {
+            } bits;
+            unsigned int value;
+        } inter_fields;
+        /**@}*/
+    } info;
+} VAEncMacroblockParameterBufferH264;
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_ENC_H264_H */
diff --git a/lib/libv4l-hva/va/va_version.h b/lib/libv4l-hva/va/va_version.h
new file mode 100644
index 0000000..c85da7a
--- /dev/null
+++ b/lib/libv4l-hva/va/va_version.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2009 Splitted-Desktop Systems. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef VA_VERSION_H
+#define VA_VERSION_H
+
+/**
+ * VA_MAJOR_VERSION:
+ *
+ * The major version of VA-API (1, if %VA_VERSION is 1.2.3)
+ */
+#define VA_MAJOR_VERSION    1
+
+/**
+ * VA_MINOR_VERSION:
+ *
+ * The minor version of VA-API (2, if %VA_VERSION is 1.2.3)
+ */
+#define VA_MINOR_VERSION    4
+
+/**
+ * VA_MICRO_VERSION:
+ *
+ * The micro version of VA-API (3, if %VA_VERSION is 1.2.3)
+ */
+#define VA_MICRO_VERSION    1
+/**
+ * VA_VERSION:
+ *
+ * The full version of VA-API, like 1.2.3
+ */
+#define VA_VERSION          1.4.1
+
+/**
+ * VA_VERSION_S:
+ *
+ * The full version of VA-API, in string form (suited for string
+ * concatenation)
+ */
+#define VA_VERSION_S       "1.4.1"
+/**
+ * VA_VERSION_HEX:
+ *
+ * Numerically encoded version of VA-API, like 0x010203
+ */
+#define VA_VERSION_HEX     ((VA_MAJOR_VERSION << 24) | \
+                            (VA_MINOR_VERSION << 16) | \
+                            (VA_MICRO_VERSION << 8))
+
+/**
+ * VA_CHECK_VERSION:
+ * @major: major version, like 1 in 1.2.3
+ * @minor: minor version, like 2 in 1.2.3
+ * @micro: micro version, like 3 in 1.2.3
+ *
+ * Evaluates to %TRUE if the version of VA-API is greater than
+ * @major, @minor and @micro
+ */
+#define VA_CHECK_VERSION(major,minor,micro) \
+        (VA_MAJOR_VERSION > (major) || \
+         (VA_MAJOR_VERSION == (major) && VA_MINOR_VERSION > (minor)) || \
+         (VA_MAJOR_VERSION == (major) && VA_MINOR_VERSION == (minor) && VA_MICRO_VERSION >= (micro)))
+
+#endif /* VA_VERSION_H */
-- 
2.7.4

